    <!DOCTYPE HTML>
    <!--- This page was autogenerated  By tsecheng -->
    <html>
        <!-- Header -->
        <head>
		        <Title>SQL Server Report</Title>            <!-- Styles -->
            
<style type="text/css">
* {    
    margin: 0px;
    font-family: sans-serif;
    font-size: 8pt;
}

body {
    margin: 8px 5px 8px 5px; 
}

h1 {
	margin: 8px 5px 8px 5px; 
    font-family: sans-serif;
    font-size: 18pt;
	border-bottom: 2px solid #bbbbbb; 
}

h2 {
	 margin: 8px 5px 8px 5px; 
    font-family: sans-serif;
    font-size: 16pt;
	border-bottom: 2px solid #bbbbbb; 
}

h3 {
	margin: 8px 5px 8px 5px; 
    font-family: sans-serif;
    font-size: 14pt;
	border-bottom: 1px solid #bbbbbb; 
}

h4 {
	margin: 8px 5px 8px 5px; 
    font-family: sans-serif;
    font-size: 12pt;
	border-bottom: 1px solid #bbbbbb; 
}

h5 {
	margin: 8px 5px 8px 5px; 
    font-family: sans-serif;
    font-size: 10pt;
	border-bottom: 1px solid #bbbbbb; 
}

h6 {
	margin: 8px 5px 8px 5px; 
    font-family: sans-serif;
    font-size: 8pt;
	border-bottom: 1px solid #bbbbbb; 
}

h7 {
    font-family: sans-serif;
    font-size: 10pt;
}


hr {
    height: 4px; 
    background-color: #337e94; 
    border: 0px;
	width: 99%;
}

table {
    table-layout: auto; 
    width: 100%;
    border-collapse: collapse;   
}

th {
    vertical-align: top; 
    text-align: left;
    padding: 2px 5px 2px 5px;
}

td {
    vertical-align: top; 
    padding: 2px 5px 2px 5px;
    border-top: 1px solid #bbbbbb;  
}

tr.totalrow {
    border-top: thick double
}

td.totalrow {
    vertical-align: Bottom; 
    text-align: left;
    font-size: 8pt; 
    font-weight: bold;
    padding: 2px 5px 2px 5px;
}

div.pageTitle {
    font-size: 14pt; 
    font-weight: bold;
	width: 100%;
    display: block;
    padding: 4px 1em 0px 2px; 
    height: 2em; 
}

div.ReportCreated {	
	text-align: right;
	padding-right: 5em;
}

div.clientlogo {
    border: 0px;
    vertical-align: middle;
    text-align: left;
    display: inline-block;
    width: 50%;
} 

div.MainLogo {
    border: 0px;
    vertical-align: middle;
    text-align: right;
    display: inline-block;
    width: 50%;
} 

div.section {
    border: 1px solid #bbbbbb; 
    padding-bottom: 12px;
    display: inline-block;
    margin: 5px;
    width: 98%
} 

div.header {
    padding: 4px 5em 0px 5px; 
    margin: 0px 0px 0px 0px;
    height: 2em; 
    font-weight: bold ;
    color: #ffffff;
    background-color: #337e94;
}

div.content {   
    padding: 4px 0px 5px 11px; 
    margin: 0px 0px 0px 0px;
    width: 95%; 
    color: #000000; 
    background-color: #f9f9f9;
}

div.footer {
    padding-right: 5em;
    text-align: right; 
}

table.fixed {
    table-layout: fixed; 
}

table.vertical {
	table-layout: fixed; width 100px; 
}

td.clientlogo {
    border: 0px;
	padding-left: 0px;
    vertical-align: middle;	
}

td.MainLogo {
    border: 0px; 
    padding-right: 5em;
    text-align: right; 
    vertical-align: middle;	
}

th.content { 
    border-top: 1px solid #bbbbbb; 
	width: 25%;
}

td.content { 
	width: 75%;
}

td.groupby {
	border-top: 3px double #bbbbbb;
}

.green {
	background-color: #a1cda4;
}

.yellow {
	background-color: #fffab1;
}

.red {
	background-color: #f5a085;
}

.odd {
	background-color: #D5D8DC;
}

.even {
	background-color: #F7F9F9;
}

.header {
	background-color: #616A6B; color: #F7F9F9;
}

div.column { width: 100%; float: left; }
div.first { width: 49% }
div.second { margin-left: 10px;width: 49% }

div.oneoftwo { width: 49% }
div.twooftwo { margin-left: 10px;width: 49% }

div.oneofthree { width: 32% }
div.twoofthree { margin-left: 10px;width: 32% }
div.threeofthree { margin-left: 10px;width: 32% }

div.oneoffour { width: 24% }
div.twooffour { margin-left: 10px;width: 24% }
div.threeoffour { margin-left: 10px;width: 24% }
div.fouroffour { margin-left: 10px;width: 24% }

div.oneoffive { width: 19% }
div.twooffive { margin-left: 10px;width: 19% }
div.threeoffive { margin-left: 10px;width: 19% }
div.fouroffive { margin-left: 10px;width: 19% }
div.fiveoffive { margin-left: 10px;width: 19% }

div.oneofsix { width: 16% }
div.twoofsix { margin-left: 10px;width: 16% }
div.threeofsix { margin-left: 10px;width: 16% }
div.fourofsix { margin-left: 10px;width: 16% }
div.fiveofsix { margin-left: 10px;width: 16% }
div.sixofsix { margin-left: 10px;width: 16% }


a.alink:link {color:#007BFF;text-decoration:none;font-size:120%}
a.alink:visited {color:#FF8400;text-decoration:none;font-size:120%}
a.alink:hover {text-decoration:underline;font-size:130%}

table.sortable thead {
    background-color:#eee;
    color:#666666;
    font-weight: bold;
    cursor: default;
}


/* Style the list */
ul.tab {
    list-style-type: none;
    margin: 0;
    padding: 0;
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
}

/* Float the list items side by side */
ul.tab li {float: left;}

/* Style the links inside the list items */
ul.tab li a {
    display: inline-block;
    color: black;
    text-align: center;
    padding: 10px 12px;
    text-decoration: none;
    transition: 0.3s;
    font-size: 14px;
}

/* Change background color of links on hover */
ul.tab li a:hover {background-color: #ddd;}

/* Create an active/current tablink class */
ul.tab li a:focus, .active {background-color: #ccc;}

/* Style the tab content */
.tabcontent {
    display: none;
    padding: 6px 8px;
    border: 1px solid #ccc;
    border-top: none;
}

.PowerShell {
  color: #EEEDF0;
  background-color: #012456;
  font-family: consolas;
  font-size: 0.99em;
  padding: .30em;
  padding-top: 0.25em;
  padding-right: 0.25em;
  padding-bottom: 0.25em;
  padding-left: 0.25em;
}

table.dataTable {
    width: 100%;
    margin: 0 auto;
    clear: both;
    border-collapse: separate;
    border-spacing: 0
}
table.dataTable thead th,
table.dataTable tfoot th {
    font-weight: bold
}
table.dataTable thead th,
table.dataTable thead td {
    padding: 10px 18px;
    border-bottom: 1px solid #111
}
table.dataTable thead th:active,
table.dataTable thead td:active {
    outline: none
}
table.dataTable tfoot th,
table.dataTable tfoot td {
    padding: 10px 18px 6px 18px;
    border-top: 1px solid #111
}
table.dataTable thead .sorting,
table.dataTable thead .sorting_asc,
table.dataTable thead .sorting_desc,
table.dataTable thead .sorting_asc_disabled,
table.dataTable thead .sorting_desc_disabled {
    cursor: pointer;
    *cursor: hand
}
table.dataTable thead .sorting,
table.dataTable thead .sorting_asc,
table.dataTable thead .sorting_desc,
table.dataTable thead .sorting_asc_disabled,
table.dataTable thead .sorting_desc_disabled {
    background-repeat: no-repeat;
    background-position: center right
}
table.dataTable thead .sorting {
    background-image: url("../images/sort_both.png")
}
table.dataTable thead .sorting_asc {
    background-image: url("../images/sort_asc.png")
}
table.dataTable thead .sorting_desc {
    background-image: url("../images/sort_desc.png")
}
table.dataTable thead .sorting_asc_disabled {
    background-image: url("../images/sort_asc_disabled.png")
}
table.dataTable thead .sorting_desc_disabled {
    background-image: url("../images/sort_desc_disabled.png")
}
table.dataTable tbody tr {
    background-color: #ffffff
}
table.dataTable tbody tr.selected {
    background-color: #B0BED9
}
table.dataTable tbody th,
table.dataTable tbody td {
    padding: 8px 10px
}
table.dataTable.row-border tbody th,
table.dataTable.row-border tbody td,
table.dataTable.display tbody th,
table.dataTable.display tbody td {
    border-top: 1px solid #ddd
}
table.dataTable.row-border tbody tr:first-child th,
table.dataTable.row-border tbody tr:first-child td,
table.dataTable.display tbody tr:first-child th,
table.dataTable.display tbody tr:first-child td {
    border-top: none
}
table.dataTable.cell-border tbody th,
table.dataTable.cell-border tbody td {
    border-top: 1px solid #ddd;
    border-right: 1px solid #ddd
}
table.dataTable.cell-border tbody tr th:first-child,
table.dataTable.cell-border tbody tr td:first-child {
    border-left: 1px solid #ddd
}
table.dataTable.cell-border tbody tr:first-child th,
table.dataTable.cell-border tbody tr:first-child td {
    border-top: none
}
table.dataTable.stripe tbody tr.odd,
table.dataTable.display tbody tr.odd {
    background-color: #f9f9f9
}
table.dataTable.stripe tbody tr.odd.selected,
table.dataTable.display tbody tr.odd.selected {
    background-color: #acbad4
}
table.dataTable.hover tbody tr:hover,
table.dataTable.display tbody tr:hover {
    background-color: #f6f6f6
}
table.dataTable.hover tbody tr:hover.selected,
table.dataTable.display tbody tr:hover.selected {
    background-color: #aab7d1
}
table.dataTable.order-column tbody tr>.sorting_1,
table.dataTable.order-column tbody tr>.sorting_2,
table.dataTable.order-column tbody tr>.sorting_3,
table.dataTable.display tbody tr>.sorting_1,
table.dataTable.display tbody tr>.sorting_2,
table.dataTable.display tbody tr>.sorting_3 {
    background-color: #fafafa
}
table.dataTable.order-column tbody tr.selected>.sorting_1,
table.dataTable.order-column tbody tr.selected>.sorting_2,
table.dataTable.order-column tbody tr.selected>.sorting_3,
table.dataTable.display tbody tr.selected>.sorting_1,
table.dataTable.display tbody tr.selected>.sorting_2,
table.dataTable.display tbody tr.selected>.sorting_3 {
    background-color: #acbad5
}
table.dataTable.display tbody tr.odd>.sorting_1,
table.dataTable.order-column.stripe tbody tr.odd>.sorting_1 {
    background-color: #f1f1f1
}
table.dataTable.display tbody tr.odd>.sorting_2,
table.dataTable.order-column.stripe tbody tr.odd>.sorting_2 {
    background-color: #f3f3f3
}
table.dataTable.display tbody tr.odd>.sorting_3,
table.dataTable.order-column.stripe tbody tr.odd>.sorting_3 {
    background-color: whitesmoke
}
table.dataTable.display tbody tr.odd.selected>.sorting_1,
table.dataTable.order-column.stripe tbody tr.odd.selected>.sorting_1 {
    background-color: #a6b4cd
}
table.dataTable.display tbody tr.odd.selected>.sorting_2,
table.dataTable.order-column.stripe tbody tr.odd.selected>.sorting_2 {
    background-color: #a8b5cf
}
table.dataTable.display tbody tr.odd.selected>.sorting_3,
table.dataTable.order-column.stripe tbody tr.odd.selected>.sorting_3 {
    background-color: #a9b7d1
}
table.dataTable.display tbody tr.even>.sorting_1,
table.dataTable.order-column.stripe tbody tr.even>.sorting_1 {
    background-color: #fafafa
}
table.dataTable.display tbody tr.even>.sorting_2,
table.dataTable.order-column.stripe tbody tr.even>.sorting_2 {
    background-color: #fcfcfc
}
table.dataTable.display tbody tr.even>.sorting_3,
table.dataTable.order-column.stripe tbody tr.even>.sorting_3 {
    background-color: #fefefe
}
table.dataTable.display tbody tr.even.selected>.sorting_1,
table.dataTable.order-column.stripe tbody tr.even.selected>.sorting_1 {
    background-color: #acbad5
}
table.dataTable.display tbody tr.even.selected>.sorting_2,
table.dataTable.order-column.stripe tbody tr.even.selected>.sorting_2 {
    background-color: #aebcd6
}
table.dataTable.display tbody tr.even.selected>.sorting_3,
table.dataTable.order-column.stripe tbody tr.even.selected>.sorting_3 {
    background-color: #afbdd8
}
table.dataTable.display tbody tr:hover>.sorting_1,
table.dataTable.order-column.hover tbody tr:hover>.sorting_1 {
    background-color: #eaeaea
}
table.dataTable.display tbody tr:hover>.sorting_2,
table.dataTable.order-column.hover tbody tr:hover>.sorting_2 {
    background-color: #ececec
}
table.dataTable.display tbody tr:hover>.sorting_3,
table.dataTable.order-column.hover tbody tr:hover>.sorting_3 {
    background-color: #efefef
}
table.dataTable.display tbody tr:hover.selected>.sorting_1,
table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_1 {
    background-color: #a2aec7
}
table.dataTable.display tbody tr:hover.selected>.sorting_2,
table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_2 {
    background-color: #a3b0c9
}
table.dataTable.display tbody tr:hover.selected>.sorting_3,
table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_3 {
    background-color: #a5b2cb
}
table.dataTable.no-footer {
    border-bottom: 1px solid #111
}
table.dataTable.nowrap th,
table.dataTable.nowrap td {
    white-space: nowrap
}
table.dataTable.compact thead th,
table.dataTable.compact thead td {
    padding: 4px 17px 4px 4px
}
table.dataTable.compact tfoot th,
table.dataTable.compact tfoot td {
    padding: 4px
}
table.dataTable.compact tbody th,
table.dataTable.compact tbody td {
    padding: 4px
}
table.dataTable th.dt-left,
table.dataTable td.dt-left {
    text-align: left
}
table.dataTable th.dt-center,
table.dataTable td.dt-center,
table.dataTable td.dataTables_empty {
    text-align: center
}
table.dataTable th.dt-right,
table.dataTable td.dt-right {
    text-align: right
}
table.dataTable th.dt-justify,
table.dataTable td.dt-justify {
    text-align: justify
}
table.dataTable th.dt-nowrap,
table.dataTable td.dt-nowrap {
    white-space: nowrap
}
table.dataTable thead th.dt-head-left,
table.dataTable thead td.dt-head-left,
table.dataTable tfoot th.dt-head-left,
table.dataTable tfoot td.dt-head-left {
    text-align: left
}
table.dataTable thead th.dt-head-center,
table.dataTable thead td.dt-head-center,
table.dataTable tfoot th.dt-head-center,
table.dataTable tfoot td.dt-head-center {
    text-align: center
}
table.dataTable thead th.dt-head-right,
table.dataTable thead td.dt-head-right,
table.dataTable tfoot th.dt-head-right,
table.dataTable tfoot td.dt-head-right {
    text-align: right
}
table.dataTable thead th.dt-head-justify,
table.dataTable thead td.dt-head-justify,
table.dataTable tfoot th.dt-head-justify,
table.dataTable tfoot td.dt-head-justify {
    text-align: justify
}
table.dataTable thead th.dt-head-nowrap,
table.dataTable thead td.dt-head-nowrap,
table.dataTable tfoot th.dt-head-nowrap,
table.dataTable tfoot td.dt-head-nowrap {
    white-space: nowrap
}
table.dataTable tbody th.dt-body-left,
table.dataTable tbody td.dt-body-left {
    text-align: left
}
table.dataTable tbody th.dt-body-center,
table.dataTable tbody td.dt-body-center {
    text-align: center
}
table.dataTable tbody th.dt-body-right,
table.dataTable tbody td.dt-body-right {
    text-align: right
}
table.dataTable tbody th.dt-body-justify,
table.dataTable tbody td.dt-body-justify {
    text-align: justify
}
table.dataTable tbody th.dt-body-nowrap,
table.dataTable tbody td.dt-body-nowrap {
    white-space: nowrap
}
table.dataTable,
table.dataTable th,
table.dataTable td {
    -webkit-box-sizing: content-box;
    box-sizing: content-box
}
.dataTables_wrapper {
    position: relative;
    clear: both;
    *zoom: 1;
    zoom: 1
}
.dataTables_wrapper .dataTables_length {
    float: left
}
.dataTables_wrapper .dataTables_filter {
    float: right;
    text-align: right
}
.dataTables_wrapper .dataTables_filter input {
    margin-left: 0.5em
}
.dataTables_wrapper .dataTables_info {
    clear: both;
    float: left;
    padding-top: 0.755em
}
.dataTables_wrapper .dataTables_paginate {
    float: right;
    text-align: right;
    padding-top: 0.25em
}
.dataTables_wrapper .dataTables_paginate .paginate_button {
    box-sizing: border-box;
    display: inline-block;
    min-width: 1.5em;
    padding: 0.5em 1em;
    margin-left: 2px;
    text-align: center;
    text-decoration: none !important;
    cursor: pointer;
    *cursor: hand;
    color: #333 !important;
    border: 1px solid transparent;
    border-radius: 2px
}
.dataTables_wrapper .dataTables_paginate .paginate_button.current,
.dataTables_wrapper .dataTables_paginate .paginate_button.current:hover {
    color: #333 !important;
    border: 1px solid #979797;
    background-color: white;
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #fff), color-stop(100%, #dcdcdc));
    background: -webkit-linear-gradient(top, #fff 0%, #dcdcdc 100%);
    background: -moz-linear-gradient(top, #fff 0%, #dcdcdc 100%);
    background: -ms-linear-gradient(top, #fff 0%, #dcdcdc 100%);
    background: -o-linear-gradient(top, #fff 0%, #dcdcdc 100%);
    background: linear-gradient(to bottom, #fff 0%, #dcdcdc 100%)
}
.dataTables_wrapper .dataTables_paginate .paginate_button.disabled,
.dataTables_wrapper .dataTables_paginate .paginate_button.disabled:hover,
.dataTables_wrapper .dataTables_paginate .paginate_button.disabled:active {
    cursor: default;
    color: #666 !important;
    border: 1px solid transparent;
    background: transparent;
    box-shadow: none
}
.dataTables_wrapper .dataTables_paginate .paginate_button:hover {
    color: white !important;
    border: 1px solid #111;
    background-color: #585858;
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #585858), color-stop(100%, #111));
    background: -webkit-linear-gradient(top, #585858 0%, #111 100%);
    background: -moz-linear-gradient(top, #585858 0%, #111 100%);
    background: -ms-linear-gradient(top, #585858 0%, #111 100%);
    background: -o-linear-gradient(top, #585858 0%, #111 100%);
    background: linear-gradient(to bottom, #585858 0%, #111 100%)
}
.dataTables_wrapper .dataTables_paginate .paginate_button:active {
    outline: none;
    background-color: #2b2b2b;
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #2b2b2b), color-stop(100%, #0c0c0c));
    background: -webkit-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
    background: -moz-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
    background: -ms-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
    background: -o-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
    background: linear-gradient(to bottom, #2b2b2b 0%, #0c0c0c 100%);
    box-shadow: inset 0 0 3px #111
}
.dataTables_wrapper .dataTables_paginate .ellipsis {
    padding: 0 1em
}
.dataTables_wrapper .dataTables_processing {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 40px;
    margin-left: -50%;
    margin-top: -25px;
    padding-top: 20px;
    text-align: center;
    font-size: 1.2em;
    background-color: white;
    background: -webkit-gradient(linear, left top, right top, color-stop(0%, rgba(255, 255, 255, 0)), color-stop(25%, rgba(255, 255, 255, 0.9)), color-stop(75%, rgba(255, 255, 255, 0.9)), color-stop(100%, rgba(255, 255, 255, 0)));
    background: -webkit-linear-gradient(left, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.9) 25%, rgba(255, 255, 255, 0.9) 75%, rgba(255, 255, 255, 0) 100%);
    background: -moz-linear-gradient(left, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.9) 25%, rgba(255, 255, 255, 0.9) 75%, rgba(255, 255, 255, 0) 100%);
    background: -ms-linear-gradient(left, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.9) 25%, rgba(255, 255, 255, 0.9) 75%, rgba(255, 255, 255, 0) 100%);
    background: -o-linear-gradient(left, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.9) 25%, rgba(255, 255, 255, 0.9) 75%, rgba(255, 255, 255, 0) 100%);
    background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.9) 25%, rgba(255, 255, 255, 0.9) 75%, rgba(255, 255, 255, 0) 100%)
}
.dataTables_wrapper .dataTables_length,
.dataTables_wrapper .dataTables_filter,
.dataTables_wrapper .dataTables_info,
.dataTables_wrapper .dataTables_processing,
.dataTables_wrapper .dataTables_paginate {
    color: #333
}
.dataTables_wrapper .dataTables_scroll {
    clear: both
}
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody {
    *margin-top: -1px;
    -webkit-overflow-scrolling: touch
}
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>th,
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>td,
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>th,
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>td {
    vertical-align: middle
}
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>th>div.dataTables_sizing,
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>td>div.dataTables_sizing,
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>th>div.dataTables_sizing,
.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>td>div.dataTables_sizing {
    height: 0;
    overflow: hidden;
    margin: 0 !important;
    padding: 0 !important
}
.dataTables_wrapper.no-footer .dataTables_scrollBody {
    border-bottom: 1px solid #111
}
.dataTables_wrapper.no-footer div.dataTables_scrollHead>table,
.dataTables_wrapper.no-footer div.dataTables_scrollBody>table {
    border-bottom: none
}
.dataTables_wrapper:after {
    visibility: hidden;
    display: block;
    content: "";
    clear: both;
    height: 0
}
@media screen and (max-width: 767px) {
    .dataTables_wrapper .dataTables_info,
    .dataTables_wrapper .dataTables_paginate {
        float: none;
        text-align: center
    }
    .dataTables_wrapper .dataTables_paginate {
        margin-top: 0.5em
    }
}
@media screen and (max-width: 640px) {
    .dataTables_wrapper .dataTables_length,
    .dataTables_wrapper .dataTables_filter {
        float: none;
        text-align: center
    }
    .dataTables_wrapper .dataTables_filter {
        margin-top: 0.5em
    }
}
</style>
            <!-- Scripts -->
            
<script type="text/javascript">  
 /*!
  * Chart.js
  * http://chartjs.org/
  * Version: 2.7.2
  *
  * Copyright 2018 Chart.js Contributors
  * Released under the MIT license
  * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
  */
 (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
 
 },{}],2:[function(require,module,exports){
 /* MIT license */
 var colorNames = require(6);
 
 module.exports = {
    getRgba: getRgba,
    getHsla: getHsla,
    getRgb: getRgb,
    getHsl: getHsl,
    getHwb: getHwb,
    getAlpha: getAlpha,
 
    hexString: hexString,
    rgbString: rgbString,
    rgbaString: rgbaString,
    percentString: percentString,
    percentaString: percentaString,
    hslString: hslString,
    hslaString: hslaString,
    hwbString: hwbString,
    keyword: keyword
 }
 
 function getRgba(string) {
    if (!string) {
       return;
    }
    var abbr =  /^#([a-fA-F0-9]{3})$/i,
        hex =  /^#([a-fA-F0-9]{6})$/i,
        rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
        per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
        keyword = /(\w+)/;
 
    var rgb = [0, 0, 0],
        a = 1,
        match = string.match(abbr);
    if (match) {
       match = match[1];
       for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
       }
    }
    else if (match = string.match(hex)) {
       match = match[1];
       for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
       }
    }
    else if (match = string.match(rgba)) {
       for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
       }
       a = parseFloat(match[4]);
    }
    else if (match = string.match(per)) {
       for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
       }
       a = parseFloat(match[4]);
    }
    else if (match = string.match(keyword)) {
       if (match[1] == "transparent") {
          return [0, 0, 0, 0];
       }
       rgb = colorNames[match[1]];
       if (!rgb) {
          return;
       }
    }
 
    for (var i = 0; i < rgb.length; i++) {
       rgb[i] = scale(rgb[i], 0, 255);
    }
    if (!a && a != 0) {
       a = 1;
    }
    else {
       a = scale(a, 0, 1);
    }
    rgb[3] = a;
    return rgb;
 }
 
 function getHsla(string) {
    if (!string) {
       return;
    }
    var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
    var match = string.match(hsl);
    if (match) {
       var alpha = parseFloat(match[4]);
       var h = scale(parseInt(match[1]), 0, 360),
           s = scale(parseFloat(match[2]), 0, 100),
           l = scale(parseFloat(match[3]), 0, 100),
           a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
       return [h, s, l, a];
    }
 }
 
 function getHwb(string) {
    if (!string) {
       return;
    }
    var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
    var match = string.match(hwb);
    if (match) {
     var alpha = parseFloat(match[4]);
       var h = scale(parseInt(match[1]), 0, 360),
           w = scale(parseFloat(match[2]), 0, 100),
           b = scale(parseFloat(match[3]), 0, 100),
           a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
       return [h, w, b, a];
    }
 }
 
 function getRgb(string) {
    var rgba = getRgba(string);
    return rgba && rgba.slice(0, 3);
 }
 
 function getHsl(string) {
   var hsla = getHsla(string);
   return hsla && hsla.slice(0, 3);
 }
 
 function getAlpha(string) {
    var vals = getRgba(string);
    if (vals) {
       return vals[3];
    }
    else if (vals = getHsla(string)) {
       return vals[3];
    }
    else if (vals = getHwb(string)) {
       return vals[3];
    }
 }
 
 // generators
 function hexString(rgb) {
    return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
               + hexDouble(rgb[2]);
 }
 
 function rgbString(rgba, alpha) {
    if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
       return rgbaString(rgba, alpha);
    }
    return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
 }
 
 function rgbaString(rgba, alpha) {
    if (alpha === undefined) {
       alpha = (rgba[3] !== undefined ? rgba[3] : 1);
    }
    return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
            + ", " + alpha + ")";
 }
 
 function percentString(rgba, alpha) {
    if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
       return percentaString(rgba, alpha);
    }
    var r = Math.round(rgba[0]/255 * 100),
        g = Math.round(rgba[1]/255 * 100),
        b = Math.round(rgba[2]/255 * 100);
 
    return "rgb(" + r + "%, " + g + "%, " + b + "%)";
 }
 
 function percentaString(rgba, alpha) {
    var r = Math.round(rgba[0]/255 * 100),
        g = Math.round(rgba[1]/255 * 100),
        b = Math.round(rgba[2]/255 * 100);
    return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
 }
 
 function hslString(hsla, alpha) {
    if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
       return hslaString(hsla, alpha);
    }
    return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
 }
 
 function hslaString(hsla, alpha) {
    if (alpha === undefined) {
       alpha = (hsla[3] !== undefined ? hsla[3] : 1);
    }
    return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
            + alpha + ")";
 }
 
 // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
 // (hwb have alpha optional & 1 is default value)
 function hwbString(hwb, alpha) {
    if (alpha === undefined) {
       alpha = (hwb[3] !== undefined ? hwb[3] : 1);
    }
    return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
            + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
 }
 
 function keyword(rgb) {
   return reverseNames[rgb.slice(0, 3)];
 }
 
 // helpers
 function scale(num, min, max) {
    return Math.min(Math.max(min, num), max);
 }
 
 function hexDouble(num) {
   var str = num.toString(16).toUpperCase();
   return (str.length < 2) ? "0" + str : str;
 }
 
 
 //create a list of reverse color names
 var reverseNames = {};
 for (var name in colorNames) {
    reverseNames[colorNames[name]] = name;
 }
 
 },{"6":6}],3:[function(require,module,exports){
 /* MIT license */
 var convert = require(5);
 var string = require(2);
 
 var Color = function (obj) {
 	if (obj instanceof Color) {
 		return obj;
 	}
 	if (!(this instanceof Color)) {
 		return new Color(obj);
 	}
 
 	this.valid = false;
 	this.values = {
 		rgb: [0, 0, 0],
 		hsl: [0, 0, 0],
 		hsv: [0, 0, 0],
 		hwb: [0, 0, 0],
 		cmyk: [0, 0, 0, 0],
 		alpha: 1
 	};
 
 	// parse Color() argument
 	var vals;
 	if (typeof obj === 'string') {
 		vals = string.getRgba(obj);
 		if (vals) {
 			this.setValues('rgb', vals);
 		} else if (vals = string.getHsla(obj)) {
 			this.setValues('hsl', vals);
 		} else if (vals = string.getHwb(obj)) {
 			this.setValues('hwb', vals);
 		}
 	} else if (typeof obj === 'object') {
 		vals = obj;
 		if (vals.r !== undefined || vals.red !== undefined) {
 			this.setValues('rgb', vals);
 		} else if (vals.l !== undefined || vals.lightness !== undefined) {
 			this.setValues('hsl', vals);
 		} else if (vals.v !== undefined || vals.value !== undefined) {
 			this.setValues('hsv', vals);
 		} else if (vals.w !== undefined || vals.whiteness !== undefined) {
 			this.setValues('hwb', vals);
 		} else if (vals.c !== undefined || vals.cyan !== undefined) {
 			this.setValues('cmyk', vals);
 		}
 	}
 };
 
 Color.prototype = {
 	isValid: function () {
 		return this.valid;
 	},
 	rgb: function () {
 		return this.setSpace('rgb', arguments);
 	},
 	hsl: function () {
 		return this.setSpace('hsl', arguments);
 	},
 	hsv: function () {
 		return this.setSpace('hsv', arguments);
 	},
 	hwb: function () {
 		return this.setSpace('hwb', arguments);
 	},
 	cmyk: function () {
 		return this.setSpace('cmyk', arguments);
 	},
 
 	rgbArray: function () {
 		return this.values.rgb;
 	},
 	hslArray: function () {
 		return this.values.hsl;
 	},
 	hsvArray: function () {
 		return this.values.hsv;
 	},
 	hwbArray: function () {
 		var values = this.values;
 		if (values.alpha !== 1) {
 			return values.hwb.concat([values.alpha]);
 		}
 		return values.hwb;
 	},
 	cmykArray: function () {
 		return this.values.cmyk;
 	},
 	rgbaArray: function () {
 		var values = this.values;
 		return values.rgb.concat([values.alpha]);
 	},
 	hslaArray: function () {
 		var values = this.values;
 		return values.hsl.concat([values.alpha]);
 	},
 	alpha: function (val) {
 		if (val === undefined) {
 			return this.values.alpha;
 		}
 		this.setValues('alpha', val);
 		return this;
 	},
 
 	red: function (val) {
 		return this.setChannel('rgb', 0, val);
 	},
 	green: function (val) {
 		return this.setChannel('rgb', 1, val);
 	},
 	blue: function (val) {
 		return this.setChannel('rgb', 2, val);
 	},
 	hue: function (val) {
 		if (val) {
 			val %= 360;
 			val = val < 0 ? 360 + val : val;
 		}
 		return this.setChannel('hsl', 0, val);
 	},
 	saturation: function (val) {
 		return this.setChannel('hsl', 1, val);
 	},
 	lightness: function (val) {
 		return this.setChannel('hsl', 2, val);
 	},
 	saturationv: function (val) {
 		return this.setChannel('hsv', 1, val);
 	},
 	whiteness: function (val) {
 		return this.setChannel('hwb', 1, val);
 	},
 	blackness: function (val) {
 		return this.setChannel('hwb', 2, val);
 	},
 	value: function (val) {
 		return this.setChannel('hsv', 2, val);
 	},
 	cyan: function (val) {
 		return this.setChannel('cmyk', 0, val);
 	},
 	magenta: function (val) {
 		return this.setChannel('cmyk', 1, val);
 	},
 	yellow: function (val) {
 		return this.setChannel('cmyk', 2, val);
 	},
 	black: function (val) {
 		return this.setChannel('cmyk', 3, val);
 	},
 
 	hexString: function () {
 		return string.hexString(this.values.rgb);
 	},
 	rgbString: function () {
 		return string.rgbString(this.values.rgb, this.values.alpha);
 	},
 	rgbaString: function () {
 		return string.rgbaString(this.values.rgb, this.values.alpha);
 	},
 	percentString: function () {
 		return string.percentString(this.values.rgb, this.values.alpha);
 	},
 	hslString: function () {
 		return string.hslString(this.values.hsl, this.values.alpha);
 	},
 	hslaString: function () {
 		return string.hslaString(this.values.hsl, this.values.alpha);
 	},
 	hwbString: function () {
 		return string.hwbString(this.values.hwb, this.values.alpha);
 	},
 	keyword: function () {
 		return string.keyword(this.values.rgb, this.values.alpha);
 	},
 
 	rgbNumber: function () {
 		var rgb = this.values.rgb;
 		return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
 	},
 
 	luminosity: function () {
 		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
 		var rgb = this.values.rgb;
 		var lum = [];
 		for (var i = 0; i < rgb.length; i++) {
 			var chan = rgb[i] / 255;
 			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
 		}
 		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
 	},
 
 	contrast: function (color2) {
 		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
 		var lum1 = this.luminosity();
 		var lum2 = color2.luminosity();
 		if (lum1 > lum2) {
 			return (lum1 + 0.05) / (lum2 + 0.05);
 		}
 		return (lum2 + 0.05) / (lum1 + 0.05);
 	},
 
 	level: function (color2) {
 		var contrastRatio = this.contrast(color2);
 		if (contrastRatio >= 7.1) {
 			return 'AAA';
 		}
 
 		return (contrastRatio >= 4.5) ? 'AA' : '';
 	},
 
 	dark: function () {
 		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
 		var rgb = this.values.rgb;
 		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
 		return yiq < 128;
 	},
 
 	light: function () {
 		return !this.dark();
 	},
 
 	negate: function () {
 		var rgb = [];
 		for (var i = 0; i < 3; i++) {
 			rgb[i] = 255 - this.values.rgb[i];
 		}
 		this.setValues('rgb', rgb);
 		return this;
 	},
 
 	lighten: function (ratio) {
 		var hsl = this.values.hsl;
 		hsl[2] += hsl[2] * ratio;
 		this.setValues('hsl', hsl);
 		return this;
 	},
 
 	darken: function (ratio) {
 		var hsl = this.values.hsl;
 		hsl[2] -= hsl[2] * ratio;
 		this.setValues('hsl', hsl);
 		return this;
 	},
 
 	saturate: function (ratio) {
 		var hsl = this.values.hsl;
 		hsl[1] += hsl[1] * ratio;
 		this.setValues('hsl', hsl);
 		return this;
 	},
 
 	desaturate: function (ratio) {
 		var hsl = this.values.hsl;
 		hsl[1] -= hsl[1] * ratio;
 		this.setValues('hsl', hsl);
 		return this;
 	},
 
 	whiten: function (ratio) {
 		var hwb = this.values.hwb;
 		hwb[1] += hwb[1] * ratio;
 		this.setValues('hwb', hwb);
 		return this;
 	},
 
 	blacken: function (ratio) {
 		var hwb = this.values.hwb;
 		hwb[2] += hwb[2] * ratio;
 		this.setValues('hwb', hwb);
 		return this;
 	},
 
 	greyscale: function () {
 		var rgb = this.values.rgb;
 		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
 		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
 		this.setValues('rgb', [val, val, val]);
 		return this;
 	},
 
 	clearer: function (ratio) {
 		var alpha = this.values.alpha;
 		this.setValues('alpha', alpha - (alpha * ratio));
 		return this;
 	},
 
 	opaquer: function (ratio) {
 		var alpha = this.values.alpha;
 		this.setValues('alpha', alpha + (alpha * ratio));
 		return this;
 	},
 
 	rotate: function (degrees) {
 		var hsl = this.values.hsl;
 		var hue = (hsl[0] + degrees) % 360;
 		hsl[0] = hue < 0 ? 360 + hue : hue;
 		this.setValues('hsl', hsl);
 		return this;
 	},
 
 	/**
 	 * Ported from sass implementation in C
 	 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
 	 */
 	mix: function (mixinColor, weight) {
 		var color1 = this;
 		var color2 = mixinColor;
 		var p = weight === undefined ? 0.5 : weight;
 
 		var w = 2 * p - 1;
 		var a = color1.alpha() - color2.alpha();
 
 		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
 		var w2 = 1 - w1;
 
 		return this
 			.rgb(
 				w1 * color1.red() + w2 * color2.red(),
 				w1 * color1.green() + w2 * color2.green(),
 				w1 * color1.blue() + w2 * color2.blue()
 			)
 			.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
 	},
 
 	toJSON: function () {
 		return this.rgb();
 	},
 
 	clone: function () {
 		// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
 		// making the final build way to big to embed in Chart.js. So let's do it manually,
 		// assuming that values to clone are 1 dimension arrays containing only numbers,
 		// except 'alpha' which is a number.
 		var result = new Color();
 		var source = this.values;
 		var target = result.values;
 		var value, type;
 
 		for (var prop in source) {
 			if (source.hasOwnProperty(prop)) {
 				value = source[prop];
 				type = ({}).toString.call(value);
 				if (type === '[object Array]') {
 					target[prop] = value.slice(0);
 				} else if (type === '[object Number]') {
 					target[prop] = value;
 				} else {
 					console.error('unexpected color value:', value);
 				}
 			}
 		}
 
 		return result;
 	}
 };
 
 Color.prototype.spaces = {
 	rgb: ['red', 'green', 'blue'],
 	hsl: ['hue', 'saturation', 'lightness'],
 	hsv: ['hue', 'saturation', 'value'],
 	hwb: ['hue', 'whiteness', 'blackness'],
 	cmyk: ['cyan', 'magenta', 'yellow', 'black']
 };
 
 Color.prototype.maxes = {
 	rgb: [255, 255, 255],
 	hsl: [360, 100, 100],
 	hsv: [360, 100, 100],
 	hwb: [360, 100, 100],
 	cmyk: [100, 100, 100, 100]
 };
 
 Color.prototype.getValues = function (space) {
 	var values = this.values;
 	var vals = {};
 
 	for (var i = 0; i < space.length; i++) {
 		vals[space.charAt(i)] = values[space][i];
 	}
 
 	if (values.alpha !== 1) {
 		vals.a = values.alpha;
 	}
 
 	// {r: 255, g: 255, b: 255, a: 0.4}
 	return vals;
 };
 
 Color.prototype.setValues = function (space, vals) {
 	var values = this.values;
 	var spaces = this.spaces;
 	var maxes = this.maxes;
 	var alpha = 1;
 	var i;
 
 	this.valid = true;
 
 	if (space === 'alpha') {
 		alpha = vals;
 	} else if (vals.length) {
 		// [10, 10, 10]
 		values[space] = vals.slice(0, space.length);
 		alpha = vals[space.length];
 	} else if (vals[space.charAt(0)] !== undefined) {
 		// {r: 10, g: 10, b: 10}
 		for (i = 0; i < space.length; i++) {
 			values[space][i] = vals[space.charAt(i)];
 		}
 
 		alpha = vals.a;
 	} else if (vals[spaces[space][0]] !== undefined) {
 		// {red: 10, green: 10, blue: 10}
 		var chans = spaces[space];
 
 		for (i = 0; i < space.length; i++) {
 			values[space][i] = vals[chans[i]];
 		}
 
 		alpha = vals.alpha;
 	}
 
 	values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));
 
 	if (space === 'alpha') {
 		return false;
 	}
 
 	var capped;
 
 	// cap values of the space prior converting all values
 	for (i = 0; i < space.length; i++) {
 		capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
 		values[space][i] = Math.round(capped);
 	}
 
 	// convert to all the other color spaces
 	for (var sname in spaces) {
 		if (sname !== space) {
 			values[sname] = convert[space][sname](values[space]);
 		}
 	}
 
 	return true;
 };
 
 Color.prototype.setSpace = function (space, args) {
 	var vals = args[0];
 
 	if (vals === undefined) {
 		// color.rgb()
 		return this.getValues(space);
 	}
 
 	// color.rgb(10, 10, 10)
 	if (typeof vals === 'number') {
 		vals = Array.prototype.slice.call(args);
 	}
 
 	this.setValues(space, vals);
 	return this;
 };
 
 Color.prototype.setChannel = function (space, index, val) {
 	var svalues = this.values[space];
 	if (val === undefined) {
 		// color.red()
 		return svalues[index];
 	} else if (val === svalues[index]) {
 		// color.red(color.red())
 		return this;
 	}
 
 	// color.red(100)
 	svalues[index] = val;
 	this.setValues(space, svalues);
 
 	return this;
 };
 
 if (typeof window !== 'undefined') {
 	window.Color = Color;
 }
 
 module.exports = Color;
 
 },{"2":2,"5":5}],4:[function(require,module,exports){
 /* MIT license */
 
 module.exports = {
   rgb2hsl: rgb2hsl,
   rgb2hsv: rgb2hsv,
   rgb2hwb: rgb2hwb,
   rgb2cmyk: rgb2cmyk,
   rgb2keyword: rgb2keyword,
   rgb2xyz: rgb2xyz,
   rgb2lab: rgb2lab,
   rgb2lch: rgb2lch,
 
   hsl2rgb: hsl2rgb,
   hsl2hsv: hsl2hsv,
   hsl2hwb: hsl2hwb,
   hsl2cmyk: hsl2cmyk,
   hsl2keyword: hsl2keyword,
 
   hsv2rgb: hsv2rgb,
   hsv2hsl: hsv2hsl,
   hsv2hwb: hsv2hwb,
   hsv2cmyk: hsv2cmyk,
   hsv2keyword: hsv2keyword,
 
   hwb2rgb: hwb2rgb,
   hwb2hsl: hwb2hsl,
   hwb2hsv: hwb2hsv,
   hwb2cmyk: hwb2cmyk,
   hwb2keyword: hwb2keyword,
 
   cmyk2rgb: cmyk2rgb,
   cmyk2hsl: cmyk2hsl,
   cmyk2hsv: cmyk2hsv,
   cmyk2hwb: cmyk2hwb,
   cmyk2keyword: cmyk2keyword,
 
   keyword2rgb: keyword2rgb,
   keyword2hsl: keyword2hsl,
   keyword2hsv: keyword2hsv,
   keyword2hwb: keyword2hwb,
   keyword2cmyk: keyword2cmyk,
   keyword2lab: keyword2lab,
   keyword2xyz: keyword2xyz,
 
   xyz2rgb: xyz2rgb,
   xyz2lab: xyz2lab,
   xyz2lch: xyz2lch,
 
   lab2xyz: lab2xyz,
   lab2rgb: lab2rgb,
   lab2lch: lab2lch,
 
   lch2lab: lch2lab,
   lch2xyz: lch2xyz,
   lch2rgb: lch2rgb
 }
 
 
 function rgb2hsl(rgb) {
   var r = rgb[0]/255,
       g = rgb[1]/255,
       b = rgb[2]/255,
       min = Math.min(r, g, b),
       max = Math.max(r, g, b),
       delta = max - min,
       h, s, l;
 
   if (max == min)
     h = 0;
   else if (r == max)
     h = (g - b) / delta;
   else if (g == max)
     h = 2 + (b - r) / delta;
   else if (b == max)
     h = 4 + (r - g)/ delta;
 
   h = Math.min(h * 60, 360);
 
   if (h < 0)
     h += 360;
 
   l = (min + max) / 2;
 
   if (max == min)
     s = 0;
   else if (l <= 0.5)
     s = delta / (max + min);
   else
     s = delta / (2 - max - min);
 
   return [h, s * 100, l * 100];
 }
 
 function rgb2hsv(rgb) {
   var r = rgb[0],
       g = rgb[1],
       b = rgb[2],
       min = Math.min(r, g, b),
       max = Math.max(r, g, b),
       delta = max - min,
       h, s, v;
 
   if (max == 0)
     s = 0;
   else
     s = (delta/max * 1000)/10;
 
   if (max == min)
     h = 0;
   else if (r == max)
     h = (g - b) / delta;
   else if (g == max)
     h = 2 + (b - r) / delta;
   else if (b == max)
     h = 4 + (r - g) / delta;
 
   h = Math.min(h * 60, 360);
 
   if (h < 0)
     h += 360;
 
   v = ((max / 255) * 1000) / 10;
 
   return [h, s, v];
 }
 
 function rgb2hwb(rgb) {
   var r = rgb[0],
       g = rgb[1],
       b = rgb[2],
       h = rgb2hsl(rgb)[0],
       w = 1/255 * Math.min(r, Math.min(g, b)),
       b = 1 - 1/255 * Math.max(r, Math.max(g, b));
 
   return [h, w * 100, b * 100];
 }
 
 function rgb2cmyk(rgb) {
   var r = rgb[0] / 255,
       g = rgb[1] / 255,
       b = rgb[2] / 255,
       c, m, y, k;
 
   k = Math.min(1 - r, 1 - g, 1 - b);
   c = (1 - r - k) / (1 - k) || 0;
   m = (1 - g - k) / (1 - k) || 0;
   y = (1 - b - k) / (1 - k) || 0;
   return [c * 100, m * 100, y * 100, k * 100];
 }
 
 function rgb2keyword(rgb) {
   return reverseKeywords[JSON.stringify(rgb)];
 }
 
 function rgb2xyz(rgb) {
   var r = rgb[0] / 255,
       g = rgb[1] / 255,
       b = rgb[2] / 255;
 
   // assume sRGB
   r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
   g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
   b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
 
   var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
   var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
   var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
 
   return [x * 100, y *100, z * 100];
 }
 
 function rgb2lab(rgb) {
   var xyz = rgb2xyz(rgb),
         x = xyz[0],
         y = xyz[1],
         z = xyz[2],
         l, a, b;
 
   x /= 95.047;
   y /= 100;
   z /= 108.883;
 
   x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
   y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
   z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
 
   l = (116 * y) - 16;
   a = 500 * (x - y);
   b = 200 * (y - z);
 
   return [l, a, b];
 }
 
 function rgb2lch(args) {
   return lab2lch(rgb2lab(args));
 }
 
 function hsl2rgb(hsl) {
   var h = hsl[0] / 360,
       s = hsl[1] / 100,
       l = hsl[2] / 100,
       t1, t2, t3, rgb, val;
 
   if (s == 0) {
     val = l * 255;
     return [val, val, val];
   }
 
   if (l < 0.5)
     t2 = l * (1 + s);
   else
     t2 = l + s - l * s;
   t1 = 2 * l - t2;
 
   rgb = [0, 0, 0];
   for (var i = 0; i < 3; i++) {
     t3 = h + 1 / 3 * - (i - 1);
     t3 < 0 && t3++;
     t3 > 1 && t3--;
 
     if (6 * t3 < 1)
       val = t1 + (t2 - t1) * 6 * t3;
     else if (2 * t3 < 1)
       val = t2;
     else if (3 * t3 < 2)
       val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
     else
       val = t1;
 
     rgb[i] = val * 255;
   }
 
   return rgb;
 }
 
 function hsl2hsv(hsl) {
   var h = hsl[0],
       s = hsl[1] / 100,
       l = hsl[2] / 100,
       sv, v;
 
   if(l === 0) {
       // no need to do calc on black
       // also avoids divide by 0 error
       return [0, 0, 0];
   }
 
   l *= 2;
   s *= (l <= 1) ? l : 2 - l;
   v = (l + s) / 2;
   sv = (2 * s) / (l + s);
   return [h, sv * 100, v * 100];
 }
 
 function hsl2hwb(args) {
   return rgb2hwb(hsl2rgb(args));
 }
 
 function hsl2cmyk(args) {
   return rgb2cmyk(hsl2rgb(args));
 }
 
 function hsl2keyword(args) {
   return rgb2keyword(hsl2rgb(args));
 }
 
 
 function hsv2rgb(hsv) {
   var h = hsv[0] / 60,
       s = hsv[1] / 100,
       v = hsv[2] / 100,
       hi = Math.floor(h) % 6;
 
   var f = h - Math.floor(h),
       p = 255 * v * (1 - s),
       q = 255 * v * (1 - (s * f)),
       t = 255 * v * (1 - (s * (1 - f))),
       v = 255 * v;
 
   switch(hi) {
     case 0:
       return [v, t, p];
     case 1:
       return [q, v, p];
     case 2:
       return [p, v, t];
     case 3:
       return [p, q, v];
     case 4:
       return [t, p, v];
     case 5:
       return [v, p, q];
   }
 }
 
 function hsv2hsl(hsv) {
   var h = hsv[0],
       s = hsv[1] / 100,
       v = hsv[2] / 100,
       sl, l;
 
   l = (2 - s) * v;
   sl = s * v;
   sl /= (l <= 1) ? l : 2 - l;
   sl = sl || 0;
   l /= 2;
   return [h, sl * 100, l * 100];
 }
 
 function hsv2hwb(args) {
   return rgb2hwb(hsv2rgb(args))
 }
 
 function hsv2cmyk(args) {
   return rgb2cmyk(hsv2rgb(args));
 }
 
 function hsv2keyword(args) {
   return rgb2keyword(hsv2rgb(args));
 }
 
 // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
 function hwb2rgb(hwb) {
   var h = hwb[0] / 360,
       wh = hwb[1] / 100,
       bl = hwb[2] / 100,
       ratio = wh + bl,
       i, v, f, n;
 
   // wh + bl cant be > 1
   if (ratio > 1) {
     wh /= ratio;
     bl /= ratio;
   }
 
   i = Math.floor(6 * h);
   v = 1 - bl;
   f = 6 * h - i;
   if ((i & 0x01) != 0) {
     f = 1 - f;
   }
   n = wh + f * (v - wh);  // linear interpolation
 
   switch (i) {
     default:
     case 6:
     case 0: r = v; g = n; b = wh; break;
     case 1: r = n; g = v; b = wh; break;
     case 2: r = wh; g = v; b = n; break;
     case 3: r = wh; g = n; b = v; break;
     case 4: r = n; g = wh; b = v; break;
     case 5: r = v; g = wh; b = n; break;
   }
 
   return [r * 255, g * 255, b * 255];
 }
 
 function hwb2hsl(args) {
   return rgb2hsl(hwb2rgb(args));
 }
 
 function hwb2hsv(args) {
   return rgb2hsv(hwb2rgb(args));
 }
 
 function hwb2cmyk(args) {
   return rgb2cmyk(hwb2rgb(args));
 }
 
 function hwb2keyword(args) {
   return rgb2keyword(hwb2rgb(args));
 }
 
 function cmyk2rgb(cmyk) {
   var c = cmyk[0] / 100,
       m = cmyk[1] / 100,
       y = cmyk[2] / 100,
       k = cmyk[3] / 100,
       r, g, b;
 
   r = 1 - Math.min(1, c * (1 - k) + k);
   g = 1 - Math.min(1, m * (1 - k) + k);
   b = 1 - Math.min(1, y * (1 - k) + k);
   return [r * 255, g * 255, b * 255];
 }
 
 function cmyk2hsl(args) {
   return rgb2hsl(cmyk2rgb(args));
 }
 
 function cmyk2hsv(args) {
   return rgb2hsv(cmyk2rgb(args));
 }
 
 function cmyk2hwb(args) {
   return rgb2hwb(cmyk2rgb(args));
 }
 
 function cmyk2keyword(args) {
   return rgb2keyword(cmyk2rgb(args));
 }
 
 
 function xyz2rgb(xyz) {
   var x = xyz[0] / 100,
       y = xyz[1] / 100,
       z = xyz[2] / 100,
       r, g, b;
 
   r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
   g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
   b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
 
   // assume sRGB
   r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
     : r = (r * 12.92);
 
   g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
     : g = (g * 12.92);
 
   b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
     : b = (b * 12.92);
 
   r = Math.min(Math.max(0, r), 1);
   g = Math.min(Math.max(0, g), 1);
   b = Math.min(Math.max(0, b), 1);
 
   return [r * 255, g * 255, b * 255];
 }
 
 function xyz2lab(xyz) {
   var x = xyz[0],
       y = xyz[1],
       z = xyz[2],
       l, a, b;
 
   x /= 95.047;
   y /= 100;
   z /= 108.883;
 
   x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
   y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
   z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
 
   l = (116 * y) - 16;
   a = 500 * (x - y);
   b = 200 * (y - z);
 
   return [l, a, b];
 }
 
 function xyz2lch(args) {
   return lab2lch(xyz2lab(args));
 }
 
 function lab2xyz(lab) {
   var l = lab[0],
       a = lab[1],
       b = lab[2],
       x, y, z, y2;
 
   if (l <= 8) {
     y = (l * 100) / 903.3;
     y2 = (7.787 * (y / 100)) + (16 / 116);
   } else {
     y = 100 * Math.pow((l + 16) / 116, 3);
     y2 = Math.pow(y / 100, 1/3);
   }
 
   x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);
 
   z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);
 
   return [x, y, z];
 }
 
 function lab2lch(lab) {
   var l = lab[0],
       a = lab[1],
       b = lab[2],
       hr, h, c;
 
   hr = Math.atan2(b, a);
   h = hr * 360 / 2 / Math.PI;
   if (h < 0) {
     h += 360;
   }
   c = Math.sqrt(a * a + b * b);
   return [l, c, h];
 }
 
 function lab2rgb(args) {
   return xyz2rgb(lab2xyz(args));
 }
 
 function lch2lab(lch) {
   var l = lch[0],
       c = lch[1],
       h = lch[2],
       a, b, hr;
 
   hr = h / 360 * 2 * Math.PI;
   a = c * Math.cos(hr);
   b = c * Math.sin(hr);
   return [l, a, b];
 }
 
 function lch2xyz(args) {
   return lab2xyz(lch2lab(args));
 }
 
 function lch2rgb(args) {
   return lab2rgb(lch2lab(args));
 }
 
 function keyword2rgb(keyword) {
   return cssKeywords[keyword];
 }
 
 function keyword2hsl(args) {
   return rgb2hsl(keyword2rgb(args));
 }
 
 function keyword2hsv(args) {
   return rgb2hsv(keyword2rgb(args));
 }
 
 function keyword2hwb(args) {
   return rgb2hwb(keyword2rgb(args));
 }
 
 function keyword2cmyk(args) {
   return rgb2cmyk(keyword2rgb(args));
 }
 
 function keyword2lab(args) {
   return rgb2lab(keyword2rgb(args));
 }
 
 function keyword2xyz(args) {
   return rgb2xyz(keyword2rgb(args));
 }
 
 var cssKeywords = {
   aliceblue:  [240,248,255],
   antiquewhite: [250,235,215],
   aqua: [0,255,255],
   aquamarine: [127,255,212],
   azure:  [240,255,255],
   beige:  [245,245,220],
   bisque: [255,228,196],
   black:  [0,0,0],
   blanchedalmond: [255,235,205],
   blue: [0,0,255],
   blueviolet: [138,43,226],
   brown:  [165,42,42],
   burlywood:  [222,184,135],
   cadetblue:  [95,158,160],
   chartreuse: [127,255,0],
   chocolate:  [210,105,30],
   coral:  [255,127,80],
   cornflowerblue: [100,149,237],
   cornsilk: [255,248,220],
   crimson:  [220,20,60],
   cyan: [0,255,255],
   darkblue: [0,0,139],
   darkcyan: [0,139,139],
   darkgoldenrod:  [184,134,11],
   darkgray: [169,169,169],
   darkgreen:  [0,100,0],
   darkgrey: [169,169,169],
   darkkhaki:  [189,183,107],
   darkmagenta:  [139,0,139],
   darkolivegreen: [85,107,47],
   darkorange: [255,140,0],
   darkorchid: [153,50,204],
   darkred:  [139,0,0],
   darksalmon: [233,150,122],
   darkseagreen: [143,188,143],
   darkslateblue:  [72,61,139],
   darkslategray:  [47,79,79],
   darkslategrey:  [47,79,79],
   darkturquoise:  [0,206,209],
   darkviolet: [148,0,211],
   deeppink: [255,20,147],
   deepskyblue:  [0,191,255],
   dimgray:  [105,105,105],
   dimgrey:  [105,105,105],
   dodgerblue: [30,144,255],
   firebrick:  [178,34,34],
   floralwhite:  [255,250,240],
   forestgreen:  [34,139,34],
   fuchsia:  [255,0,255],
   gainsboro:  [220,220,220],
   ghostwhite: [248,248,255],
   gold: [255,215,0],
   goldenrod:  [218,165,32],
   gray: [128,128,128],
   green:  [0,128,0],
   greenyellow:  [173,255,47],
   grey: [128,128,128],
   honeydew: [240,255,240],
   hotpink:  [255,105,180],
   indianred:  [205,92,92],
   indigo: [75,0,130],
   ivory:  [255,255,240],
   khaki:  [240,230,140],
   lavender: [230,230,250],
   lavenderblush:  [255,240,245],
   lawngreen:  [124,252,0],
   lemonchiffon: [255,250,205],
   lightblue:  [173,216,230],
   lightcoral: [240,128,128],
   lightcyan:  [224,255,255],
   lightgoldenrodyellow: [250,250,210],
   lightgray:  [211,211,211],
   lightgreen: [144,238,144],
   lightgrey:  [211,211,211],
   lightpink:  [255,182,193],
   lightsalmon:  [255,160,122],
   lightseagreen:  [32,178,170],
   lightskyblue: [135,206,250],
   lightslategray: [119,136,153],
   lightslategrey: [119,136,153],
   lightsteelblue: [176,196,222],
   lightyellow:  [255,255,224],
   lime: [0,255,0],
   limegreen:  [50,205,50],
   linen:  [250,240,230],
   magenta:  [255,0,255],
   maroon: [128,0,0],
   mediumaquamarine: [102,205,170],
   mediumblue: [0,0,205],
   mediumorchid: [186,85,211],
   mediumpurple: [147,112,219],
   mediumseagreen: [60,179,113],
   mediumslateblue:  [123,104,238],
   mediumspringgreen:  [0,250,154],
   mediumturquoise:  [72,209,204],
   mediumvioletred:  [199,21,133],
   midnightblue: [25,25,112],
   mintcream:  [245,255,250],
   mistyrose:  [255,228,225],
   moccasin: [255,228,181],
   navajowhite:  [255,222,173],
   navy: [0,0,128],
   oldlace:  [253,245,230],
   olive:  [128,128,0],
   olivedrab:  [107,142,35],
   orange: [255,165,0],
   orangered:  [255,69,0],
   orchid: [218,112,214],
   palegoldenrod:  [238,232,170],
   palegreen:  [152,251,152],
   paleturquoise:  [175,238,238],
   palevioletred:  [219,112,147],
   papayawhip: [255,239,213],
   peachpuff:  [255,218,185],
   peru: [205,133,63],
   pink: [255,192,203],
   plum: [221,160,221],
   powderblue: [176,224,230],
   purple: [128,0,128],
   rebeccapurple: [102, 51, 153],
   red:  [255,0,0],
   rosybrown:  [188,143,143],
   royalblue:  [65,105,225],
   saddlebrown:  [139,69,19],
   salmon: [250,128,114],
   sandybrown: [244,164,96],
   seagreen: [46,139,87],
   seashell: [255,245,238],
   sienna: [160,82,45],
   silver: [192,192,192],
   skyblue:  [135,206,235],
   slateblue:  [106,90,205],
   slategray:  [112,128,144],
   slategrey:  [112,128,144],
   snow: [255,250,250],
   springgreen:  [0,255,127],
   steelblue:  [70,130,180],
   tan:  [210,180,140],
   teal: [0,128,128],
   thistle:  [216,191,216],
   tomato: [255,99,71],
   turquoise:  [64,224,208],
   violet: [238,130,238],
   wheat:  [245,222,179],
   white:  [255,255,255],
   whitesmoke: [245,245,245],
   yellow: [255,255,0],
   yellowgreen:  [154,205,50]
 };
 
 var reverseKeywords = {};
 for (var key in cssKeywords) {
   reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
 }
 
 },{}],5:[function(require,module,exports){
 var conversions = require(4);
 
 var convert = function() {
    return new Converter();
 }
 
 for (var func in conversions) {
   // export Raw versions
   convert[func + "Raw"] =  (function(func) {
     // accept array or plain args
     return function(arg) {
       if (typeof arg == "number")
         arg = Array.prototype.slice.call(arguments);
       return conversions[func](arg);
     }
   })(func);
 
   var pair = /(\w+)2(\w+)/.exec(func),
       from = pair[1],
       to = pair[2];
 
   // export rgb2hsl and ["rgb"]["hsl"]
   convert[from] = convert[from] || {};
 
   convert[from][to] = convert[func] = (function(func) { 
     return function(arg) {
       if (typeof arg == "number")
         arg = Array.prototype.slice.call(arguments);
       
       var val = conversions[func](arg);
       if (typeof val == "string" || val === undefined)
         return val; // keyword
 
       for (var i = 0; i < val.length; i++)
         val[i] = Math.round(val[i]);
       return val;
     }
   })(func);
 }
 
 
 /* Converter does lazy conversion and caching */
 var Converter = function() {
    this.convs = {};
 };
 
 /* Either get the values for a space or
   set the values for a space, depending on args */
 Converter.prototype.routeSpace = function(space, args) {
    var values = args[0];
    if (values === undefined) {
       // color.rgb()
       return this.getValues(space);
    }
    // color.rgb(10, 10, 10)
    if (typeof values == "number") {
       values = Array.prototype.slice.call(args);        
    }
 
    return this.setValues(space, values);
 };
   
 /* Set the values for a space, invalidating cache */
 Converter.prototype.setValues = function(space, values) {
    this.space = space;
    this.convs = {};
    this.convs[space] = values;
    return this;
 };
 
 /* Get the values for a space. If there's already
   a conversion for the space, fetch it, otherwise
   compute it */
 Converter.prototype.getValues = function(space) {
    var vals = this.convs[space];
    if (!vals) {
       var fspace = this.space,
           from = this.convs[fspace];
       vals = convert[fspace][space](from);
 
       this.convs[space] = vals;
    }
   return vals;
 };
 
 ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
    Converter.prototype[space] = function(vals) {
       return this.routeSpace(space, arguments);
    }
 });
 
 module.exports = convert;
 },{"4":4}],6:[function(require,module,exports){
 'use strict'
 
 module.exports = {
 	"aliceblue": [240, 248, 255],
 	"antiquewhite": [250, 235, 215],
 	"aqua": [0, 255, 255],
 	"aquamarine": [127, 255, 212],
 	"azure": [240, 255, 255],
 	"beige": [245, 245, 220],
 	"bisque": [255, 228, 196],
 	"black": [0, 0, 0],
 	"blanchedalmond": [255, 235, 205],
 	"blue": [0, 0, 255],
 	"blueviolet": [138, 43, 226],
 	"brown": [165, 42, 42],
 	"burlywood": [222, 184, 135],
 	"cadetblue": [95, 158, 160],
 	"chartreuse": [127, 255, 0],
 	"chocolate": [210, 105, 30],
 	"coral": [255, 127, 80],
 	"cornflowerblue": [100, 149, 237],
 	"cornsilk": [255, 248, 220],
 	"crimson": [220, 20, 60],
 	"cyan": [0, 255, 255],
 	"darkblue": [0, 0, 139],
 	"darkcyan": [0, 139, 139],
 	"darkgoldenrod": [184, 134, 11],
 	"darkgray": [169, 169, 169],
 	"darkgreen": [0, 100, 0],
 	"darkgrey": [169, 169, 169],
 	"darkkhaki": [189, 183, 107],
 	"darkmagenta": [139, 0, 139],
 	"darkolivegreen": [85, 107, 47],
 	"darkorange": [255, 140, 0],
 	"darkorchid": [153, 50, 204],
 	"darkred": [139, 0, 0],
 	"darksalmon": [233, 150, 122],
 	"darkseagreen": [143, 188, 143],
 	"darkslateblue": [72, 61, 139],
 	"darkslategray": [47, 79, 79],
 	"darkslategrey": [47, 79, 79],
 	"darkturquoise": [0, 206, 209],
 	"darkviolet": [148, 0, 211],
 	"deeppink": [255, 20, 147],
 	"deepskyblue": [0, 191, 255],
 	"dimgray": [105, 105, 105],
 	"dimgrey": [105, 105, 105],
 	"dodgerblue": [30, 144, 255],
 	"firebrick": [178, 34, 34],
 	"floralwhite": [255, 250, 240],
 	"forestgreen": [34, 139, 34],
 	"fuchsia": [255, 0, 255],
 	"gainsboro": [220, 220, 220],
 	"ghostwhite": [248, 248, 255],
 	"gold": [255, 215, 0],
 	"goldenrod": [218, 165, 32],
 	"gray": [128, 128, 128],
 	"green": [0, 128, 0],
 	"greenyellow": [173, 255, 47],
 	"grey": [128, 128, 128],
 	"honeydew": [240, 255, 240],
 	"hotpink": [255, 105, 180],
 	"indianred": [205, 92, 92],
 	"indigo": [75, 0, 130],
 	"ivory": [255, 255, 240],
 	"khaki": [240, 230, 140],
 	"lavender": [230, 230, 250],
 	"lavenderblush": [255, 240, 245],
 	"lawngreen": [124, 252, 0],
 	"lemonchiffon": [255, 250, 205],
 	"lightblue": [173, 216, 230],
 	"lightcoral": [240, 128, 128],
 	"lightcyan": [224, 255, 255],
 	"lightgoldenrodyellow": [250, 250, 210],
 	"lightgray": [211, 211, 211],
 	"lightgreen": [144, 238, 144],
 	"lightgrey": [211, 211, 211],
 	"lightpink": [255, 182, 193],
 	"lightsalmon": [255, 160, 122],
 	"lightseagreen": [32, 178, 170],
 	"lightskyblue": [135, 206, 250],
 	"lightslategray": [119, 136, 153],
 	"lightslategrey": [119, 136, 153],
 	"lightsteelblue": [176, 196, 222],
 	"lightyellow": [255, 255, 224],
 	"lime": [0, 255, 0],
 	"limegreen": [50, 205, 50],
 	"linen": [250, 240, 230],
 	"magenta": [255, 0, 255],
 	"maroon": [128, 0, 0],
 	"mediumaquamarine": [102, 205, 170],
 	"mediumblue": [0, 0, 205],
 	"mediumorchid": [186, 85, 211],
 	"mediumpurple": [147, 112, 219],
 	"mediumseagreen": [60, 179, 113],
 	"mediumslateblue": [123, 104, 238],
 	"mediumspringgreen": [0, 250, 154],
 	"mediumturquoise": [72, 209, 204],
 	"mediumvioletred": [199, 21, 133],
 	"midnightblue": [25, 25, 112],
 	"mintcream": [245, 255, 250],
 	"mistyrose": [255, 228, 225],
 	"moccasin": [255, 228, 181],
 	"navajowhite": [255, 222, 173],
 	"navy": [0, 0, 128],
 	"oldlace": [253, 245, 230],
 	"olive": [128, 128, 0],
 	"olivedrab": [107, 142, 35],
 	"orange": [255, 165, 0],
 	"orangered": [255, 69, 0],
 	"orchid": [218, 112, 214],
 	"palegoldenrod": [238, 232, 170],
 	"palegreen": [152, 251, 152],
 	"paleturquoise": [175, 238, 238],
 	"palevioletred": [219, 112, 147],
 	"papayawhip": [255, 239, 213],
 	"peachpuff": [255, 218, 185],
 	"peru": [205, 133, 63],
 	"pink": [255, 192, 203],
 	"plum": [221, 160, 221],
 	"powderblue": [176, 224, 230],
 	"purple": [128, 0, 128],
 	"rebeccapurple": [102, 51, 153],
 	"red": [255, 0, 0],
 	"rosybrown": [188, 143, 143],
 	"royalblue": [65, 105, 225],
 	"saddlebrown": [139, 69, 19],
 	"salmon": [250, 128, 114],
 	"sandybrown": [244, 164, 96],
 	"seagreen": [46, 139, 87],
 	"seashell": [255, 245, 238],
 	"sienna": [160, 82, 45],
 	"silver": [192, 192, 192],
 	"skyblue": [135, 206, 235],
 	"slateblue": [106, 90, 205],
 	"slategray": [112, 128, 144],
 	"slategrey": [112, 128, 144],
 	"snow": [255, 250, 250],
 	"springgreen": [0, 255, 127],
 	"steelblue": [70, 130, 180],
 	"tan": [210, 180, 140],
 	"teal": [0, 128, 128],
 	"thistle": [216, 191, 216],
 	"tomato": [255, 99, 71],
 	"turquoise": [64, 224, 208],
 	"violet": [238, 130, 238],
 	"wheat": [245, 222, 179],
 	"white": [255, 255, 255],
 	"whitesmoke": [245, 245, 245],
 	"yellow": [255, 255, 0],
 	"yellowgreen": [154, 205, 50]
 };
 
 },{}],7:[function(require,module,exports){
 /**
  * @namespace Chart
  */
 var Chart = require(29)();
 
 Chart.helpers = require(45);
 
 // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
 require(27)(Chart);
 
 Chart.defaults = require(25);
 Chart.Element = require(26);
 Chart.elements = require(40);
 Chart.Interaction = require(28);
 Chart.layouts = require(30);
 Chart.platform = require(48);
 Chart.plugins = require(31);
 Chart.Ticks = require(34);
 
 require(22)(Chart);
 require(23)(Chart);
 require(24)(Chart);
 require(33)(Chart);
 require(32)(Chart);
 require(35)(Chart);
 
 require(55)(Chart);
 require(53)(Chart);
 require(54)(Chart);
 require(56)(Chart);
 require(57)(Chart);
 require(58)(Chart);
 
 // Controllers must be loaded after elements
 // See Chart.core.datasetController.dataElementType
 require(15)(Chart);
 require(16)(Chart);
 require(17)(Chart);
 require(18)(Chart);
 require(19)(Chart);
 require(20)(Chart);
 require(21)(Chart);
 
 require(8)(Chart);
 require(9)(Chart);
 require(10)(Chart);
 require(11)(Chart);
 require(12)(Chart);
 require(13)(Chart);
 require(14)(Chart);
 
 // Loading built-it plugins
 var plugins = require(49);
 for (var k in plugins) {
 	if (plugins.hasOwnProperty(k)) {
 		Chart.plugins.register(plugins[k]);
 	}
 }
 
 Chart.platform.initialize();
 
 module.exports = Chart;
 if (typeof window !== 'undefined') {
 	window.Chart = Chart;
 }
 
 // DEPRECATIONS
 
 /**
  * Provided for backward compatibility, not available anymore
  * @namespace Chart.Legend
  * @deprecated since version 2.1.5
  * @todo remove at version 3
  * @private
  */
 Chart.Legend = plugins.legend._element;
 
 /**
  * Provided for backward compatibility, not available anymore
  * @namespace Chart.Title
  * @deprecated since version 2.1.5
  * @todo remove at version 3
  * @private
  */
 Chart.Title = plugins.title._element;
 
 /**
  * Provided for backward compatibility, use Chart.plugins instead
  * @namespace Chart.pluginService
  * @deprecated since version 2.1.5
  * @todo remove at version 3
  * @private
  */
 Chart.pluginService = Chart.plugins;
 
 /**
  * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
  * effect, instead simply create/register plugins via plain JavaScript objects.
  * @interface Chart.PluginBase
  * @deprecated since version 2.5.0
  * @todo remove at version 3
  * @private
  */
 Chart.PluginBase = Chart.Element.extend({});
 
 /**
  * Provided for backward compatibility, use Chart.helpers.canvas instead.
  * @namespace Chart.canvasHelpers
  * @deprecated since version 2.6.0
  * @todo remove at version 3
  * @private
  */
 Chart.canvasHelpers = Chart.helpers.canvas;
 
 /**
  * Provided for backward compatibility, use Chart.layouts instead.
  * @namespace Chart.layoutService
  * @deprecated since version 2.8.0
  * @todo remove at version 3
  * @private
  */
 Chart.layoutService = Chart.layouts;
 
 },{"10":10,"11":11,"12":12,"13":13,"14":14,"15":15,"16":16,"17":17,"18":18,"19":19,"20":20,"21":21,"22":22,"23":23,"24":24,"25":25,"26":26,"27":27,"28":28,"29":29,"30":30,"31":31,"32":32,"33":33,"34":34,"35":35,"40":40,"45":45,"48":48,"49":49,"53":53,"54":54,"55":55,"56":56,"57":57,"58":58,"8":8,"9":9}],8:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 
 	Chart.Bar = function(context, config) {
 		config.type = 'bar';
 
 		return new Chart(context, config);
 	};
 
 };
 
 },{}],9:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 
 	Chart.Bubble = function(context, config) {
 		config.type = 'bubble';
 		return new Chart(context, config);
 	};
 
 };
 
 },{}],10:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 
 	Chart.Doughnut = function(context, config) {
 		config.type = 'doughnut';
 
 		return new Chart(context, config);
 	};
 
 };
 
 },{}],11:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 
 	Chart.Line = function(context, config) {
 		config.type = 'line';
 
 		return new Chart(context, config);
 	};
 
 };
 
 },{}],12:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 
 	Chart.PolarArea = function(context, config) {
 		config.type = 'polarArea';
 
 		return new Chart(context, config);
 	};
 
 };
 
 },{}],13:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 
 	Chart.Radar = function(context, config) {
 		config.type = 'radar';
 
 		return new Chart(context, config);
 	};
 
 };
 
 },{}],14:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 	Chart.Scatter = function(context, config) {
 		config.type = 'scatter';
 		return new Chart(context, config);
 	};
 };
 
 },{}],15:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var elements = require(40);
 var helpers = require(45);
 
 defaults._set('bar', {
 	hover: {
 		mode: 'label'
 	},
 
 	scales: {
 		xAxes: [{
 			type: 'category',
 
 			// Specific to Bar Controller
 			categoryPercentage: 0.8,
 			barPercentage: 0.9,
 
 			// offset settings
 			offset: true,
 
 			// grid line settings
 			gridLines: {
 				offsetGridLines: true
 			}
 		}],
 
 		yAxes: [{
 			type: 'linear'
 		}]
 	}
 });
 
 defaults._set('horizontalBar', {
 	hover: {
 		mode: 'index',
 		axis: 'y'
 	},
 
 	scales: {
 		xAxes: [{
 			type: 'linear',
 			position: 'bottom'
 		}],
 
 		yAxes: [{
 			position: 'left',
 			type: 'category',
 
 			// Specific to Horizontal Bar Controller
 			categoryPercentage: 0.8,
 			barPercentage: 0.9,
 
 			// offset settings
 			offset: true,
 
 			// grid line settings
 			gridLines: {
 				offsetGridLines: true
 			}
 		}]
 	},
 
 	elements: {
 		rectangle: {
 			borderSkipped: 'left'
 		}
 	},
 
 	tooltips: {
 		callbacks: {
 			title: function(item, data) {
 				// Pick first xLabel for now
 				var title = '';
 
 				if (item.length > 0) {
 					if (item[0].yLabel) {
 						title = item[0].yLabel;
 					} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
 						title = data.labels[item[0].index];
 					}
 				}
 
 				return title;
 			},
 
 			label: function(item, data) {
 				var datasetLabel = data.datasets[item.datasetIndex].label || '';
 				return datasetLabel + ': ' + item.xLabel;
 			}
 		},
 		mode: 'index',
 		axis: 'y'
 	}
 });
 
 /**
  * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
  * @private
  */
 function computeMinSampleSize(scale, pixels) {
 	var min = scale.isHorizontal() ? scale.width : scale.height;
 	var ticks = scale.getTicks();
 	var prev, curr, i, ilen;
 
 	for (i = 1, ilen = pixels.length; i < ilen; ++i) {
 		min = Math.min(min, pixels[i] - pixels[i - 1]);
 	}
 
 	for (i = 0, ilen = ticks.length; i < ilen; ++i) {
 		curr = scale.getPixelForTick(i);
 		min = i > 0 ? Math.min(min, curr - prev) : min;
 		prev = curr;
 	}
 
 	return min;
 }
 
 /**
  * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
  * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
  * mode currently always generates bars equally sized (until we introduce scriptable options?).
  * @private
  */
 function computeFitCategoryTraits(index, ruler, options) {
 	var thickness = options.barThickness;
 	var count = ruler.stackCount;
 	var curr = ruler.pixels[index];
 	var size, ratio;
 
 	if (helpers.isNullOrUndef(thickness)) {
 		size = ruler.min * options.categoryPercentage;
 		ratio = options.barPercentage;
 	} else {
 		// When bar thickness is enforced, category and bar percentages are ignored.
 		// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
 		// and deprecate barPercentage since this value is ignored when thickness is absolute.
 		size = thickness * count;
 		ratio = 1;
 	}
 
 	return {
 		chunk: size / count,
 		ratio: ratio,
 		start: curr - (size / 2)
 	};
 }
 
 /**
  * Computes an "optimal" category that globally arranges bars side by side (no gap when
  * percentage options are 1), based on the previous and following categories. This mode
  * generates bars with different widths when data are not evenly spaced.
  * @private
  */
 function computeFlexCategoryTraits(index, ruler, options) {
 	var pixels = ruler.pixels;
 	var curr = pixels[index];
 	var prev = index > 0 ? pixels[index - 1] : null;
 	var next = index < pixels.length - 1 ? pixels[index + 1] : null;
 	var percent = options.categoryPercentage;
 	var start, size;
 
 	if (prev === null) {
 		// first data: its size is double based on the next point or,
 		// if it's also the last data, we use the scale end extremity.
 		prev = curr - (next === null ? ruler.end - curr : next - curr);
 	}
 
 	if (next === null) {
 		// last data: its size is also double based on the previous point.
 		next = curr + curr - prev;
 	}
 
 	start = curr - ((curr - prev) / 2) * percent;
 	size = ((next - prev) / 2) * percent;
 
 	return {
 		chunk: size / ruler.stackCount,
 		ratio: options.barPercentage,
 		start: start
 	};
 }
 
 module.exports = function(Chart) {
 
 	Chart.controllers.bar = Chart.DatasetController.extend({
 
 		dataElementType: elements.Rectangle,
 
 		initialize: function() {
 			var me = this;
 			var meta;
 
 			Chart.DatasetController.prototype.initialize.apply(me, arguments);
 
 			meta = me.getMeta();
 			meta.stack = me.getDataset().stack;
 			meta.bar = true;
 		},
 
 		update: function(reset) {
 			var me = this;
 			var rects = me.getMeta().data;
 			var i, ilen;
 
 			me._ruler = me.getRuler();
 
 			for (i = 0, ilen = rects.length; i < ilen; ++i) {
 				me.updateElement(rects[i], i, reset);
 			}
 		},
 
 		updateElement: function(rectangle, index, reset) {
 			var me = this;
 			var chart = me.chart;
 			var meta = me.getMeta();
 			var dataset = me.getDataset();
 			var custom = rectangle.custom || {};
 			var rectangleOptions = chart.options.elements.rectangle;
 
 			rectangle._xScale = me.getScaleForId(meta.xAxisID);
 			rectangle._yScale = me.getScaleForId(meta.yAxisID);
 			rectangle._datasetIndex = me.index;
 			rectangle._index = index;
 
 			rectangle._model = {
 				datasetLabel: dataset.label,
 				label: chart.data.labels[index],
 				borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
 				backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
 				borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
 				borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
 			};
 
 			me.updateElementGeometry(rectangle, index, reset);
 
 			rectangle.pivot();
 		},
 
 		/**
 		 * @private
 		 */
 		updateElementGeometry: function(rectangle, index, reset) {
 			var me = this;
 			var model = rectangle._model;
 			var vscale = me.getValueScale();
 			var base = vscale.getBasePixel();
 			var horizontal = vscale.isHorizontal();
 			var ruler = me._ruler || me.getRuler();
 			var vpixels = me.calculateBarValuePixels(me.index, index);
 			var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
 
 			model.horizontal = horizontal;
 			model.base = reset ? base : vpixels.base;
 			model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
 			model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
 			model.height = horizontal ? ipixels.size : undefined;
 			model.width = horizontal ? undefined : ipixels.size;
 		},
 
 		/**
 		 * @private
 		 */
 		getValueScaleId: function() {
 			return this.getMeta().yAxisID;
 		},
 
 		/**
 		 * @private
 		 */
 		getIndexScaleId: function() {
 			return this.getMeta().xAxisID;
 		},
 
 		/**
 		 * @private
 		 */
 		getValueScale: function() {
 			return this.getScaleForId(this.getValueScaleId());
 		},
 
 		/**
 		 * @private
 		 */
 		getIndexScale: function() {
 			return this.getScaleForId(this.getIndexScaleId());
 		},
 
 		/**
 		 * Returns the stacks based on groups and bar visibility.
 		 * @param {Number} [last] - The dataset index
 		 * @returns {Array} The stack list
 		 * @private
 		 */
 		_getStacks: function(last) {
 			var me = this;
 			var chart = me.chart;
 			var scale = me.getIndexScale();
 			var stacked = scale.options.stacked;
 			var ilen = last === undefined ? chart.data.datasets.length : last + 1;
 			var stacks = [];
 			var i, meta;
 
 			for (i = 0; i < ilen; ++i) {
 				meta = chart.getDatasetMeta(i);
 				if (meta.bar && chart.isDatasetVisible(i) &&
 					(stacked === false ||
 					(stacked === true && stacks.indexOf(meta.stack) === -1) ||
 					(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
 					stacks.push(meta.stack);
 				}
 			}
 
 			return stacks;
 		},
 
 		/**
 		 * Returns the effective number of stacks based on groups and bar visibility.
 		 * @private
 		 */
 		getStackCount: function() {
 			return this._getStacks().length;
 		},
 
 		/**
 		 * Returns the stack index for the given dataset based on groups and bar visibility.
 		 * @param {Number} [datasetIndex] - The dataset index
 		 * @param {String} [name] - The stack name to find
 		 * @returns {Number} The stack index
 		 * @private
 		 */
 		getStackIndex: function(datasetIndex, name) {
 			var stacks = this._getStacks(datasetIndex);
 			var index = (name !== undefined)
 				? stacks.indexOf(name)
 				: -1; // indexOf returns -1 if element is not present
 
 			return (index === -1)
 				? stacks.length - 1
 				: index;
 		},
 
 		/**
 		 * @private
 		 */
 		getRuler: function() {
 			var me = this;
 			var scale = me.getIndexScale();
 			var stackCount = me.getStackCount();
 			var datasetIndex = me.index;
 			var isHorizontal = scale.isHorizontal();
 			var start = isHorizontal ? scale.left : scale.top;
 			var end = start + (isHorizontal ? scale.width : scale.height);
 			var pixels = [];
 			var i, ilen, min;
 
 			for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
 				pixels.push(scale.getPixelForValue(null, i, datasetIndex));
 			}
 
 			min = helpers.isNullOrUndef(scale.options.barThickness)
 				? computeMinSampleSize(scale, pixels)
 				: -1;
 
 			return {
 				min: min,
 				pixels: pixels,
 				start: start,
 				end: end,
 				stackCount: stackCount,
 				scale: scale
 			};
 		},
 
 		/**
 		 * Note: pixel values are not clamped to the scale area.
 		 * @private
 		 */
 		calculateBarValuePixels: function(datasetIndex, index) {
 			var me = this;
 			var chart = me.chart;
 			var meta = me.getMeta();
 			var scale = me.getValueScale();
 			var datasets = chart.data.datasets;
 			var value = scale.getRightValue(datasets[datasetIndex].data[index]);
 			var stacked = scale.options.stacked;
 			var stack = meta.stack;
 			var start = 0;
 			var i, imeta, ivalue, base, head, size;
 
 			if (stacked || (stacked === undefined && stack !== undefined)) {
 				for (i = 0; i < datasetIndex; ++i) {
 					imeta = chart.getDatasetMeta(i);
 
 					if (imeta.bar &&
 						imeta.stack === stack &&
 						imeta.controller.getValueScaleId() === scale.id &&
 						chart.isDatasetVisible(i)) {
 
 						ivalue = scale.getRightValue(datasets[i].data[index]);
 						if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
 							start += ivalue;
 						}
 					}
 				}
 			}
 
 			base = scale.getPixelForValue(start);
 			head = scale.getPixelForValue(start + value);
 			size = (head - base) / 2;
 
 			return {
 				size: size,
 				base: base,
 				head: head,
 				center: head + size / 2
 			};
 		},
 
 		/**
 		 * @private
 		 */
 		calculateBarIndexPixels: function(datasetIndex, index, ruler) {
 			var me = this;
 			var options = ruler.scale.options;
 			var range = options.barThickness === 'flex'
 				? computeFlexCategoryTraits(index, ruler, options)
 				: computeFitCategoryTraits(index, ruler, options);
 
 			var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
 			var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
 			var size = Math.min(
 				helpers.valueOrDefault(options.maxBarThickness, Infinity),
 				range.chunk * range.ratio);
 
 			return {
 				base: center - size / 2,
 				head: center + size / 2,
 				center: center,
 				size: size
 			};
 		},
 
 		draw: function() {
 			var me = this;
 			var chart = me.chart;
 			var scale = me.getValueScale();
 			var rects = me.getMeta().data;
 			var dataset = me.getDataset();
 			var ilen = rects.length;
 			var i = 0;
 
 			helpers.canvas.clipArea(chart.ctx, chart.chartArea);
 
 			for (; i < ilen; ++i) {
 				if (!isNaN(scale.getRightValue(dataset.data[i]))) {
 					rects[i].draw();
 				}
 			}
 
 			helpers.canvas.unclipArea(chart.ctx);
 		},
 
 		setHoverStyle: function(rectangle) {
 			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
 			var index = rectangle._index;
 			var custom = rectangle.custom || {};
 			var model = rectangle._model;
 
 			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
 			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
 			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
 		},
 
 		removeHoverStyle: function(rectangle) {
 			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
 			var index = rectangle._index;
 			var custom = rectangle.custom || {};
 			var model = rectangle._model;
 			var rectangleElementOptions = this.chart.options.elements.rectangle;
 
 			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
 			model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
 			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
 		}
 	});
 
 	Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
 		/**
 		 * @private
 		 */
 		getValueScaleId: function() {
 			return this.getMeta().xAxisID;
 		},
 
 		/**
 		 * @private
 		 */
 		getIndexScaleId: function() {
 			return this.getMeta().yAxisID;
 		}
 	});
 };
 
 },{"25":25,"40":40,"45":45}],16:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var elements = require(40);
 var helpers = require(45);
 
 defaults._set('bubble', {
 	hover: {
 		mode: 'single'
 	},
 
 	scales: {
 		xAxes: [{
 			type: 'linear', // bubble should probably use a linear scale by default
 			position: 'bottom',
 			id: 'x-axis-0' // need an ID so datasets can reference the scale
 		}],
 		yAxes: [{
 			type: 'linear',
 			position: 'left',
 			id: 'y-axis-0'
 		}]
 	},
 
 	tooltips: {
 		callbacks: {
 			title: function() {
 				// Title doesn't make sense for scatter since we format the data as a point
 				return '';
 			},
 			label: function(item, data) {
 				var datasetLabel = data.datasets[item.datasetIndex].label || '';
 				var dataPoint = data.datasets[item.datasetIndex].data[item.index];
 				return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
 			}
 		}
 	}
 });
 
 
 module.exports = function(Chart) {
 
 	Chart.controllers.bubble = Chart.DatasetController.extend({
 		/**
 		 * @protected
 		 */
 		dataElementType: elements.Point,
 
 		/**
 		 * @protected
 		 */
 		update: function(reset) {
 			var me = this;
 			var meta = me.getMeta();
 			var points = meta.data;
 
 			// Update Points
 			helpers.each(points, function(point, index) {
 				me.updateElement(point, index, reset);
 			});
 		},
 
 		/**
 		 * @protected
 		 */
 		updateElement: function(point, index, reset) {
 			var me = this;
 			var meta = me.getMeta();
 			var custom = point.custom || {};
 			var xScale = me.getScaleForId(meta.xAxisID);
 			var yScale = me.getScaleForId(meta.yAxisID);
 			var options = me._resolveElementOptions(point, index);
 			var data = me.getDataset().data[index];
 			var dsIndex = me.index;
 
 			var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
 			var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
 
 			point._xScale = xScale;
 			point._yScale = yScale;
 			point._options = options;
 			point._datasetIndex = dsIndex;
 			point._index = index;
 			point._model = {
 				backgroundColor: options.backgroundColor,
 				borderColor: options.borderColor,
 				borderWidth: options.borderWidth,
 				hitRadius: options.hitRadius,
 				pointStyle: options.pointStyle,
 				radius: reset ? 0 : options.radius,
 				skip: custom.skip || isNaN(x) || isNaN(y),
 				x: x,
 				y: y,
 			};
 
 			point.pivot();
 		},
 
 		/**
 		 * @protected
 		 */
 		setHoverStyle: function(point) {
 			var model = point._model;
 			var options = point._options;
 
 			model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
 			model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
 			model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
 			model.radius = options.radius + options.hoverRadius;
 		},
 
 		/**
 		 * @protected
 		 */
 		removeHoverStyle: function(point) {
 			var model = point._model;
 			var options = point._options;
 
 			model.backgroundColor = options.backgroundColor;
 			model.borderColor = options.borderColor;
 			model.borderWidth = options.borderWidth;
 			model.radius = options.radius;
 		},
 
 		/**
 		 * @private
 		 */
 		_resolveElementOptions: function(point, index) {
 			var me = this;
 			var chart = me.chart;
 			var datasets = chart.data.datasets;
 			var dataset = datasets[me.index];
 			var custom = point.custom || {};
 			var options = chart.options.elements.point;
 			var resolve = helpers.options.resolve;
 			var data = dataset.data[index];
 			var values = {};
 			var i, ilen, key;
 
 			// Scriptable options
 			var context = {
 				chart: chart,
 				dataIndex: index,
 				dataset: dataset,
 				datasetIndex: me.index
 			};
 
 			var keys = [
 				'backgroundColor',
 				'borderColor',
 				'borderWidth',
 				'hoverBackgroundColor',
 				'hoverBorderColor',
 				'hoverBorderWidth',
 				'hoverRadius',
 				'hitRadius',
 				'pointStyle'
 			];
 
 			for (i = 0, ilen = keys.length; i < ilen; ++i) {
 				key = keys[i];
 				values[key] = resolve([
 					custom[key],
 					dataset[key],
 					options[key]
 				], context, index);
 			}
 
 			// Custom radius resolution
 			values.radius = resolve([
 				custom.radius,
 				data ? data.r : undefined,
 				dataset.radius,
 				options.radius
 			], context, index);
 
 			return values;
 		}
 	});
 };
 
 },{"25":25,"40":40,"45":45}],17:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var elements = require(40);
 var helpers = require(45);
 
 defaults._set('doughnut', {
 	animation: {
 		// Boolean - Whether we animate the rotation of the Doughnut
 		animateRotate: true,
 		// Boolean - Whether we animate scaling the Doughnut from the centre
 		animateScale: false
 	},
 	hover: {
 		mode: 'single'
 	},
 	legendCallback: function(chart) {
 		var text = [];
 		text.push('<ul class="' + chart.id + '-legend">');
 
 		var data = chart.data;
 		var datasets = data.datasets;
 		var labels = data.labels;
 
 		if (datasets.length) {
 			for (var i = 0; i < datasets[0].data.length; ++i) {
 				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
 				if (labels[i]) {
 					text.push(labels[i]);
 				}
 				text.push('</li>');
 			}
 		}
 
 		text.push('</ul>');
 		return text.join('');
 	},
 	legend: {
 		labels: {
 			generateLabels: function(chart) {
 				var data = chart.data;
 				if (data.labels.length && data.datasets.length) {
 					return data.labels.map(function(label, i) {
 						var meta = chart.getDatasetMeta(0);
 						var ds = data.datasets[0];
 						var arc = meta.data[i];
 						var custom = arc && arc.custom || {};
 						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
 						var arcOpts = chart.options.elements.arc;
 						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
 						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
 						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
 
 						return {
 							text: label,
 							fillStyle: fill,
 							strokeStyle: stroke,
 							lineWidth: bw,
 							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
 
 							// Extra data used for toggling the correct item
 							index: i
 						};
 					});
 				}
 				return [];
 			}
 		},
 
 		onClick: function(e, legendItem) {
 			var index = legendItem.index;
 			var chart = this.chart;
 			var i, ilen, meta;
 
 			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
 				meta = chart.getDatasetMeta(i);
 				// toggle visibility of index if exists
 				if (meta.data[index]) {
 					meta.data[index].hidden = !meta.data[index].hidden;
 				}
 			}
 
 			chart.update();
 		}
 	},
 
 	// The percentage of the chart that we cut out of the middle.
 	cutoutPercentage: 50,
 
 	// The rotation of the chart, where the first data arc begins.
 	rotation: Math.PI * -0.5,
 
 	// The total circumference of the chart.
 	circumference: Math.PI * 2.0,
 
 	// Need to override these to give a nice default
 	tooltips: {
 		callbacks: {
 			title: function() {
 				return '';
 			},
 			label: function(tooltipItem, data) {
 				var dataLabel = data.labels[tooltipItem.index];
 				var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
 
 				if (helpers.isArray(dataLabel)) {
 					// show value on first line of multiline label
 					// need to clone because we are changing the value
 					dataLabel = dataLabel.slice();
 					dataLabel[0] += value;
 				} else {
 					dataLabel += value;
 				}
 
 				return dataLabel;
 			}
 		}
 	}
 });
 
 defaults._set('pie', helpers.clone(defaults.doughnut));
 defaults._set('pie', {
 	cutoutPercentage: 0
 });
 
 module.exports = function(Chart) {
 
 	Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
 
 		dataElementType: elements.Arc,
 
 		linkScales: helpers.noop,
 
 		// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
 		getRingIndex: function(datasetIndex) {
 			var ringIndex = 0;
 
 			for (var j = 0; j < datasetIndex; ++j) {
 				if (this.chart.isDatasetVisible(j)) {
 					++ringIndex;
 				}
 			}
 
 			return ringIndex;
 		},
 
 		update: function(reset) {
 			var me = this;
 			var chart = me.chart;
 			var chartArea = chart.chartArea;
 			var opts = chart.options;
 			var arcOpts = opts.elements.arc;
 			var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
 			var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
 			var minSize = Math.min(availableWidth, availableHeight);
 			var offset = {x: 0, y: 0};
 			var meta = me.getMeta();
 			var cutoutPercentage = opts.cutoutPercentage;
 			var circumference = opts.circumference;
 
 			// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
 			if (circumference < Math.PI * 2.0) {
 				var startAngle = opts.rotation % (Math.PI * 2.0);
 				startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
 				var endAngle = startAngle + circumference;
 				var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
 				var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
 				var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
 				var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
 				var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
 				var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
 				var cutout = cutoutPercentage / 100.0;
 				var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};
 				var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};
 				var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
 				minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
 				offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
 			}
 
 			chart.borderWidth = me.getMaxBorderWidth(meta.data);
 			chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
 			chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
 			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
 			chart.offsetX = offset.x * chart.outerRadius;
 			chart.offsetY = offset.y * chart.outerRadius;
 
 			meta.total = me.calculateTotal();
 
 			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
 			me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
 
 			helpers.each(meta.data, function(arc, index) {
 				me.updateElement(arc, index, reset);
 			});
 		},
 
 		updateElement: function(arc, index, reset) {
 			var me = this;
 			var chart = me.chart;
 			var chartArea = chart.chartArea;
 			var opts = chart.options;
 			var animationOpts = opts.animation;
 			var centerX = (chartArea.left + chartArea.right) / 2;
 			var centerY = (chartArea.top + chartArea.bottom) / 2;
 			var startAngle = opts.rotation; // non reset case handled later
 			var endAngle = opts.rotation; // non reset case handled later
 			var dataset = me.getDataset();
 			var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
 			var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
 			var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
 			var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
 
 			helpers.extend(arc, {
 				// Utility
 				_datasetIndex: me.index,
 				_index: index,
 
 				// Desired view properties
 				_model: {
 					x: centerX + chart.offsetX,
 					y: centerY + chart.offsetY,
 					startAngle: startAngle,
 					endAngle: endAngle,
 					circumference: circumference,
 					outerRadius: outerRadius,
 					innerRadius: innerRadius,
 					label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
 				}
 			});
 
 			var model = arc._model;
 			// Resets the visual styles
 			this.removeHoverStyle(arc);
 
 			// Set correct angles if not resetting
 			if (!reset || !animationOpts.animateRotate) {
 				if (index === 0) {
 					model.startAngle = opts.rotation;
 				} else {
 					model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
 				}
 
 				model.endAngle = model.startAngle + model.circumference;
 			}
 
 			arc.pivot();
 		},
 
 		removeHoverStyle: function(arc) {
 			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
 		},
 
 		calculateTotal: function() {
 			var dataset = this.getDataset();
 			var meta = this.getMeta();
 			var total = 0;
 			var value;
 
 			helpers.each(meta.data, function(element, index) {
 				value = dataset.data[index];
 				if (!isNaN(value) && !element.hidden) {
 					total += Math.abs(value);
 				}
 			});
 
 			/* if (total === 0) {
 				total = NaN;
 			}*/
 
 			return total;
 		},
 
 		calculateCircumference: function(value) {
 			var total = this.getMeta().total;
 			if (total > 0 && !isNaN(value)) {
 				return (Math.PI * 2.0) * (Math.abs(value) / total);
 			}
 			return 0;
 		},
 
 		// gets the max border or hover width to properly scale pie charts
 		getMaxBorderWidth: function(arcs) {
 			var max = 0;
 			var index = this.index;
 			var length = arcs.length;
 			var borderWidth;
 			var hoverWidth;
 
 			for (var i = 0; i < length; i++) {
 				borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
 				hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
 
 				max = borderWidth > max ? borderWidth : max;
 				max = hoverWidth > max ? hoverWidth : max;
 			}
 			return max;
 		}
 	});
 };
 
 },{"25":25,"40":40,"45":45}],18:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var elements = require(40);
 var helpers = require(45);
 
 defaults._set('line', {
 	showLines: true,
 	spanGaps: false,
 
 	hover: {
 		mode: 'label'
 	},
 
 	scales: {
 		xAxes: [{
 			type: 'category',
 			id: 'x-axis-0'
 		}],
 		yAxes: [{
 			type: 'linear',
 			id: 'y-axis-0'
 		}]
 	}
 });
 
 module.exports = function(Chart) {
 
 	function lineEnabled(dataset, options) {
 		return helpers.valueOrDefault(dataset.showLine, options.showLines);
 	}
 
 	Chart.controllers.line = Chart.DatasetController.extend({
 
 		datasetElementType: elements.Line,
 
 		dataElementType: elements.Point,
 
 		update: function(reset) {
 			var me = this;
 			var meta = me.getMeta();
 			var line = meta.dataset;
 			var points = meta.data || [];
 			var options = me.chart.options;
 			var lineElementOptions = options.elements.line;
 			var scale = me.getScaleForId(meta.yAxisID);
 			var i, ilen, custom;
 			var dataset = me.getDataset();
 			var showLine = lineEnabled(dataset, options);
 
 			// Update Line
 			if (showLine) {
 				custom = line.custom || {};
 
 				// Compatibility: If the properties are defined with only the old name, use those values
 				if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
 					dataset.lineTension = dataset.tension;
 				}
 
 				// Utility
 				line._scale = scale;
 				line._datasetIndex = me.index;
 				// Data
 				line._children = points;
 				// Model
 				line._model = {
 					// Appearance
 					// The default behavior of lines is to break at null values, according
 					// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
 					// This option gives lines the ability to span gaps
 					spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
 					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
 					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
 					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
 					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
 					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
 					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
 					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
 					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
 					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
 					steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
 					cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
 				};
 
 				line.pivot();
 			}
 
 			// Update Points
 			for (i = 0, ilen = points.length; i < ilen; ++i) {
 				me.updateElement(points[i], i, reset);
 			}
 
 			if (showLine && line._model.tension !== 0) {
 				me.updateBezierControlPoints();
 			}
 
 			// Now pivot the point for animation
 			for (i = 0, ilen = points.length; i < ilen; ++i) {
 				points[i].pivot();
 			}
 		},
 
 		getPointBackgroundColor: function(point, index) {
 			var backgroundColor = this.chart.options.elements.point.backgroundColor;
 			var dataset = this.getDataset();
 			var custom = point.custom || {};
 
 			if (custom.backgroundColor) {
 				backgroundColor = custom.backgroundColor;
 			} else if (dataset.pointBackgroundColor) {
 				backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
 			} else if (dataset.backgroundColor) {
 				backgroundColor = dataset.backgroundColor;
 			}
 
 			return backgroundColor;
 		},
 
 		getPointBorderColor: function(point, index) {
 			var borderColor = this.chart.options.elements.point.borderColor;
 			var dataset = this.getDataset();
 			var custom = point.custom || {};
 
 			if (custom.borderColor) {
 				borderColor = custom.borderColor;
 			} else if (dataset.pointBorderColor) {
 				borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
 			} else if (dataset.borderColor) {
 				borderColor = dataset.borderColor;
 			}
 
 			return borderColor;
 		},
 
 		getPointBorderWidth: function(point, index) {
 			var borderWidth = this.chart.options.elements.point.borderWidth;
 			var dataset = this.getDataset();
 			var custom = point.custom || {};
 
 			if (!isNaN(custom.borderWidth)) {
 				borderWidth = custom.borderWidth;
 			} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
 				borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
 			} else if (!isNaN(dataset.borderWidth)) {
 				borderWidth = dataset.borderWidth;
 			}
 
 			return borderWidth;
 		},
 
 		updateElement: function(point, index, reset) {
 			var me = this;
 			var meta = me.getMeta();
 			var custom = point.custom || {};
 			var dataset = me.getDataset();
 			var datasetIndex = me.index;
 			var value = dataset.data[index];
 			var yScale = me.getScaleForId(meta.yAxisID);
 			var xScale = me.getScaleForId(meta.xAxisID);
 			var pointOptions = me.chart.options.elements.point;
 			var x, y;
 
 			// Compatibility: If the properties are defined with only the old name, use those values
 			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
 				dataset.pointRadius = dataset.radius;
 			}
 			if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
 				dataset.pointHitRadius = dataset.hitRadius;
 			}
 
 			x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
 			y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
 
 			// Utility
 			point._xScale = xScale;
 			point._yScale = yScale;
 			point._datasetIndex = datasetIndex;
 			point._index = index;
 
 			// Desired view properties
 			point._model = {
 				x: x,
 				y: y,
 				skip: custom.skip || isNaN(x) || isNaN(y),
 				// Appearance
 				radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
 				pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
 				backgroundColor: me.getPointBackgroundColor(point, index),
 				borderColor: me.getPointBorderColor(point, index),
 				borderWidth: me.getPointBorderWidth(point, index),
 				tension: meta.dataset._model ? meta.dataset._model.tension : 0,
 				steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
 				// Tooltip
 				hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
 			};
 		},
 
 		calculatePointY: function(value, index, datasetIndex) {
 			var me = this;
 			var chart = me.chart;
 			var meta = me.getMeta();
 			var yScale = me.getScaleForId(meta.yAxisID);
 			var sumPos = 0;
 			var sumNeg = 0;
 			var i, ds, dsMeta;
 
 			if (yScale.options.stacked) {
 				for (i = 0; i < datasetIndex; i++) {
 					ds = chart.data.datasets[i];
 					dsMeta = chart.getDatasetMeta(i);
 					if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
 						var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
 						if (stackedRightValue < 0) {
 							sumNeg += stackedRightValue || 0;
 						} else {
 							sumPos += stackedRightValue || 0;
 						}
 					}
 				}
 
 				var rightValue = Number(yScale.getRightValue(value));
 				if (rightValue < 0) {
 					return yScale.getPixelForValue(sumNeg + rightValue);
 				}
 				return yScale.getPixelForValue(sumPos + rightValue);
 			}
 
 			return yScale.getPixelForValue(value);
 		},
 
 		updateBezierControlPoints: function() {
 			var me = this;
 			var meta = me.getMeta();
 			var area = me.chart.chartArea;
 			var points = (meta.data || []);
 			var i, ilen, point, model, controlPoints;
 
 			// Only consider points that are drawn in case the spanGaps option is used
 			if (meta.dataset._model.spanGaps) {
 				points = points.filter(function(pt) {
 					return !pt._model.skip;
 				});
 			}
 
 			function capControlPoint(pt, min, max) {
 				return Math.max(Math.min(pt, max), min);
 			}
 
 			if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
 				helpers.splineCurveMonotone(points);
 			} else {
 				for (i = 0, ilen = points.length; i < ilen; ++i) {
 					point = points[i];
 					model = point._model;
 					controlPoints = helpers.splineCurve(
 						helpers.previousItem(points, i)._model,
 						model,
 						helpers.nextItem(points, i)._model,
 						meta.dataset._model.tension
 					);
 					model.controlPointPreviousX = controlPoints.previous.x;
 					model.controlPointPreviousY = controlPoints.previous.y;
 					model.controlPointNextX = controlPoints.next.x;
 					model.controlPointNextY = controlPoints.next.y;
 				}
 			}
 
 			if (me.chart.options.elements.line.capBezierPoints) {
 				for (i = 0, ilen = points.length; i < ilen; ++i) {
 					model = points[i]._model;
 					model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
 					model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
 					model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
 					model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
 				}
 			}
 		},
 
 		draw: function() {
 			var me = this;
 			var chart = me.chart;
 			var meta = me.getMeta();
 			var points = meta.data || [];
 			var area = chart.chartArea;
 			var ilen = points.length;
 			var i = 0;
 
 			helpers.canvas.clipArea(chart.ctx, area);
 
 			if (lineEnabled(me.getDataset(), chart.options)) {
 				meta.dataset.draw();
 			}
 
 			helpers.canvas.unclipArea(chart.ctx);
 
 			// Draw the points
 			for (; i < ilen; ++i) {
 				points[i].draw(area);
 			}
 		},
 
 		setHoverStyle: function(point) {
 			// Point
 			var dataset = this.chart.data.datasets[point._datasetIndex];
 			var index = point._index;
 			var custom = point.custom || {};
 			var model = point._model;
 
 			model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
 			model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
 			model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
 			model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
 		},
 
 		removeHoverStyle: function(point) {
 			var me = this;
 			var dataset = me.chart.data.datasets[point._datasetIndex];
 			var index = point._index;
 			var custom = point.custom || {};
 			var model = point._model;
 
 			// Compatibility: If the properties are defined with only the old name, use those values
 			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
 				dataset.pointRadius = dataset.radius;
 			}
 
 			model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
 			model.backgroundColor = me.getPointBackgroundColor(point, index);
 			model.borderColor = me.getPointBorderColor(point, index);
 			model.borderWidth = me.getPointBorderWidth(point, index);
 		}
 	});
 };
 
 },{"25":25,"40":40,"45":45}],19:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var elements = require(40);
 var helpers = require(45);
 
 defaults._set('polarArea', {
 	scale: {
 		type: 'radialLinear',
 		angleLines: {
 			display: false
 		},
 		gridLines: {
 			circular: true
 		},
 		pointLabels: {
 			display: false
 		},
 		ticks: {
 			beginAtZero: true
 		}
 	},
 
 	// Boolean - Whether to animate the rotation of the chart
 	animation: {
 		animateRotate: true,
 		animateScale: true
 	},
 
 	startAngle: -0.5 * Math.PI,
 	legendCallback: function(chart) {
 		var text = [];
 		text.push('<ul class="' + chart.id + '-legend">');
 
 		var data = chart.data;
 		var datasets = data.datasets;
 		var labels = data.labels;
 
 		if (datasets.length) {
 			for (var i = 0; i < datasets[0].data.length; ++i) {
 				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
 				if (labels[i]) {
 					text.push(labels[i]);
 				}
 				text.push('</li>');
 			}
 		}
 
 		text.push('</ul>');
 		return text.join('');
 	},
 	legend: {
 		labels: {
 			generateLabels: function(chart) {
 				var data = chart.data;
 				if (data.labels.length && data.datasets.length) {
 					return data.labels.map(function(label, i) {
 						var meta = chart.getDatasetMeta(0);
 						var ds = data.datasets[0];
 						var arc = meta.data[i];
 						var custom = arc.custom || {};
 						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
 						var arcOpts = chart.options.elements.arc;
 						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
 						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
 						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
 
 						return {
 							text: label,
 							fillStyle: fill,
 							strokeStyle: stroke,
 							lineWidth: bw,
 							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
 
 							// Extra data used for toggling the correct item
 							index: i
 						};
 					});
 				}
 				return [];
 			}
 		},
 
 		onClick: function(e, legendItem) {
 			var index = legendItem.index;
 			var chart = this.chart;
 			var i, ilen, meta;
 
 			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
 				meta = chart.getDatasetMeta(i);
 				meta.data[index].hidden = !meta.data[index].hidden;
 			}
 
 			chart.update();
 		}
 	},
 
 	// Need to override these to give a nice default
 	tooltips: {
 		callbacks: {
 			title: function() {
 				return '';
 			},
 			label: function(item, data) {
 				return data.labels[item.index] + ': ' + item.yLabel;
 			}
 		}
 	}
 });
 
 module.exports = function(Chart) {
 
 	Chart.controllers.polarArea = Chart.DatasetController.extend({
 
 		dataElementType: elements.Arc,
 
 		linkScales: helpers.noop,
 
 		update: function(reset) {
 			var me = this;
 			var chart = me.chart;
 			var chartArea = chart.chartArea;
 			var meta = me.getMeta();
 			var opts = chart.options;
 			var arcOpts = opts.elements.arc;
 			var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
 			chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
 			chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
 			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
 
 			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
 			me.innerRadius = me.outerRadius - chart.radiusLength;
 
 			meta.count = me.countVisibleElements();
 
 			helpers.each(meta.data, function(arc, index) {
 				me.updateElement(arc, index, reset);
 			});
 		},
 
 		updateElement: function(arc, index, reset) {
 			var me = this;
 			var chart = me.chart;
 			var dataset = me.getDataset();
 			var opts = chart.options;
 			var animationOpts = opts.animation;
 			var scale = chart.scale;
 			var labels = chart.data.labels;
 
 			var circumference = me.calculateCircumference(dataset.data[index]);
 			var centerX = scale.xCenter;
 			var centerY = scale.yCenter;
 
 			// If there is NaN data before us, we need to calculate the starting angle correctly.
 			// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
 			var visibleCount = 0;
 			var meta = me.getMeta();
 			for (var i = 0; i < index; ++i) {
 				if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
 					++visibleCount;
 				}
 			}
 
 			// var negHalfPI = -0.5 * Math.PI;
 			var datasetStartAngle = opts.startAngle;
 			var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
 			var startAngle = datasetStartAngle + (circumference * visibleCount);
 			var endAngle = startAngle + (arc.hidden ? 0 : circumference);
 
 			var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
 
 			helpers.extend(arc, {
 				// Utility
 				_datasetIndex: me.index,
 				_index: index,
 				_scale: scale,
 
 				// Desired view properties
 				_model: {
 					x: centerX,
 					y: centerY,
 					innerRadius: 0,
 					outerRadius: reset ? resetRadius : distance,
 					startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
 					endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
 					label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
 				}
 			});
 
 			// Apply border and fill style
 			me.removeHoverStyle(arc);
 
 			arc.pivot();
 		},
 
 		removeHoverStyle: function(arc) {
 			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
 		},
 
 		countVisibleElements: function() {
 			var dataset = this.getDataset();
 			var meta = this.getMeta();
 			var count = 0;
 
 			helpers.each(meta.data, function(element, index) {
 				if (!isNaN(dataset.data[index]) && !element.hidden) {
 					count++;
 				}
 			});
 
 			return count;
 		},
 
 		calculateCircumference: function(value) {
 			var count = this.getMeta().count;
 			if (count > 0 && !isNaN(value)) {
 				return (2 * Math.PI) / count;
 			}
 			return 0;
 		}
 	});
 };
 
 },{"25":25,"40":40,"45":45}],20:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var elements = require(40);
 var helpers = require(45);
 
 defaults._set('radar', {
 	scale: {
 		type: 'radialLinear'
 	},
 	elements: {
 		line: {
 			tension: 0 // no bezier in radar
 		}
 	}
 });
 
 module.exports = function(Chart) {
 
 	Chart.controllers.radar = Chart.DatasetController.extend({
 
 		datasetElementType: elements.Line,
 
 		dataElementType: elements.Point,
 
 		linkScales: helpers.noop,
 
 		update: function(reset) {
 			var me = this;
 			var meta = me.getMeta();
 			var line = meta.dataset;
 			var points = meta.data;
 			var custom = line.custom || {};
 			var dataset = me.getDataset();
 			var lineElementOptions = me.chart.options.elements.line;
 			var scale = me.chart.scale;
 
 			// Compatibility: If the properties are defined with only the old name, use those values
 			if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
 				dataset.lineTension = dataset.tension;
 			}
 
 			helpers.extend(meta.dataset, {
 				// Utility
 				_datasetIndex: me.index,
 				_scale: scale,
 				// Data
 				_children: points,
 				_loop: true,
 				// Model
 				_model: {
 					// Appearance
 					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
 					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
 					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
 					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
 					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
 					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
 					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
 					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
 					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
 				}
 			});
 
 			meta.dataset.pivot();
 
 			// Update Points
 			helpers.each(points, function(point, index) {
 				me.updateElement(point, index, reset);
 			}, me);
 
 			// Update bezier control points
 			me.updateBezierControlPoints();
 		},
 		updateElement: function(point, index, reset) {
 			var me = this;
 			var custom = point.custom || {};
 			var dataset = me.getDataset();
 			var scale = me.chart.scale;
 			var pointElementOptions = me.chart.options.elements.point;
 			var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
 
 			// Compatibility: If the properties are defined with only the old name, use those values
 			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
 				dataset.pointRadius = dataset.radius;
 			}
 			if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
 				dataset.pointHitRadius = dataset.hitRadius;
 			}
 
 			helpers.extend(point, {
 				// Utility
 				_datasetIndex: me.index,
 				_index: index,
 				_scale: scale,
 
 				// Desired view properties
 				_model: {
 					x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
 					y: reset ? scale.yCenter : pointPosition.y,
 
 					// Appearance
 					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
 					radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
 					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
 					borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
 					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
 					pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
 
 					// Tooltip
 					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
 				}
 			});
 
 			point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
 		},
 		updateBezierControlPoints: function() {
 			var chartArea = this.chart.chartArea;
 			var meta = this.getMeta();
 
 			helpers.each(meta.data, function(point, index) {
 				var model = point._model;
 				var controlPoints = helpers.splineCurve(
 					helpers.previousItem(meta.data, index, true)._model,
 					model,
 					helpers.nextItem(meta.data, index, true)._model,
 					model.tension
 				);
 
 				// Prevent the bezier going outside of the bounds of the graph
 				model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
 				model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
 
 				model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
 				model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
 
 				// Now pivot the point for animation
 				point.pivot();
 			});
 		},
 
 		setHoverStyle: function(point) {
 			// Point
 			var dataset = this.chart.data.datasets[point._datasetIndex];
 			var custom = point.custom || {};
 			var index = point._index;
 			var model = point._model;
 
 			model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
 			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
 			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
 			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
 		},
 
 		removeHoverStyle: function(point) {
 			var dataset = this.chart.data.datasets[point._datasetIndex];
 			var custom = point.custom || {};
 			var index = point._index;
 			var model = point._model;
 			var pointElementOptions = this.chart.options.elements.point;
 
 			model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
 			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
 			model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
 			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
 		}
 	});
 };
 
 },{"25":25,"40":40,"45":45}],21:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 
 defaults._set('scatter', {
 	hover: {
 		mode: 'single'
 	},
 
 	scales: {
 		xAxes: [{
 			id: 'x-axis-1',    // need an ID so datasets can reference the scale
 			type: 'linear',    // scatter should not use a category axis
 			position: 'bottom'
 		}],
 		yAxes: [{
 			id: 'y-axis-1',
 			type: 'linear',
 			position: 'left'
 		}]
 	},
 
 	showLines: false,
 
 	tooltips: {
 		callbacks: {
 			title: function() {
 				return '';     // doesn't make sense for scatter since data are formatted as a point
 			},
 			label: function(item) {
 				return '(' + item.xLabel + ', ' + item.yLabel + ')';
 			}
 		}
 	}
 });
 
 module.exports = function(Chart) {
 
 	// Scatter charts use line controllers
 	Chart.controllers.scatter = Chart.controllers.line;
 
 };
 
 },{"25":25}],22:[function(require,module,exports){
 /* global window: false */
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 
 defaults._set('global', {
 	animation: {
 		duration: 1000,
 		easing: 'easeOutQuart',
 		onProgress: helpers.noop,
 		onComplete: helpers.noop
 	}
 });
 
 module.exports = function(Chart) {
 
 	Chart.Animation = Element.extend({
 		chart: null, // the animation associated chart instance
 		currentStep: 0, // the current animation step
 		numSteps: 60, // default number of steps
 		easing: '', // the easing to use for this animation
 		render: null, // render function used by the animation service
 
 		onAnimationProgress: null, // user specified callback to fire on each step of the animation
 		onAnimationComplete: null, // user specified callback to fire when the animation finishes
 	});
 
 	Chart.animationService = {
 		frameDuration: 17,
 		animations: [],
 		dropFrames: 0,
 		request: null,
 
 		/**
 		 * @param {Chart} chart - The chart to animate.
 		 * @param {Chart.Animation} animation - The animation that we will animate.
 		 * @param {Number} duration - The animation duration in ms.
 		 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
 		 */
 		addAnimation: function(chart, animation, duration, lazy) {
 			var animations = this.animations;
 			var i, ilen;
 
 			animation.chart = chart;
 
 			if (!lazy) {
 				chart.animating = true;
 			}
 
 			for (i = 0, ilen = animations.length; i < ilen; ++i) {
 				if (animations[i].chart === chart) {
 					animations[i] = animation;
 					return;
 				}
 			}
 
 			animations.push(animation);
 
 			// If there are no animations queued, manually kickstart a digest, for lack of a better word
 			if (animations.length === 1) {
 				this.requestAnimationFrame();
 			}
 		},
 
 		cancelAnimation: function(chart) {
 			var index = helpers.findIndex(this.animations, function(animation) {
 				return animation.chart === chart;
 			});
 
 			if (index !== -1) {
 				this.animations.splice(index, 1);
 				chart.animating = false;
 			}
 		},
 
 		requestAnimationFrame: function() {
 			var me = this;
 			if (me.request === null) {
 				// Skip animation frame requests until the active one is executed.
 				// This can happen when processing mouse events, e.g. 'mousemove'
 				// and 'mouseout' events will trigger multiple renders.
 				me.request = helpers.requestAnimFrame.call(window, function() {
 					me.request = null;
 					me.startDigest();
 				});
 			}
 		},
 
 		/**
 		 * @private
 		 */
 		startDigest: function() {
 			var me = this;
 			var startTime = Date.now();
 			var framesToDrop = 0;
 
 			if (me.dropFrames > 1) {
 				framesToDrop = Math.floor(me.dropFrames);
 				me.dropFrames = me.dropFrames % 1;
 			}
 
 			me.advance(1 + framesToDrop);
 
 			var endTime = Date.now();
 
 			me.dropFrames += (endTime - startTime) / me.frameDuration;
 
 			// Do we have more stuff to animate?
 			if (me.animations.length > 0) {
 				me.requestAnimationFrame();
 			}
 		},
 
 		/**
 		 * @private
 		 */
 		advance: function(count) {
 			var animations = this.animations;
 			var animation, chart;
 			var i = 0;
 
 			while (i < animations.length) {
 				animation = animations[i];
 				chart = animation.chart;
 
 				animation.currentStep = (animation.currentStep || 0) + count;
 				animation.currentStep = Math.min(animation.currentStep, animation.numSteps);
 
 				helpers.callback(animation.render, [chart, animation], chart);
 				helpers.callback(animation.onAnimationProgress, [animation], chart);
 
 				if (animation.currentStep >= animation.numSteps) {
 					helpers.callback(animation.onAnimationComplete, [animation], chart);
 					chart.animating = false;
 					animations.splice(i, 1);
 				} else {
 					++i;
 				}
 			}
 		}
 	};
 
 	/**
 	 * Provided for backward compatibility, use Chart.Animation instead
 	 * @prop Chart.Animation#animationObject
 	 * @deprecated since version 2.6.0
 	 * @todo remove at version 3
 	 */
 	Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
 		get: function() {
 			return this;
 		}
 	});
 
 	/**
 	 * Provided for backward compatibility, use Chart.Animation#chart instead
 	 * @prop Chart.Animation#chartInstance
 	 * @deprecated since version 2.6.0
 	 * @todo remove at version 3
 	 */
 	Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
 		get: function() {
 			return this.chart;
 		},
 		set: function(value) {
 			this.chart = value;
 		}
 	});
 
 };
 
 },{"25":25,"26":26,"45":45}],23:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var helpers = require(45);
 var Interaction = require(28);
 var layouts = require(30);
 var platform = require(48);
 var plugins = require(31);
 
 module.exports = function(Chart) {
 
 	// Create a dictionary of chart types, to allow for extension of existing types
 	Chart.types = {};
 
 	// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
 	// Destroy method on the chart will remove the instance of the chart from this reference.
 	Chart.instances = {};
 
 	// Controllers available for dataset visualization eg. bar, line, slice, etc.
 	Chart.controllers = {};
 
 	/**
 	 * Initializes the given config with global and chart default values.
 	 */
 	function initConfig(config) {
 		config = config || {};
 
 		// Do NOT use configMerge() for the data object because this method merges arrays
 		// and so would change references to labels and datasets, preventing data updates.
 		var data = config.data = config.data || {};
 		data.datasets = data.datasets || [];
 		data.labels = data.labels || [];
 
 		config.options = helpers.configMerge(
 			defaults.global,
 			defaults[config.type],
 			config.options || {});
 
 		return config;
 	}
 
 	/**
 	 * Updates the config of the chart
 	 * @param chart {Chart} chart to update the options for
 	 */
 	function updateConfig(chart) {
 		var newOptions = chart.options;
 
 		helpers.each(chart.scales, function(scale) {
 			layouts.removeBox(chart, scale);
 		});
 
 		newOptions = helpers.configMerge(
 			Chart.defaults.global,
 			Chart.defaults[chart.config.type],
 			newOptions);
 
 		chart.options = chart.config.options = newOptions;
 		chart.ensureScalesHaveIDs();
 		chart.buildOrUpdateScales();
 		// Tooltip
 		chart.tooltip._options = newOptions.tooltips;
 		chart.tooltip.initialize();
 	}
 
 	function positionIsHorizontal(position) {
 		return position === 'top' || position === 'bottom';
 	}
 
 	helpers.extend(Chart.prototype, /** @lends Chart */ {
 		/**
 		 * @private
 		 */
 		construct: function(item, config) {
 			var me = this;
 
 			config = initConfig(config);
 
 			var context = platform.acquireContext(item, config);
 			var canvas = context && context.canvas;
 			var height = canvas && canvas.height;
 			var width = canvas && canvas.width;
 
 			me.id = helpers.uid();
 			me.ctx = context;
 			me.canvas = canvas;
 			me.config = config;
 			me.width = width;
 			me.height = height;
 			me.aspectRatio = height ? width / height : null;
 			me.options = config.options;
 			me._bufferedRender = false;
 
 			/**
 			 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
 			 * the "instance" still need to be defined since it might be called from plugins.
 			 * @prop Chart#chart
 			 * @deprecated since version 2.6.0
 			 * @todo remove at version 3
 			 * @private
 			 */
 			me.chart = me;
 			me.controller = me; // chart.chart.controller #inception
 
 			// Add the chart instance to the global namespace
 			Chart.instances[me.id] = me;
 
 			// Define alias to the config data: `chart.data === chart.config.data`
 			Object.defineProperty(me, 'data', {
 				get: function() {
 					return me.config.data;
 				},
 				set: function(value) {
 					me.config.data = value;
 				}
 			});
 
 			if (!context || !canvas) {
 				// The given item is not a compatible context2d element, let's return before finalizing
 				// the chart initialization but after setting basic chart / controller properties that
 				// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
 				// https://github.com/chartjs/Chart.js/issues/2807
 				console.error("Failed to create chart: can't acquire context from the given item");
 				return;
 			}
 
 			me.initialize();
 			me.update();
 		},
 
 		/**
 		 * @private
 		 */
 		initialize: function() {
 			var me = this;
 
 			// Before init plugin notification
 			plugins.notify(me, 'beforeInit');
 
 			helpers.retinaScale(me, me.options.devicePixelRatio);
 
 			me.bindEvents();
 
 			if (me.options.responsive) {
 				// Initial resize before chart draws (must be silent to preserve initial animations).
 				me.resize(true);
 			}
 
 			// Make sure scales have IDs and are built before we build any controllers.
 			me.ensureScalesHaveIDs();
 			me.buildOrUpdateScales();
 			me.initToolTip();
 
 			// After init plugin notification
 			plugins.notify(me, 'afterInit');
 
 			return me;
 		},
 
 		clear: function() {
 			helpers.canvas.clear(this);
 			return this;
 		},
 
 		stop: function() {
 			// Stops any current animation loop occurring
 			Chart.animationService.cancelAnimation(this);
 			return this;
 		},
 
 		resize: function(silent) {
 			var me = this;
 			var options = me.options;
 			var canvas = me.canvas;
 			var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;
 
 			// the canvas render width and height will be casted to integers so make sure that
 			// the canvas display style uses the same integer values to avoid blurring effect.
 
 			// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased
 			var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
 			var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));
 
 			if (me.width === newWidth && me.height === newHeight) {
 				return;
 			}
 
 			canvas.width = me.width = newWidth;
 			canvas.height = me.height = newHeight;
 			canvas.style.width = newWidth + 'px';
 			canvas.style.height = newHeight + 'px';
 
 			helpers.retinaScale(me, options.devicePixelRatio);
 
 			if (!silent) {
 				// Notify any plugins about the resize
 				var newSize = {width: newWidth, height: newHeight};
 				plugins.notify(me, 'resize', [newSize]);
 
 				// Notify of resize
 				if (me.options.onResize) {
 					me.options.onResize(me, newSize);
 				}
 
 				me.stop();
 				me.update(me.options.responsiveAnimationDuration);
 			}
 		},
 
 		ensureScalesHaveIDs: function() {
 			var options = this.options;
 			var scalesOptions = options.scales || {};
 			var scaleOptions = options.scale;
 
 			helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
 				xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
 			});
 
 			helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
 				yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
 			});
 
 			if (scaleOptions) {
 				scaleOptions.id = scaleOptions.id || 'scale';
 			}
 		},
 
 		/**
 		 * Builds a map of scale ID to scale object for future lookup.
 		 */
 		buildOrUpdateScales: function() {
 			var me = this;
 			var options = me.options;
 			var scales = me.scales || {};
 			var items = [];
 			var updated = Object.keys(scales).reduce(function(obj, id) {
 				obj[id] = false;
 				return obj;
 			}, {});
 
 			if (options.scales) {
 				items = items.concat(
 					(options.scales.xAxes || []).map(function(xAxisOptions) {
 						return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
 					}),
 					(options.scales.yAxes || []).map(function(yAxisOptions) {
 						return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
 					})
 				);
 			}
 
 			if (options.scale) {
 				items.push({
 					options: options.scale,
 					dtype: 'radialLinear',
 					isDefault: true,
 					dposition: 'chartArea'
 				});
 			}
 
 			helpers.each(items, function(item) {
 				var scaleOptions = item.options;
 				var id = scaleOptions.id;
 				var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
 
 				if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
 					scaleOptions.position = item.dposition;
 				}
 
 				updated[id] = true;
 				var scale = null;
 				if (id in scales && scales[id].type === scaleType) {
 					scale = scales[id];
 					scale.options = scaleOptions;
 					scale.ctx = me.ctx;
 					scale.chart = me;
 				} else {
 					var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
 					if (!scaleClass) {
 						return;
 					}
 					scale = new scaleClass({
 						id: id,
 						type: scaleType,
 						options: scaleOptions,
 						ctx: me.ctx,
 						chart: me
 					});
 					scales[scale.id] = scale;
 				}
 
 				scale.mergeTicksOptions();
 
 				// TODO(SB): I think we should be able to remove this custom case (options.scale)
 				// and consider it as a regular scale part of the "scales"" map only! This would
 				// make the logic easier and remove some useless? custom code.
 				if (item.isDefault) {
 					me.scale = scale;
 				}
 			});
 			// clear up discarded scales
 			helpers.each(updated, function(hasUpdated, id) {
 				if (!hasUpdated) {
 					delete scales[id];
 				}
 			});
 
 			me.scales = scales;
 
 			Chart.scaleService.addScalesToLayout(this);
 		},
 
 		buildOrUpdateControllers: function() {
 			var me = this;
 			var types = [];
 			var newControllers = [];
 
 			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
 				var meta = me.getDatasetMeta(datasetIndex);
 				var type = dataset.type || me.config.type;
 
 				if (meta.type && meta.type !== type) {
 					me.destroyDatasetMeta(datasetIndex);
 					meta = me.getDatasetMeta(datasetIndex);
 				}
 				meta.type = type;
 
 				types.push(meta.type);
 
 				if (meta.controller) {
 					meta.controller.updateIndex(datasetIndex);
 					meta.controller.linkScales();
 				} else {
 					var ControllerClass = Chart.controllers[meta.type];
 					if (ControllerClass === undefined) {
 						throw new Error('"' + meta.type + '" is not a chart type.');
 					}
 
 					meta.controller = new ControllerClass(me, datasetIndex);
 					newControllers.push(meta.controller);
 				}
 			}, me);
 
 			return newControllers;
 		},
 
 		/**
 		 * Reset the elements of all datasets
 		 * @private
 		 */
 		resetElements: function() {
 			var me = this;
 			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
 				me.getDatasetMeta(datasetIndex).controller.reset();
 			}, me);
 		},
 
 		/**
 		* Resets the chart back to it's state before the initial animation
 		*/
 		reset: function() {
 			this.resetElements();
 			this.tooltip.initialize();
 		},
 
 		update: function(config) {
 			var me = this;
 
 			if (!config || typeof config !== 'object') {
 				// backwards compatibility
 				config = {
 					duration: config,
 					lazy: arguments[1]
 				};
 			}
 
 			updateConfig(me);
 
 			// plugins options references might have change, let's invalidate the cache
 			// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
 			plugins._invalidate(me);
 
 			if (plugins.notify(me, 'beforeUpdate') === false) {
 				return;
 			}
 
 			// In case the entire data object changed
 			me.tooltip._data = me.data;
 
 			// Make sure dataset controllers are updated and new controllers are reset
 			var newControllers = me.buildOrUpdateControllers();
 
 			// Make sure all dataset controllers have correct meta data counts
 			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
 				me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
 			}, me);
 
 			me.updateLayout();
 
 			// Can only reset the new controllers after the scales have been updated
 			if (me.options.animation && me.options.animation.duration) {
 				helpers.each(newControllers, function(controller) {
 					controller.reset();
 				});
 			}
 
 			me.updateDatasets();
 
 			// Need to reset tooltip in case it is displayed with elements that are removed
 			// after update.
 			me.tooltip.initialize();
 
 			// Last active contains items that were previously in the tooltip.
 			// When we reset the tooltip, we need to clear it
 			me.lastActive = [];
 
 			// Do this before render so that any plugins that need final scale updates can use it
 			plugins.notify(me, 'afterUpdate');
 
 			if (me._bufferedRender) {
 				me._bufferedRequest = {
 					duration: config.duration,
 					easing: config.easing,
 					lazy: config.lazy
 				};
 			} else {
 				me.render(config);
 			}
 		},
 
 		/**
 		 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
 		 * hook, in which case, plugins will not be called on `afterLayout`.
 		 * @private
 		 */
 		updateLayout: function() {
 			var me = this;
 
 			if (plugins.notify(me, 'beforeLayout') === false) {
 				return;
 			}
 
 			layouts.update(this, this.width, this.height);
 
 			/**
 			 * Provided for backward compatibility, use `afterLayout` instead.
 			 * @method IPlugin#afterScaleUpdate
 			 * @deprecated since version 2.5.0
 			 * @todo remove at version 3
 			 * @private
 			 */
 			plugins.notify(me, 'afterScaleUpdate');
 			plugins.notify(me, 'afterLayout');
 		},
 
 		/**
 		 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
 		 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
 		 * @private
 		 */
 		updateDatasets: function() {
 			var me = this;
 
 			if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
 				return;
 			}
 
 			for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
 				me.updateDataset(i);
 			}
 
 			plugins.notify(me, 'afterDatasetsUpdate');
 		},
 
 		/**
 		 * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
 		 * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
 		 * @private
 		 */
 		updateDataset: function(index) {
 			var me = this;
 			var meta = me.getDatasetMeta(index);
 			var args = {
 				meta: meta,
 				index: index
 			};
 
 			if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
 				return;
 			}
 
 			meta.controller.update();
 
 			plugins.notify(me, 'afterDatasetUpdate', [args]);
 		},
 
 		render: function(config) {
 			var me = this;
 
 			if (!config || typeof config !== 'object') {
 				// backwards compatibility
 				config = {
 					duration: config,
 					lazy: arguments[1]
 				};
 			}
 
 			var duration = config.duration;
 			var lazy = config.lazy;
 
 			if (plugins.notify(me, 'beforeRender') === false) {
 				return;
 			}
 
 			var animationOptions = me.options.animation;
 			var onComplete = function(animation) {
 				plugins.notify(me, 'afterRender');
 				helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
 			};
 
 			if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
 				var animation = new Chart.Animation({
 					numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
 					easing: config.easing || animationOptions.easing,
 
 					render: function(chart, animationObject) {
 						var easingFunction = helpers.easing.effects[animationObject.easing];
 						var currentStep = animationObject.currentStep;
 						var stepDecimal = currentStep / animationObject.numSteps;
 
 						chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
 					},
 
 					onAnimationProgress: animationOptions.onProgress,
 					onAnimationComplete: onComplete
 				});
 
 				Chart.animationService.addAnimation(me, animation, duration, lazy);
 			} else {
 				me.draw();
 
 				// See https://github.com/chartjs/Chart.js/issues/3781
 				onComplete(new Chart.Animation({numSteps: 0, chart: me}));
 			}
 
 			return me;
 		},
 
 		draw: function(easingValue) {
 			var me = this;
 
 			me.clear();
 
 			if (helpers.isNullOrUndef(easingValue)) {
 				easingValue = 1;
 			}
 
 			me.transition(easingValue);
 
 			if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
 				return;
 			}
 
 			// Draw all the scales
 			helpers.each(me.boxes, function(box) {
 				box.draw(me.chartArea);
 			}, me);
 
 			if (me.scale) {
 				me.scale.draw();
 			}
 
 			me.drawDatasets(easingValue);
 			me._drawTooltip(easingValue);
 
 			plugins.notify(me, 'afterDraw', [easingValue]);
 		},
 
 		/**
 		 * @private
 		 */
 		transition: function(easingValue) {
 			var me = this;
 
 			for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
 				if (me.isDatasetVisible(i)) {
 					me.getDatasetMeta(i).controller.transition(easingValue);
 				}
 			}
 
 			me.tooltip.transition(easingValue);
 		},
 
 		/**
 		 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
 		 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
 		 * @private
 		 */
 		drawDatasets: function(easingValue) {
 			var me = this;
 
 			if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
 				return;
 			}
 
 			// Draw datasets reversed to support proper line stacking
 			for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
 				if (me.isDatasetVisible(i)) {
 					me.drawDataset(i, easingValue);
 				}
 			}
 
 			plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
 		},
 
 		/**
 		 * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
 		 * hook, in which case, plugins will not be called on `afterDatasetDraw`.
 		 * @private
 		 */
 		drawDataset: function(index, easingValue) {
 			var me = this;
 			var meta = me.getDatasetMeta(index);
 			var args = {
 				meta: meta,
 				index: index,
 				easingValue: easingValue
 			};
 
 			if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
 				return;
 			}
 
 			meta.controller.draw(easingValue);
 
 			plugins.notify(me, 'afterDatasetDraw', [args]);
 		},
 
 		/**
 		 * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
 		 * hook, in which case, plugins will not be called on `afterTooltipDraw`.
 		 * @private
 		 */
 		_drawTooltip: function(easingValue) {
 			var me = this;
 			var tooltip = me.tooltip;
 			var args = {
 				tooltip: tooltip,
 				easingValue: easingValue
 			};
 
 			if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
 				return;
 			}
 
 			tooltip.draw();
 
 			plugins.notify(me, 'afterTooltipDraw', [args]);
 		},
 
 		// Get the single element that was clicked on
 		// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
 		getElementAtEvent: function(e) {
 			return Interaction.modes.single(this, e);
 		},
 
 		getElementsAtEvent: function(e) {
 			return Interaction.modes.label(this, e, {intersect: true});
 		},
 
 		getElementsAtXAxis: function(e) {
 			return Interaction.modes['x-axis'](this, e, {intersect: true});
 		},
 
 		getElementsAtEventForMode: function(e, mode, options) {
 			var method = Interaction.modes[mode];
 			if (typeof method === 'function') {
 				return method(this, e, options);
 			}
 
 			return [];
 		},
 
 		getDatasetAtEvent: function(e) {
 			return Interaction.modes.dataset(this, e, {intersect: true});
 		},
 
 		getDatasetMeta: function(datasetIndex) {
 			var me = this;
 			var dataset = me.data.datasets[datasetIndex];
 			if (!dataset._meta) {
 				dataset._meta = {};
 			}
 
 			var meta = dataset._meta[me.id];
 			if (!meta) {
 				meta = dataset._meta[me.id] = {
 					type: null,
 					data: [],
 					dataset: null,
 					controller: null,
 					hidden: null,			// See isDatasetVisible() comment
 					xAxisID: null,
 					yAxisID: null
 				};
 			}
 
 			return meta;
 		},
 
 		getVisibleDatasetCount: function() {
 			var count = 0;
 			for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
 				if (this.isDatasetVisible(i)) {
 					count++;
 				}
 			}
 			return count;
 		},
 
 		isDatasetVisible: function(datasetIndex) {
 			var meta = this.getDatasetMeta(datasetIndex);
 
 			// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
 			// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
 			return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
 		},
 
 		generateLegend: function() {
 			return this.options.legendCallback(this);
 		},
 
 		/**
 		 * @private
 		 */
 		destroyDatasetMeta: function(datasetIndex) {
 			var id = this.id;
 			var dataset = this.data.datasets[datasetIndex];
 			var meta = dataset._meta && dataset._meta[id];
 
 			if (meta) {
 				meta.controller.destroy();
 				delete dataset._meta[id];
 			}
 		},
 
 		destroy: function() {
 			var me = this;
 			var canvas = me.canvas;
 			var i, ilen;
 
 			me.stop();
 
 			// dataset controllers need to cleanup associated data
 			for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
 				me.destroyDatasetMeta(i);
 			}
 
 			if (canvas) {
 				me.unbindEvents();
 				helpers.canvas.clear(me);
 				platform.releaseContext(me.ctx);
 				me.canvas = null;
 				me.ctx = null;
 			}
 
 			plugins.notify(me, 'destroy');
 
 			delete Chart.instances[me.id];
 		},
 
 		toBase64Image: function() {
 			return this.canvas.toDataURL.apply(this.canvas, arguments);
 		},
 
 		initToolTip: function() {
 			var me = this;
 			me.tooltip = new Chart.Tooltip({
 				_chart: me,
 				_chartInstance: me, // deprecated, backward compatibility
 				_data: me.data,
 				_options: me.options.tooltips
 			}, me);
 		},
 
 		/**
 		 * @private
 		 */
 		bindEvents: function() {
 			var me = this;
 			var listeners = me._listeners = {};
 			var listener = function() {
 				me.eventHandler.apply(me, arguments);
 			};
 
 			helpers.each(me.options.events, function(type) {
 				platform.addEventListener(me, type, listener);
 				listeners[type] = listener;
 			});
 
 			// Elements used to detect size change should not be injected for non responsive charts.
 			// See https://github.com/chartjs/Chart.js/issues/2210
 			if (me.options.responsive) {
 				listener = function() {
 					me.resize();
 				};
 
 				platform.addEventListener(me, 'resize', listener);
 				listeners.resize = listener;
 			}
 		},
 
 		/**
 		 * @private
 		 */
 		unbindEvents: function() {
 			var me = this;
 			var listeners = me._listeners;
 			if (!listeners) {
 				return;
 			}
 
 			delete me._listeners;
 			helpers.each(listeners, function(listener, type) {
 				platform.removeEventListener(me, type, listener);
 			});
 		},
 
 		updateHoverStyle: function(elements, mode, enabled) {
 			var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
 			var element, i, ilen;
 
 			for (i = 0, ilen = elements.length; i < ilen; ++i) {
 				element = elements[i];
 				if (element) {
 					this.getDatasetMeta(element._datasetIndex).controller[method](element);
 				}
 			}
 		},
 
 		/**
 		 * @private
 		 */
 		eventHandler: function(e) {
 			var me = this;
 			var tooltip = me.tooltip;
 
 			if (plugins.notify(me, 'beforeEvent', [e]) === false) {
 				return;
 			}
 
 			// Buffer any update calls so that renders do not occur
 			me._bufferedRender = true;
 			me._bufferedRequest = null;
 
 			var changed = me.handleEvent(e);
 			// for smooth tooltip animations issue #4989
 			// the tooltip should be the source of change
 			// Animation check workaround:
 			// tooltip._start will be null when tooltip isn't animating
 			if (tooltip) {
 				changed = tooltip._start
 					? tooltip.handleEvent(e)
 					: changed | tooltip.handleEvent(e);
 			}
 
 			plugins.notify(me, 'afterEvent', [e]);
 
 			var bufferedRequest = me._bufferedRequest;
 			if (bufferedRequest) {
 				// If we have an update that was triggered, we need to do a normal render
 				me.render(bufferedRequest);
 			} else if (changed && !me.animating) {
 				// If entering, leaving, or changing elements, animate the change via pivot
 				me.stop();
 
 				// We only need to render at this point. Updating will cause scales to be
 				// recomputed generating flicker & using more memory than necessary.
 				me.render(me.options.hover.animationDuration, true);
 			}
 
 			me._bufferedRender = false;
 			me._bufferedRequest = null;
 
 			return me;
 		},
 
 		/**
 		 * Handle an event
 		 * @private
 		 * @param {IEvent} event the event to handle
 		 * @return {Boolean} true if the chart needs to re-render
 		 */
 		handleEvent: function(e) {
 			var me = this;
 			var options = me.options || {};
 			var hoverOptions = options.hover;
 			var changed = false;
 
 			me.lastActive = me.lastActive || [];
 
 			// Find Active Elements for hover and tooltips
 			if (e.type === 'mouseout') {
 				me.active = [];
 			} else {
 				me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
 			}
 
 			// Invoke onHover hook
 			// Need to call with native event here to not break backwards compatibility
 			helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);
 
 			if (e.type === 'mouseup' || e.type === 'click') {
 				if (options.onClick) {
 					// Use e.native here for backwards compatibility
 					options.onClick.call(me, e.native, me.active);
 				}
 			}
 
 			// Remove styling for last active (even if it may still be active)
 			if (me.lastActive.length) {
 				me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
 			}
 
 			// Built in hover styling
 			if (me.active.length && hoverOptions.mode) {
 				me.updateHoverStyle(me.active, hoverOptions.mode, true);
 			}
 
 			changed = !helpers.arrayEquals(me.active, me.lastActive);
 
 			// Remember Last Actives
 			me.lastActive = me.active;
 
 			return changed;
 		}
 	});
 
 	/**
 	 * Provided for backward compatibility, use Chart instead.
 	 * @class Chart.Controller
 	 * @deprecated since version 2.6.0
 	 * @todo remove at version 3
 	 * @private
 	 */
 	Chart.Controller = Chart;
 };
 
 },{"25":25,"28":28,"30":30,"31":31,"45":45,"48":48}],24:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 
 module.exports = function(Chart) {
 
 	var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
 
 	/**
 	 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
 	 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
 	 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
 	 */
 	function listenArrayEvents(array, listener) {
 		if (array._chartjs) {
 			array._chartjs.listeners.push(listener);
 			return;
 		}
 
 		Object.defineProperty(array, '_chartjs', {
 			configurable: true,
 			enumerable: false,
 			value: {
 				listeners: [listener]
 			}
 		});
 
 		arrayEvents.forEach(function(key) {
 			var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
 			var base = array[key];
 
 			Object.defineProperty(array, key, {
 				configurable: true,
 				enumerable: false,
 				value: function() {
 					var args = Array.prototype.slice.call(arguments);
 					var res = base.apply(this, args);
 
 					helpers.each(array._chartjs.listeners, function(object) {
 						if (typeof object[method] === 'function') {
 							object[method].apply(object, args);
 						}
 					});
 
 					return res;
 				}
 			});
 		});
 	}
 
 	/**
 	 * Removes the given array event listener and cleanup extra attached properties (such as
 	 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
 	 */
 	function unlistenArrayEvents(array, listener) {
 		var stub = array._chartjs;
 		if (!stub) {
 			return;
 		}
 
 		var listeners = stub.listeners;
 		var index = listeners.indexOf(listener);
 		if (index !== -1) {
 			listeners.splice(index, 1);
 		}
 
 		if (listeners.length > 0) {
 			return;
 		}
 
 		arrayEvents.forEach(function(key) {
 			delete array[key];
 		});
 
 		delete array._chartjs;
 	}
 
 	// Base class for all dataset controllers (line, bar, etc)
 	Chart.DatasetController = function(chart, datasetIndex) {
 		this.initialize(chart, datasetIndex);
 	};
 
 	helpers.extend(Chart.DatasetController.prototype, {
 
 		/**
 		 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
 		 * @type {Chart.core.element}
 		 */
 		datasetElementType: null,
 
 		/**
 		 * Element type used to generate a meta data (e.g. Chart.element.Point).
 		 * @type {Chart.core.element}
 		 */
 		dataElementType: null,
 
 		initialize: function(chart, datasetIndex) {
 			var me = this;
 			me.chart = chart;
 			me.index = datasetIndex;
 			me.linkScales();
 			me.addElements();
 		},
 
 		updateIndex: function(datasetIndex) {
 			this.index = datasetIndex;
 		},
 
 		linkScales: function() {
 			var me = this;
 			var meta = me.getMeta();
 			var dataset = me.getDataset();
 
 			if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
 				meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
 			}
 			if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
 				meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
 			}
 		},
 
 		getDataset: function() {
 			return this.chart.data.datasets[this.index];
 		},
 
 		getMeta: function() {
 			return this.chart.getDatasetMeta(this.index);
 		},
 
 		getScaleForId: function(scaleID) {
 			return this.chart.scales[scaleID];
 		},
 
 		reset: function() {
 			this.update(true);
 		},
 
 		/**
 		 * @private
 		 */
 		destroy: function() {
 			if (this._data) {
 				unlistenArrayEvents(this._data, this);
 			}
 		},
 
 		createMetaDataset: function() {
 			var me = this;
 			var type = me.datasetElementType;
 			return type && new type({
 				_chart: me.chart,
 				_datasetIndex: me.index
 			});
 		},
 
 		createMetaData: function(index) {
 			var me = this;
 			var type = me.dataElementType;
 			return type && new type({
 				_chart: me.chart,
 				_datasetIndex: me.index,
 				_index: index
 			});
 		},
 
 		addElements: function() {
 			var me = this;
 			var meta = me.getMeta();
 			var data = me.getDataset().data || [];
 			var metaData = meta.data;
 			var i, ilen;
 
 			for (i = 0, ilen = data.length; i < ilen; ++i) {
 				metaData[i] = metaData[i] || me.createMetaData(i);
 			}
 
 			meta.dataset = meta.dataset || me.createMetaDataset();
 		},
 
 		addElementAndReset: function(index) {
 			var element = this.createMetaData(index);
 			this.getMeta().data.splice(index, 0, element);
 			this.updateElement(element, index, true);
 		},
 
 		buildOrUpdateElements: function() {
 			var me = this;
 			var dataset = me.getDataset();
 			var data = dataset.data || (dataset.data = []);
 
 			// In order to correctly handle data addition/deletion animation (an thus simulate
 			// real-time charts), we need to monitor these data modifications and synchronize
 			// the internal meta data accordingly.
 			if (me._data !== data) {
 				if (me._data) {
 					// This case happens when the user replaced the data array instance.
 					unlistenArrayEvents(me._data, me);
 				}
 
 				listenArrayEvents(data, me);
 				me._data = data;
 			}
 
 			// Re-sync meta data in case the user replaced the data array or if we missed
 			// any updates and so make sure that we handle number of datapoints changing.
 			me.resyncElements();
 		},
 
 		update: helpers.noop,
 
 		transition: function(easingValue) {
 			var meta = this.getMeta();
 			var elements = meta.data || [];
 			var ilen = elements.length;
 			var i = 0;
 
 			for (; i < ilen; ++i) {
 				elements[i].transition(easingValue);
 			}
 
 			if (meta.dataset) {
 				meta.dataset.transition(easingValue);
 			}
 		},
 
 		draw: function() {
 			var meta = this.getMeta();
 			var elements = meta.data || [];
 			var ilen = elements.length;
 			var i = 0;
 
 			if (meta.dataset) {
 				meta.dataset.draw();
 			}
 
 			for (; i < ilen; ++i) {
 				elements[i].draw();
 			}
 		},
 
 		removeHoverStyle: function(element, elementOpts) {
 			var dataset = this.chart.data.datasets[element._datasetIndex];
 			var index = element._index;
 			var custom = element.custom || {};
 			var valueOrDefault = helpers.valueAtIndexOrDefault;
 			var model = element._model;
 
 			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
 			model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
 			model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
 		},
 
 		setHoverStyle: function(element) {
 			var dataset = this.chart.data.datasets[element._datasetIndex];
 			var index = element._index;
 			var custom = element.custom || {};
 			var valueOrDefault = helpers.valueAtIndexOrDefault;
 			var getHoverColor = helpers.getHoverColor;
 			var model = element._model;
 
 			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
 			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
 			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
 		},
 
 		/**
 		 * @private
 		 */
 		resyncElements: function() {
 			var me = this;
 			var meta = me.getMeta();
 			var data = me.getDataset().data;
 			var numMeta = meta.data.length;
 			var numData = data.length;
 
 			if (numData < numMeta) {
 				meta.data.splice(numData, numMeta - numData);
 			} else if (numData > numMeta) {
 				me.insertElements(numMeta, numData - numMeta);
 			}
 		},
 
 		/**
 		 * @private
 		 */
 		insertElements: function(start, count) {
 			for (var i = 0; i < count; ++i) {
 				this.addElementAndReset(start + i);
 			}
 		},
 
 		/**
 		 * @private
 		 */
 		onDataPush: function() {
 			this.insertElements(this.getDataset().data.length - 1, arguments.length);
 		},
 
 		/**
 		 * @private
 		 */
 		onDataPop: function() {
 			this.getMeta().data.pop();
 		},
 
 		/**
 		 * @private
 		 */
 		onDataShift: function() {
 			this.getMeta().data.shift();
 		},
 
 		/**
 		 * @private
 		 */
 		onDataSplice: function(start, count) {
 			this.getMeta().data.splice(start, count);
 			this.insertElements(start, arguments.length - 2);
 		},
 
 		/**
 		 * @private
 		 */
 		onDataUnshift: function() {
 			this.insertElements(0, arguments.length);
 		}
 	});
 
 	Chart.DatasetController.extend = helpers.inherits;
 };
 
 },{"45":45}],25:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 
 module.exports = {
 	/**
 	 * @private
 	 */
 	_set: function(scope, values) {
 		return helpers.merge(this[scope] || (this[scope] = {}), values);
 	}
 };
 
 },{"45":45}],26:[function(require,module,exports){
 'use strict';
 
 var color = require(3);
 var helpers = require(45);
 
 function interpolate(start, view, model, ease) {
 	var keys = Object.keys(model);
 	var i, ilen, key, actual, origin, target, type, c0, c1;
 
 	for (i = 0, ilen = keys.length; i < ilen; ++i) {
 		key = keys[i];
 
 		target = model[key];
 
 		// if a value is added to the model after pivot() has been called, the view
 		// doesn't contain it, so let's initialize the view to the target value.
 		if (!view.hasOwnProperty(key)) {
 			view[key] = target;
 		}
 
 		actual = view[key];
 
 		if (actual === target || key[0] === '_') {
 			continue;
 		}
 
 		if (!start.hasOwnProperty(key)) {
 			start[key] = actual;
 		}
 
 		origin = start[key];
 
 		type = typeof target;
 
 		if (type === typeof origin) {
 			if (type === 'string') {
 				c0 = color(origin);
 				if (c0.valid) {
 					c1 = color(target);
 					if (c1.valid) {
 						view[key] = c1.mix(c0, ease).rgbString();
 						continue;
 					}
 				}
 			} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
 				view[key] = origin + (target - origin) * ease;
 				continue;
 			}
 		}
 
 		view[key] = target;
 	}
 }
 
 var Element = function(configuration) {
 	helpers.extend(this, configuration);
 	this.initialize.apply(this, arguments);
 };
 
 helpers.extend(Element.prototype, {
 
 	initialize: function() {
 		this.hidden = false;
 	},
 
 	pivot: function() {
 		var me = this;
 		if (!me._view) {
 			me._view = helpers.clone(me._model);
 		}
 		me._start = {};
 		return me;
 	},
 
 	transition: function(ease) {
 		var me = this;
 		var model = me._model;
 		var start = me._start;
 		var view = me._view;
 
 		// No animation -> No Transition
 		if (!model || ease === 1) {
 			me._view = model;
 			me._start = null;
 			return me;
 		}
 
 		if (!view) {
 			view = me._view = {};
 		}
 
 		if (!start) {
 			start = me._start = {};
 		}
 
 		interpolate(start, view, model, ease);
 
 		return me;
 	},
 
 	tooltipPosition: function() {
 		return {
 			x: this._model.x,
 			y: this._model.y
 		};
 	},
 
 	hasValue: function() {
 		return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
 	}
 });
 
 Element.extend = helpers.inherits;
 
 module.exports = Element;
 
 },{"3":3,"45":45}],27:[function(require,module,exports){
 /* global window: false */
 /* global document: false */
 'use strict';
 
 var color = require(3);
 var defaults = require(25);
 var helpers = require(45);
 
 module.exports = function(Chart) {
 
 	// -- Basic js utility methods
 
 	helpers.configMerge = function(/* objects ... */) {
 		return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
 			merger: function(key, target, source, options) {
 				var tval = target[key] || {};
 				var sval = source[key];
 
 				if (key === 'scales') {
 					// scale config merging is complex. Add our own function here for that
 					target[key] = helpers.scaleMerge(tval, sval);
 				} else if (key === 'scale') {
 					// used in polar area & radar charts since there is only one scale
 					target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
 				} else {
 					helpers._merger(key, target, source, options);
 				}
 			}
 		});
 	};
 
 	helpers.scaleMerge = function(/* objects ... */) {
 		return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
 			merger: function(key, target, source, options) {
 				if (key === 'xAxes' || key === 'yAxes') {
 					var slen = source[key].length;
 					var i, type, scale;
 
 					if (!target[key]) {
 						target[key] = [];
 					}
 
 					for (i = 0; i < slen; ++i) {
 						scale = source[key][i];
 						type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');
 
 						if (i >= target[key].length) {
 							target[key].push({});
 						}
 
 						if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
 							// new/untyped scale or type changed: let's apply the new defaults
 							// then merge source scale to correctly overwrite the defaults.
 							helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
 						} else {
 							// scales type are the same
 							helpers.merge(target[key][i], scale);
 						}
 					}
 				} else {
 					helpers._merger(key, target, source, options);
 				}
 			}
 		});
 	};
 
 	helpers.where = function(collection, filterCallback) {
 		if (helpers.isArray(collection) && Array.prototype.filter) {
 			return collection.filter(filterCallback);
 		}
 		var filtered = [];
 
 		helpers.each(collection, function(item) {
 			if (filterCallback(item)) {
 				filtered.push(item);
 			}
 		});
 
 		return filtered;
 	};
 	helpers.findIndex = Array.prototype.findIndex ?
 		function(array, callback, scope) {
 			return array.findIndex(callback, scope);
 		} :
 		function(array, callback, scope) {
 			scope = scope === undefined ? array : scope;
 			for (var i = 0, ilen = array.length; i < ilen; ++i) {
 				if (callback.call(scope, array[i], i, array)) {
 					return i;
 				}
 			}
 			return -1;
 		};
 	helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
 		// Default to start of the array
 		if (helpers.isNullOrUndef(startIndex)) {
 			startIndex = -1;
 		}
 		for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
 			var currentItem = arrayToSearch[i];
 			if (filterCallback(currentItem)) {
 				return currentItem;
 			}
 		}
 	};
 	helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
 		// Default to end of the array
 		if (helpers.isNullOrUndef(startIndex)) {
 			startIndex = arrayToSearch.length;
 		}
 		for (var i = startIndex - 1; i >= 0; i--) {
 			var currentItem = arrayToSearch[i];
 			if (filterCallback(currentItem)) {
 				return currentItem;
 			}
 		}
 	};
 
 	// -- Math methods
 	helpers.isNumber = function(n) {
 		return !isNaN(parseFloat(n)) && isFinite(n);
 	};
 	helpers.almostEquals = function(x, y, epsilon) {
 		return Math.abs(x - y) < epsilon;
 	};
 	helpers.almostWhole = function(x, epsilon) {
 		var rounded = Math.round(x);
 		return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
 	};
 	helpers.max = function(array) {
 		return array.reduce(function(max, value) {
 			if (!isNaN(value)) {
 				return Math.max(max, value);
 			}
 			return max;
 		}, Number.NEGATIVE_INFINITY);
 	};
 	helpers.min = function(array) {
 		return array.reduce(function(min, value) {
 			if (!isNaN(value)) {
 				return Math.min(min, value);
 			}
 			return min;
 		}, Number.POSITIVE_INFINITY);
 	};
 	helpers.sign = Math.sign ?
 		function(x) {
 			return Math.sign(x);
 		} :
 		function(x) {
 			x = +x; // convert to a number
 			if (x === 0 || isNaN(x)) {
 				return x;
 			}
 			return x > 0 ? 1 : -1;
 		};
 	helpers.log10 = Math.log10 ?
 		function(x) {
 			return Math.log10(x);
 		} :
 		function(x) {
 			var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
 			// Check for whole powers of 10,
 			// which due to floating point rounding error should be corrected.
 			var powerOf10 = Math.round(exponent);
 			var isPowerOf10 = x === Math.pow(10, powerOf10);
 
 			return isPowerOf10 ? powerOf10 : exponent;
 		};
 	helpers.toRadians = function(degrees) {
 		return degrees * (Math.PI / 180);
 	};
 	helpers.toDegrees = function(radians) {
 		return radians * (180 / Math.PI);
 	};
 	// Gets the angle from vertical upright to the point about a centre.
 	helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
 		var distanceFromXCenter = anglePoint.x - centrePoint.x;
 		var distanceFromYCenter = anglePoint.y - centrePoint.y;
 		var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
 
 		var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
 
 		if (angle < (-0.5 * Math.PI)) {
 			angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
 		}
 
 		return {
 			angle: angle,
 			distance: radialDistanceFromCenter
 		};
 	};
 	helpers.distanceBetweenPoints = function(pt1, pt2) {
 		return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
 	};
 	helpers.aliasPixel = function(pixelWidth) {
 		return (pixelWidth % 2 === 0) ? 0 : 0.5;
 	};
 	helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
 		// Props to Rob Spencer at scaled innovation for his post on splining between points
 		// http://scaledinnovation.com/analytics/splines/aboutSplines.html
 
 		// This function must also respect "skipped" points
 
 		var previous = firstPoint.skip ? middlePoint : firstPoint;
 		var current = middlePoint;
 		var next = afterPoint.skip ? middlePoint : afterPoint;
 
 		var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
 		var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
 
 		var s01 = d01 / (d01 + d12);
 		var s12 = d12 / (d01 + d12);
 
 		// If all points are the same, s01 & s02 will be inf
 		s01 = isNaN(s01) ? 0 : s01;
 		s12 = isNaN(s12) ? 0 : s12;
 
 		var fa = t * s01; // scaling factor for triangle Ta
 		var fb = t * s12;
 
 		return {
 			previous: {
 				x: current.x - fa * (next.x - previous.x),
 				y: current.y - fa * (next.y - previous.y)
 			},
 			next: {
 				x: current.x + fb * (next.x - previous.x),
 				y: current.y + fb * (next.y - previous.y)
 			}
 		};
 	};
 	helpers.EPSILON = Number.EPSILON || 1e-14;
 	helpers.splineCurveMonotone = function(points) {
 		// This function calculates Bzier control points in a similar way than |splineCurve|,
 		// but preserves monotonicity of the provided data and ensures no local extremums are added
 		// between the dataset discrete points due to the interpolation.
 		// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 
 		var pointsWithTangents = (points || []).map(function(point) {
 			return {
 				model: point._model,
 				deltaK: 0,
 				mK: 0
 			};
 		});
 
 		// Calculate slopes (deltaK) and initialize tangents (mK)
 		var pointsLen = pointsWithTangents.length;
 		var i, pointBefore, pointCurrent, pointAfter;
 		for (i = 0; i < pointsLen; ++i) {
 			pointCurrent = pointsWithTangents[i];
 			if (pointCurrent.model.skip) {
 				continue;
 			}
 
 			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
 			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
 			if (pointAfter && !pointAfter.model.skip) {
 				var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);
 
 				// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
 				pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
 			}
 
 			if (!pointBefore || pointBefore.model.skip) {
 				pointCurrent.mK = pointCurrent.deltaK;
 			} else if (!pointAfter || pointAfter.model.skip) {
 				pointCurrent.mK = pointBefore.deltaK;
 			} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
 				pointCurrent.mK = 0;
 			} else {
 				pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
 			}
 		}
 
 		// Adjust tangents to ensure monotonic properties
 		var alphaK, betaK, tauK, squaredMagnitude;
 		for (i = 0; i < pointsLen - 1; ++i) {
 			pointCurrent = pointsWithTangents[i];
 			pointAfter = pointsWithTangents[i + 1];
 			if (pointCurrent.model.skip || pointAfter.model.skip) {
 				continue;
 			}
 
 			if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
 				pointCurrent.mK = pointAfter.mK = 0;
 				continue;
 			}
 
 			alphaK = pointCurrent.mK / pointCurrent.deltaK;
 			betaK = pointAfter.mK / pointCurrent.deltaK;
 			squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
 			if (squaredMagnitude <= 9) {
 				continue;
 			}
 
 			tauK = 3 / Math.sqrt(squaredMagnitude);
 			pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
 			pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
 		}
 
 		// Compute control points
 		var deltaX;
 		for (i = 0; i < pointsLen; ++i) {
 			pointCurrent = pointsWithTangents[i];
 			if (pointCurrent.model.skip) {
 				continue;
 			}
 
 			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
 			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
 			if (pointBefore && !pointBefore.model.skip) {
 				deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
 				pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
 				pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
 			}
 			if (pointAfter && !pointAfter.model.skip) {
 				deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
 				pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
 				pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
 			}
 		}
 	};
 	helpers.nextItem = function(collection, index, loop) {
 		if (loop) {
 			return index >= collection.length - 1 ? collection[0] : collection[index + 1];
 		}
 		return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
 	};
 	helpers.previousItem = function(collection, index, loop) {
 		if (loop) {
 			return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
 		}
 		return index <= 0 ? collection[0] : collection[index - 1];
 	};
 	// Implementation of the nice number algorithm used in determining where axis labels will go
 	helpers.niceNum = function(range, round) {
 		var exponent = Math.floor(helpers.log10(range));
 		var fraction = range / Math.pow(10, exponent);
 		var niceFraction;
 
 		if (round) {
 			if (fraction < 1.5) {
 				niceFraction = 1;
 			} else if (fraction < 3) {
 				niceFraction = 2;
 			} else if (fraction < 7) {
 				niceFraction = 5;
 			} else {
 				niceFraction = 10;
 			}
 		} else if (fraction <= 1.0) {
 			niceFraction = 1;
 		} else if (fraction <= 2) {
 			niceFraction = 2;
 		} else if (fraction <= 5) {
 			niceFraction = 5;
 		} else {
 			niceFraction = 10;
 		}
 
 		return niceFraction * Math.pow(10, exponent);
 	};
 	// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
 	helpers.requestAnimFrame = (function() {
 		if (typeof window === 'undefined') {
 			return function(callback) {
 				callback();
 			};
 		}
 		return window.requestAnimationFrame ||
 			window.webkitRequestAnimationFrame ||
 			window.mozRequestAnimationFrame ||
 			window.oRequestAnimationFrame ||
 			window.msRequestAnimationFrame ||
 			function(callback) {
 				return window.setTimeout(callback, 1000 / 60);
 			};
 	}());
 	// -- DOM methods
 	helpers.getRelativePosition = function(evt, chart) {
 		var mouseX, mouseY;
 		var e = evt.originalEvent || evt;
 		var canvas = evt.currentTarget || evt.srcElement;
 		var boundingRect = canvas.getBoundingClientRect();
 
 		var touches = e.touches;
 		if (touches && touches.length > 0) {
 			mouseX = touches[0].clientX;
 			mouseY = touches[0].clientY;
 
 		} else {
 			mouseX = e.clientX;
 			mouseY = e.clientY;
 		}
 
 		// Scale mouse coordinates into canvas coordinates
 		// by following the pattern laid out by 'jerryj' in the comments of
 		// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
 		var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
 		var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
 		var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
 		var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
 		var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
 		var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
 
 		// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
 		// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
 		mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
 		mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);
 
 		return {
 			x: mouseX,
 			y: mouseY
 		};
 
 	};
 
 	// Private helper function to convert max-width/max-height values that may be percentages into a number
 	function parseMaxStyle(styleValue, node, parentProperty) {
 		var valueInPixels;
 		if (typeof styleValue === 'string') {
 			valueInPixels = parseInt(styleValue, 10);
 
 			if (styleValue.indexOf('%') !== -1) {
 				// percentage * size in dimension
 				valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
 			}
 		} else {
 			valueInPixels = styleValue;
 		}
 
 		return valueInPixels;
 	}
 
 	/**
 	 * Returns if the given value contains an effective constraint.
 	 * @private
 	 */
 	function isConstrainedValue(value) {
 		return value !== undefined && value !== null && value !== 'none';
 	}
 
 	// Private helper to get a constraint dimension
 	// @param domNode : the node to check the constraint on
 	// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
 	// @param percentageProperty : property of parent to use when calculating width as a percentage
 	// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
 	function getConstraintDimension(domNode, maxStyle, percentageProperty) {
 		var view = document.defaultView;
 		var parentNode = domNode.parentNode;
 		var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
 		var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
 		var hasCNode = isConstrainedValue(constrainedNode);
 		var hasCContainer = isConstrainedValue(constrainedContainer);
 		var infinity = Number.POSITIVE_INFINITY;
 
 		if (hasCNode || hasCContainer) {
 			return Math.min(
 				hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
 				hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
 		}
 
 		return 'none';
 	}
 	// returns Number or undefined if no constraint
 	helpers.getConstraintWidth = function(domNode) {
 		return getConstraintDimension(domNode, 'max-width', 'clientWidth');
 	};
 	// returns Number or undefined if no constraint
 	helpers.getConstraintHeight = function(domNode) {
 		return getConstraintDimension(domNode, 'max-height', 'clientHeight');
 	};
 	helpers.getMaximumWidth = function(domNode) {
 		var container = domNode.parentNode;
 		if (!container) {
 			return domNode.clientWidth;
 		}
 
 		var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
 		var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
 		var w = container.clientWidth - paddingLeft - paddingRight;
 		var cw = helpers.getConstraintWidth(domNode);
 		return isNaN(cw) ? w : Math.min(w, cw);
 	};
 	helpers.getMaximumHeight = function(domNode) {
 		var container = domNode.parentNode;
 		if (!container) {
 			return domNode.clientHeight;
 		}
 
 		var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
 		var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
 		var h = container.clientHeight - paddingTop - paddingBottom;
 		var ch = helpers.getConstraintHeight(domNode);
 		return isNaN(ch) ? h : Math.min(h, ch);
 	};
 	helpers.getStyle = function(el, property) {
 		return el.currentStyle ?
 			el.currentStyle[property] :
 			document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
 	};
 	helpers.retinaScale = function(chart, forceRatio) {
 		var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
 		if (pixelRatio === 1) {
 			return;
 		}
 
 		var canvas = chart.canvas;
 		var height = chart.height;
 		var width = chart.width;
 
 		canvas.height = height * pixelRatio;
 		canvas.width = width * pixelRatio;
 		chart.ctx.scale(pixelRatio, pixelRatio);
 
 		// If no style has been set on the canvas, the render size is used as display size,
 		// making the chart visually bigger, so let's enforce it to the "correct" values.
 		// See https://github.com/chartjs/Chart.js/issues/3575
 		if (!canvas.style.height && !canvas.style.width) {
 			canvas.style.height = height + 'px';
 			canvas.style.width = width + 'px';
 		}
 	};
 	// -- Canvas methods
 	helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
 		return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
 	};
 	helpers.longestText = function(ctx, font, arrayOfThings, cache) {
 		cache = cache || {};
 		var data = cache.data = cache.data || {};
 		var gc = cache.garbageCollect = cache.garbageCollect || [];
 
 		if (cache.font !== font) {
 			data = cache.data = {};
 			gc = cache.garbageCollect = [];
 			cache.font = font;
 		}
 
 		ctx.font = font;
 		var longest = 0;
 		helpers.each(arrayOfThings, function(thing) {
 			// Undefined strings and arrays should not be measured
 			if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
 				longest = helpers.measureText(ctx, data, gc, longest, thing);
 			} else if (helpers.isArray(thing)) {
 				// if it is an array lets measure each element
 				// to do maybe simplify this function a bit so we can do this more recursively?
 				helpers.each(thing, function(nestedThing) {
 					// Undefined strings and arrays should not be measured
 					if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
 						longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
 					}
 				});
 			}
 		});
 
 		var gcLen = gc.length / 2;
 		if (gcLen > arrayOfThings.length) {
 			for (var i = 0; i < gcLen; i++) {
 				delete data[gc[i]];
 			}
 			gc.splice(0, gcLen);
 		}
 		return longest;
 	};
 	helpers.measureText = function(ctx, data, gc, longest, string) {
 		var textWidth = data[string];
 		if (!textWidth) {
 			textWidth = data[string] = ctx.measureText(string).width;
 			gc.push(string);
 		}
 		if (textWidth > longest) {
 			longest = textWidth;
 		}
 		return longest;
 	};
 	helpers.numberOfLabelLines = function(arrayOfThings) {
 		var numberOfLines = 1;
 		helpers.each(arrayOfThings, function(thing) {
 			if (helpers.isArray(thing)) {
 				if (thing.length > numberOfLines) {
 					numberOfLines = thing.length;
 				}
 			}
 		});
 		return numberOfLines;
 	};
 
 	helpers.color = !color ?
 		function(value) {
 			console.error('Color.js not found!');
 			return value;
 		} :
 		function(value) {
 			/* global CanvasGradient */
 			if (value instanceof CanvasGradient) {
 				value = defaults.global.defaultColor;
 			}
 
 			return color(value);
 		};
 
 	helpers.getHoverColor = function(colorValue) {
 		/* global CanvasPattern */
 		return (colorValue instanceof CanvasPattern) ?
 			colorValue :
 			helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
 	};
 };
 
 },{"25":25,"3":3,"45":45}],28:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 
 /**
  * Helper function to get relative position for an event
  * @param {Event|IEvent} event - The event to get the position for
  * @param {Chart} chart - The chart
  * @returns {Point} the event position
  */
 function getRelativePosition(e, chart) {
 	if (e.native) {
 		return {
 			x: e.x,
 			y: e.y
 		};
 	}
 
 	return helpers.getRelativePosition(e, chart);
 }
 
 /**
  * Helper function to traverse all of the visible elements in the chart
  * @param chart {chart} the chart
  * @param handler {Function} the callback to execute for each visible item
  */
 function parseVisibleItems(chart, handler) {
 	var datasets = chart.data.datasets;
 	var meta, i, j, ilen, jlen;
 
 	for (i = 0, ilen = datasets.length; i < ilen; ++i) {
 		if (!chart.isDatasetVisible(i)) {
 			continue;
 		}
 
 		meta = chart.getDatasetMeta(i);
 		for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
 			var element = meta.data[j];
 			if (!element._view.skip) {
 				handler(element);
 			}
 		}
 	}
 }
 
 /**
  * Helper function to get the items that intersect the event position
  * @param items {ChartElement[]} elements to filter
  * @param position {Point} the point to be nearest to
  * @return {ChartElement[]} the nearest items
  */
 function getIntersectItems(chart, position) {
 	var elements = [];
 
 	parseVisibleItems(chart, function(element) {
 		if (element.inRange(position.x, position.y)) {
 			elements.push(element);
 		}
 	});
 
 	return elements;
 }
 
 /**
  * Helper function to get the items nearest to the event position considering all visible items in teh chart
  * @param chart {Chart} the chart to look at elements from
  * @param position {Point} the point to be nearest to
  * @param intersect {Boolean} if true, only consider items that intersect the position
  * @param distanceMetric {Function} function to provide the distance between points
  * @return {ChartElement[]} the nearest items
  */
 function getNearestItems(chart, position, intersect, distanceMetric) {
 	var minDistance = Number.POSITIVE_INFINITY;
 	var nearestItems = [];
 
 	parseVisibleItems(chart, function(element) {
 		if (intersect && !element.inRange(position.x, position.y)) {
 			return;
 		}
 
 		var center = element.getCenterPoint();
 		var distance = distanceMetric(position, center);
 
 		if (distance < minDistance) {
 			nearestItems = [element];
 			minDistance = distance;
 		} else if (distance === minDistance) {
 			// Can have multiple items at the same distance in which case we sort by size
 			nearestItems.push(element);
 		}
 	});
 
 	return nearestItems;
 }
 
 /**
  * Get a distance metric function for two points based on the
  * axis mode setting
  * @param {String} axis the axis mode. x|y|xy
  */
 function getDistanceMetricForAxis(axis) {
 	var useX = axis.indexOf('x') !== -1;
 	var useY = axis.indexOf('y') !== -1;
 
 	return function(pt1, pt2) {
 		var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
 		var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
 		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
 	};
 }
 
 function indexMode(chart, e, options) {
 	var position = getRelativePosition(e, chart);
 	// Default axis for index mode is 'x' to match old behaviour
 	options.axis = options.axis || 'x';
 	var distanceMetric = getDistanceMetricForAxis(options.axis);
 	var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
 	var elements = [];
 
 	if (!items.length) {
 		return [];
 	}
 
 	chart.data.datasets.forEach(function(dataset, datasetIndex) {
 		if (chart.isDatasetVisible(datasetIndex)) {
 			var meta = chart.getDatasetMeta(datasetIndex);
 			var element = meta.data[items[0]._index];
 
 			// don't count items that are skipped (null data)
 			if (element && !element._view.skip) {
 				elements.push(element);
 			}
 		}
 	});
 
 	return elements;
 }
 
 /**
  * @interface IInteractionOptions
  */
 /**
  * If true, only consider items that intersect the point
  * @name IInterfaceOptions#boolean
  * @type Boolean
  */
 
 /**
  * Contains interaction related functions
  * @namespace Chart.Interaction
  */
 module.exports = {
 	// Helper function for different modes
 	modes: {
 		single: function(chart, e) {
 			var position = getRelativePosition(e, chart);
 			var elements = [];
 
 			parseVisibleItems(chart, function(element) {
 				if (element.inRange(position.x, position.y)) {
 					elements.push(element);
 					return elements;
 				}
 			});
 
 			return elements.slice(0, 1);
 		},
 
 		/**
 		 * @function Chart.Interaction.modes.label
 		 * @deprecated since version 2.4.0
 		 * @todo remove at version 3
 		 * @private
 		 */
 		label: indexMode,
 
 		/**
 		 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
 		 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
 		 * @function Chart.Interaction.modes.index
 		 * @since v2.4.0
 		 * @param chart {chart} the chart we are returning items from
 		 * @param e {Event} the event we are find things at
 		 * @param options {IInteractionOptions} options to use during interaction
 		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
 		 */
 		index: indexMode,
 
 		/**
 		 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
 		 * If the options.intersect is false, we find the nearest item and return the items in that dataset
 		 * @function Chart.Interaction.modes.dataset
 		 * @param chart {chart} the chart we are returning items from
 		 * @param e {Event} the event we are find things at
 		 * @param options {IInteractionOptions} options to use during interaction
 		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
 		 */
 		dataset: function(chart, e, options) {
 			var position = getRelativePosition(e, chart);
 			options.axis = options.axis || 'xy';
 			var distanceMetric = getDistanceMetricForAxis(options.axis);
 			var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
 
 			if (items.length > 0) {
 				items = chart.getDatasetMeta(items[0]._datasetIndex).data;
 			}
 
 			return items;
 		},
 
 		/**
 		 * @function Chart.Interaction.modes.x-axis
 		 * @deprecated since version 2.4.0. Use index mode and intersect == true
 		 * @todo remove at version 3
 		 * @private
 		 */
 		'x-axis': function(chart, e) {
 			return indexMode(chart, e, {intersect: false});
 		},
 
 		/**
 		 * Point mode returns all elements that hit test based on the event position
 		 * of the event
 		 * @function Chart.Interaction.modes.intersect
 		 * @param chart {chart} the chart we are returning items from
 		 * @param e {Event} the event we are find things at
 		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
 		 */
 		point: function(chart, e) {
 			var position = getRelativePosition(e, chart);
 			return getIntersectItems(chart, position);
 		},
 
 		/**
 		 * nearest mode returns the element closest to the point
 		 * @function Chart.Interaction.modes.intersect
 		 * @param chart {chart} the chart we are returning items from
 		 * @param e {Event} the event we are find things at
 		 * @param options {IInteractionOptions} options to use
 		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
 		 */
 		nearest: function(chart, e, options) {
 			var position = getRelativePosition(e, chart);
 			options.axis = options.axis || 'xy';
 			var distanceMetric = getDistanceMetricForAxis(options.axis);
 			var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);
 
 			// We have multiple items at the same distance from the event. Now sort by smallest
 			if (nearestItems.length > 1) {
 				nearestItems.sort(function(a, b) {
 					var sizeA = a.getArea();
 					var sizeB = b.getArea();
 					var ret = sizeA - sizeB;
 
 					if (ret === 0) {
 						// if equal sort by dataset index
 						ret = a._datasetIndex - b._datasetIndex;
 					}
 
 					return ret;
 				});
 			}
 
 			// Return only 1 item
 			return nearestItems.slice(0, 1);
 		},
 
 		/**
 		 * x mode returns the elements that hit-test at the current x coordinate
 		 * @function Chart.Interaction.modes.x
 		 * @param chart {chart} the chart we are returning items from
 		 * @param e {Event} the event we are find things at
 		 * @param options {IInteractionOptions} options to use
 		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
 		 */
 		x: function(chart, e, options) {
 			var position = getRelativePosition(e, chart);
 			var items = [];
 			var intersectsItem = false;
 
 			parseVisibleItems(chart, function(element) {
 				if (element.inXRange(position.x)) {
 					items.push(element);
 				}
 
 				if (element.inRange(position.x, position.y)) {
 					intersectsItem = true;
 				}
 			});
 
 			// If we want to trigger on an intersect and we don't have any items
 			// that intersect the position, return nothing
 			if (options.intersect && !intersectsItem) {
 				items = [];
 			}
 			return items;
 		},
 
 		/**
 		 * y mode returns the elements that hit-test at the current y coordinate
 		 * @function Chart.Interaction.modes.y
 		 * @param chart {chart} the chart we are returning items from
 		 * @param e {Event} the event we are find things at
 		 * @param options {IInteractionOptions} options to use
 		 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
 		 */
 		y: function(chart, e, options) {
 			var position = getRelativePosition(e, chart);
 			var items = [];
 			var intersectsItem = false;
 
 			parseVisibleItems(chart, function(element) {
 				if (element.inYRange(position.y)) {
 					items.push(element);
 				}
 
 				if (element.inRange(position.x, position.y)) {
 					intersectsItem = true;
 				}
 			});
 
 			// If we want to trigger on an intersect and we don't have any items
 			// that intersect the position, return nothing
 			if (options.intersect && !intersectsItem) {
 				items = [];
 			}
 			return items;
 		}
 	}
 };
 
 },{"45":45}],29:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 
 defaults._set('global', {
 	responsive: true,
 	responsiveAnimationDuration: 0,
 	maintainAspectRatio: true,
 	events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
 	hover: {
 		onHover: null,
 		mode: 'nearest',
 		intersect: true,
 		animationDuration: 400
 	},
 	onClick: null,
 	defaultColor: 'rgba(0,0,0,0.1)',
 	defaultFontColor: '#666',
 	defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
 	defaultFontSize: 12,
 	defaultFontStyle: 'normal',
 	showLines: true,
 
 	// Element defaults defined in element extensions
 	elements: {},
 
 	// Layout options such as padding
 	layout: {
 		padding: {
 			top: 0,
 			right: 0,
 			bottom: 0,
 			left: 0
 		}
 	}
 });
 
 module.exports = function() {
 
 	// Occupy the global variable of Chart, and create a simple base class
 	var Chart = function(item, config) {
 		this.construct(item, config);
 		return this;
 	};
 
 	Chart.Chart = Chart;
 
 	return Chart;
 };
 
 },{"25":25}],30:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 
 function filterByPosition(array, position) {
 	return helpers.where(array, function(v) {
 		return v.position === position;
 	});
 }
 
 function sortByWeight(array, reverse) {
 	array.forEach(function(v, i) {
 		v._tmpIndex_ = i;
 		return v;
 	});
 	array.sort(function(a, b) {
 		var v0 = reverse ? b : a;
 		var v1 = reverse ? a : b;
 		return v0.weight === v1.weight ?
 			v0._tmpIndex_ - v1._tmpIndex_ :
 			v0.weight - v1.weight;
 	});
 	array.forEach(function(v) {
 		delete v._tmpIndex_;
 	});
 }
 
 /**
  * @interface ILayoutItem
  * @prop {String} position - The position of the item in the chart layout. Possible values are
  * 'left', 'top', 'right', 'bottom', and 'chartArea'
  * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
  * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
  * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
  * @prop {Function} update - Takes two parameters: width and height. Returns size of item
  * @prop {Function} getPadding -  Returns an object with padding on the edges
  * @prop {Number} width - Width of item. Must be valid after update()
  * @prop {Number} height - Height of item. Must be valid after update()
  * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
  * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
  * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
  * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
  */
 
 // The layout service is very self explanatory.  It's responsible for the layout within a chart.
 // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
 // It is this service's responsibility of carrying out that layout.
 module.exports = {
 	defaults: {},
 
 	/**
 	 * Register a box to a chart.
 	 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
 	 * @param {Chart} chart - the chart to use
 	 * @param {ILayoutItem} item - the item to add to be layed out
 	 */
 	addBox: function(chart, item) {
 		if (!chart.boxes) {
 			chart.boxes = [];
 		}
 
 		// initialize item with default values
 		item.fullWidth = item.fullWidth || false;
 		item.position = item.position || 'top';
 		item.weight = item.weight || 0;
 
 		chart.boxes.push(item);
 	},
 
 	/**
 	 * Remove a layoutItem from a chart
 	 * @param {Chart} chart - the chart to remove the box from
 	 * @param {Object} layoutItem - the item to remove from the layout
 	 */
 	removeBox: function(chart, layoutItem) {
 		var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
 		if (index !== -1) {
 			chart.boxes.splice(index, 1);
 		}
 	},
 
 	/**
 	 * Sets (or updates) options on the given `item`.
 	 * @param {Chart} chart - the chart in which the item lives (or will be added to)
 	 * @param {Object} item - the item to configure with the given options
 	 * @param {Object} options - the new item options.
 	 */
 	configure: function(chart, item, options) {
 		var props = ['fullWidth', 'position', 'weight'];
 		var ilen = props.length;
 		var i = 0;
 		var prop;
 
 		for (; i < ilen; ++i) {
 			prop = props[i];
 			if (options.hasOwnProperty(prop)) {
 				item[prop] = options[prop];
 			}
 		}
 	},
 
 	/**
 	 * Fits boxes of the given chart into the given size by having each box measure itself
 	 * then running a fitting algorithm
 	 * @param {Chart} chart - the chart
 	 * @param {Number} width - the width to fit into
 	 * @param {Number} height - the height to fit into
 	 */
 	update: function(chart, width, height) {
 		if (!chart) {
 			return;
 		}
 
 		var layoutOptions = chart.options.layout || {};
 		var padding = helpers.options.toPadding(layoutOptions.padding);
 		var leftPadding = padding.left;
 		var rightPadding = padding.right;
 		var topPadding = padding.top;
 		var bottomPadding = padding.bottom;
 
 		var leftBoxes = filterByPosition(chart.boxes, 'left');
 		var rightBoxes = filterByPosition(chart.boxes, 'right');
 		var topBoxes = filterByPosition(chart.boxes, 'top');
 		var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
 		var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');
 
 		// Sort boxes by weight. A higher weight is further away from the chart area
 		sortByWeight(leftBoxes, true);
 		sortByWeight(rightBoxes, false);
 		sortByWeight(topBoxes, true);
 		sortByWeight(bottomBoxes, false);
 
 		// Essentially we now have any number of boxes on each of the 4 sides.
 		// Our canvas looks like the following.
 		// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
 		// B1 is the bottom axis
 		// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
 		// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
 		// an error will be thrown.
 		//
 		// |----------------------------------------------------|
 		// |                  T1 (Full Width)                   |
 		// |----------------------------------------------------|
 		// |    |    |                 T2                  |    |
 		// |    |----|-------------------------------------|----|
 		// |    |    | C1 |                           | C2 |    |
 		// |    |    |----|                           |----|    |
 		// |    |    |                                     |    |
 		// | L1 | L2 |           ChartArea (C0)            | R1 |
 		// |    |    |                                     |    |
 		// |    |    |----|                           |----|    |
 		// |    |    | C3 |                           | C4 |    |
 		// |    |----|-------------------------------------|----|
 		// |    |    |                 B1                  |    |
 		// |----------------------------------------------------|
 		// |                  B2 (Full Width)                   |
 		// |----------------------------------------------------|
 		//
 		// What we do to find the best sizing, we do the following
 		// 1. Determine the minimum size of the chart area.
 		// 2. Split the remaining width equally between each vertical axis
 		// 3. Split the remaining height equally between each horizontal axis
 		// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
 		// 5. Adjust the sizes of each axis based on it's minimum reported size.
 		// 6. Refit each axis
 		// 7. Position each axis in the final location
 		// 8. Tell the chart the final location of the chart area
 		// 9. Tell any axes that overlay the chart area the positions of the chart area
 
 		// Step 1
 		var chartWidth = width - leftPadding - rightPadding;
 		var chartHeight = height - topPadding - bottomPadding;
 		var chartAreaWidth = chartWidth / 2; // min 50%
 		var chartAreaHeight = chartHeight / 2; // min 50%
 
 		// Step 2
 		var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
 
 		// Step 3
 		var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
 
 		// Step 4
 		var maxChartAreaWidth = chartWidth;
 		var maxChartAreaHeight = chartHeight;
 		var minBoxSizes = [];
 
 		function getMinimumBoxSize(box) {
 			var minSize;
 			var isHorizontal = box.isHorizontal();
 
 			if (isHorizontal) {
 				minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
 				maxChartAreaHeight -= minSize.height;
 			} else {
 				minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
 				maxChartAreaWidth -= minSize.width;
 			}
 
 			minBoxSizes.push({
 				horizontal: isHorizontal,
 				minSize: minSize,
 				box: box,
 			});
 		}
 
 		helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
 
 		// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
 		var maxHorizontalLeftPadding = 0;
 		var maxHorizontalRightPadding = 0;
 		var maxVerticalTopPadding = 0;
 		var maxVerticalBottomPadding = 0;
 
 		helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
 			if (horizontalBox.getPadding) {
 				var boxPadding = horizontalBox.getPadding();
 				maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
 				maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
 			}
 		});
 
 		helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
 			if (verticalBox.getPadding) {
 				var boxPadding = verticalBox.getPadding();
 				maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
 				maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
 			}
 		});
 
 		// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
 		// be if the axes are drawn at their minimum sizes.
 		// Steps 5 & 6
 		var totalLeftBoxesWidth = leftPadding;
 		var totalRightBoxesWidth = rightPadding;
 		var totalTopBoxesHeight = topPadding;
 		var totalBottomBoxesHeight = bottomPadding;
 
 		// Function to fit a box
 		function fitBox(box) {
 			var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
 				return minBox.box === box;
 			});
 
 			if (minBoxSize) {
 				if (box.isHorizontal()) {
 					var scaleMargin = {
 						left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
 						right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
 						top: 0,
 						bottom: 0
 					};
 
 					// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
 					// on the margin. Sometimes they need to increase in size slightly
 					box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
 				} else {
 					box.update(minBoxSize.minSize.width, maxChartAreaHeight);
 				}
 			}
 		}
 
 		// Update, and calculate the left and right margins for the horizontal boxes
 		helpers.each(leftBoxes.concat(rightBoxes), fitBox);
 
 		helpers.each(leftBoxes, function(box) {
 			totalLeftBoxesWidth += box.width;
 		});
 
 		helpers.each(rightBoxes, function(box) {
 			totalRightBoxesWidth += box.width;
 		});
 
 		// Set the Left and Right margins for the horizontal boxes
 		helpers.each(topBoxes.concat(bottomBoxes), fitBox);
 
 		// Figure out how much margin is on the top and bottom of the vertical boxes
 		helpers.each(topBoxes, function(box) {
 			totalTopBoxesHeight += box.height;
 		});
 
 		helpers.each(bottomBoxes, function(box) {
 			totalBottomBoxesHeight += box.height;
 		});
 
 		function finalFitVerticalBox(box) {
 			var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
 				return minSize.box === box;
 			});
 
 			var scaleMargin = {
 				left: 0,
 				right: 0,
 				top: totalTopBoxesHeight,
 				bottom: totalBottomBoxesHeight
 			};
 
 			if (minBoxSize) {
 				box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
 			}
 		}
 
 		// Let the left layout know the final margin
 		helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
 
 		// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
 		totalLeftBoxesWidth = leftPadding;
 		totalRightBoxesWidth = rightPadding;
 		totalTopBoxesHeight = topPadding;
 		totalBottomBoxesHeight = bottomPadding;
 
 		helpers.each(leftBoxes, function(box) {
 			totalLeftBoxesWidth += box.width;
 		});
 
 		helpers.each(rightBoxes, function(box) {
 			totalRightBoxesWidth += box.width;
 		});
 
 		helpers.each(topBoxes, function(box) {
 			totalTopBoxesHeight += box.height;
 		});
 		helpers.each(bottomBoxes, function(box) {
 			totalBottomBoxesHeight += box.height;
 		});
 
 		// We may be adding some padding to account for rotated x axis labels
 		var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
 		totalLeftBoxesWidth += leftPaddingAddition;
 		totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
 
 		var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
 		totalTopBoxesHeight += topPaddingAddition;
 		totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);
 
 		// Figure out if our chart area changed. This would occur if the dataset layout label rotation
 		// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
 		// without calling `fit` again
 		var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
 		var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
 
 		if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
 			helpers.each(leftBoxes, function(box) {
 				box.height = newMaxChartAreaHeight;
 			});
 
 			helpers.each(rightBoxes, function(box) {
 				box.height = newMaxChartAreaHeight;
 			});
 
 			helpers.each(topBoxes, function(box) {
 				if (!box.fullWidth) {
 					box.width = newMaxChartAreaWidth;
 				}
 			});
 
 			helpers.each(bottomBoxes, function(box) {
 				if (!box.fullWidth) {
 					box.width = newMaxChartAreaWidth;
 				}
 			});
 
 			maxChartAreaHeight = newMaxChartAreaHeight;
 			maxChartAreaWidth = newMaxChartAreaWidth;
 		}
 
 		// Step 7 - Position the boxes
 		var left = leftPadding + leftPaddingAddition;
 		var top = topPadding + topPaddingAddition;
 
 		function placeBox(box) {
 			if (box.isHorizontal()) {
 				box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
 				box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
 				box.top = top;
 				box.bottom = top + box.height;
 
 				// Move to next point
 				top = box.bottom;
 
 			} else {
 
 				box.left = left;
 				box.right = left + box.width;
 				box.top = totalTopBoxesHeight;
 				box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
 
 				// Move to next point
 				left = box.right;
 			}
 		}
 
 		helpers.each(leftBoxes.concat(topBoxes), placeBox);
 
 		// Account for chart width and height
 		left += maxChartAreaWidth;
 		top += maxChartAreaHeight;
 
 		helpers.each(rightBoxes, placeBox);
 		helpers.each(bottomBoxes, placeBox);
 
 		// Step 8
 		chart.chartArea = {
 			left: totalLeftBoxesWidth,
 			top: totalTopBoxesHeight,
 			right: totalLeftBoxesWidth + maxChartAreaWidth,
 			bottom: totalTopBoxesHeight + maxChartAreaHeight
 		};
 
 		// Step 9
 		helpers.each(chartAreaBoxes, function(box) {
 			box.left = chart.chartArea.left;
 			box.top = chart.chartArea.top;
 			box.right = chart.chartArea.right;
 			box.bottom = chart.chartArea.bottom;
 
 			box.update(maxChartAreaWidth, maxChartAreaHeight);
 		});
 	}
 };
 
 },{"45":45}],31:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var helpers = require(45);
 
 defaults._set('global', {
 	plugins: {}
 });
 
 /**
  * The plugin service singleton
  * @namespace Chart.plugins
  * @since 2.1.0
  */
 module.exports = {
 	/**
 	 * Globally registered plugins.
 	 * @private
 	 */
 	_plugins: [],
 
 	/**
 	 * This identifier is used to invalidate the descriptors cache attached to each chart
 	 * when a global plugin is registered or unregistered. In this case, the cache ID is
 	 * incremented and descriptors are regenerated during following API calls.
 	 * @private
 	 */
 	_cacheId: 0,
 
 	/**
 	 * Registers the given plugin(s) if not already registered.
 	 * @param {Array|Object} plugins plugin instance(s).
 	 */
 	register: function(plugins) {
 		var p = this._plugins;
 		([]).concat(plugins).forEach(function(plugin) {
 			if (p.indexOf(plugin) === -1) {
 				p.push(plugin);
 			}
 		});
 
 		this._cacheId++;
 	},
 
 	/**
 	 * Unregisters the given plugin(s) only if registered.
 	 * @param {Array|Object} plugins plugin instance(s).
 	 */
 	unregister: function(plugins) {
 		var p = this._plugins;
 		([]).concat(plugins).forEach(function(plugin) {
 			var idx = p.indexOf(plugin);
 			if (idx !== -1) {
 				p.splice(idx, 1);
 			}
 		});
 
 		this._cacheId++;
 	},
 
 	/**
 	 * Remove all registered plugins.
 	 * @since 2.1.5
 	 */
 	clear: function() {
 		this._plugins = [];
 		this._cacheId++;
 	},
 
 	/**
 	 * Returns the number of registered plugins?
 	 * @returns {Number}
 	 * @since 2.1.5
 	 */
 	count: function() {
 		return this._plugins.length;
 	},
 
 	/**
 	 * Returns all registered plugin instances.
 	 * @returns {Array} array of plugin objects.
 	 * @since 2.1.5
 	 */
 	getAll: function() {
 		return this._plugins;
 	},
 
 	/**
 	 * Calls enabled plugins for `chart` on the specified hook and with the given args.
 	 * This method immediately returns as soon as a plugin explicitly returns false. The
 	 * returned value can be used, for instance, to interrupt the current action.
 	 * @param {Object} chart - The chart instance for which plugins should be called.
 	 * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
 	 * @param {Array} [args] - Extra arguments to apply to the hook call.
 	 * @returns {Boolean} false if any of the plugins return false, else returns true.
 	 */
 	notify: function(chart, hook, args) {
 		var descriptors = this.descriptors(chart);
 		var ilen = descriptors.length;
 		var i, descriptor, plugin, params, method;
 
 		for (i = 0; i < ilen; ++i) {
 			descriptor = descriptors[i];
 			plugin = descriptor.plugin;
 			method = plugin[hook];
 			if (typeof method === 'function') {
 				params = [chart].concat(args || []);
 				params.push(descriptor.options);
 				if (method.apply(plugin, params) === false) {
 					return false;
 				}
 			}
 		}
 
 		return true;
 	},
 
 	/**
 	 * Returns descriptors of enabled plugins for the given chart.
 	 * @returns {Array} [{ plugin, options }]
 	 * @private
 	 */
 	descriptors: function(chart) {
 		var cache = chart.$plugins || (chart.$plugins = {});
 		if (cache.id === this._cacheId) {
 			return cache.descriptors;
 		}
 
 		var plugins = [];
 		var descriptors = [];
 		var config = (chart && chart.config) || {};
 		var options = (config.options && config.options.plugins) || {};
 
 		this._plugins.concat(config.plugins || []).forEach(function(plugin) {
 			var idx = plugins.indexOf(plugin);
 			if (idx !== -1) {
 				return;
 			}
 
 			var id = plugin.id;
 			var opts = options[id];
 			if (opts === false) {
 				return;
 			}
 
 			if (opts === true) {
 				opts = helpers.clone(defaults.global.plugins[id]);
 			}
 
 			plugins.push(plugin);
 			descriptors.push({
 				plugin: plugin,
 				options: opts || {}
 			});
 		});
 
 		cache.descriptors = descriptors;
 		cache.id = this._cacheId;
 		return descriptors;
 	},
 
 	/**
 	 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
 	 * but in some cases, this reference can be changed by the user when updating options.
 	 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
 	 * @private
 	 */
 	_invalidate: function(chart) {
 		delete chart.$plugins;
 	}
 };
 
 /**
  * Plugin extension hooks.
  * @interface IPlugin
  * @since 2.1.0
  */
 /**
  * @method IPlugin#beforeInit
  * @desc Called before initializing `chart`.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#afterInit
  * @desc Called after `chart` has been initialized and before the first update.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeUpdate
  * @desc Called before updating `chart`. If any plugin returns `false`, the update
  * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart update.
  */
 /**
  * @method IPlugin#afterUpdate
  * @desc Called after `chart` has been updated and before rendering. Note that this
  * hook will not be called if the chart update has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeDatasetsUpdate
  * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
  * the datasets update is cancelled until another `update` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} false to cancel the datasets update.
  * @since version 2.1.5
 */
 /**
  * @method IPlugin#afterDatasetsUpdate
  * @desc Called after the `chart` datasets have been updated. Note that this hook
  * will not be called if the datasets update has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @since version 2.1.5
  */
 /**
  * @method IPlugin#beforeDatasetUpdate
  * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
  * returns `false`, the datasets update is cancelled until another `update` is triggered.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart datasets drawing.
  */
 /**
  * @method IPlugin#afterDatasetUpdate
  * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
  * that this hook will not be called if the datasets update has been previously cancelled.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeLayout
  * @desc Called before laying out `chart`. If any plugin returns `false`,
  * the layout update is cancelled until another `update` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart layout.
  */
 /**
  * @method IPlugin#afterLayout
  * @desc Called after the `chart` has been layed out. Note that this hook will not
  * be called if the layout update has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeRender
  * @desc Called before rendering `chart`. If any plugin returns `false`,
  * the rendering is cancelled until another `render` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart rendering.
  */
 /**
  * @method IPlugin#afterRender
  * @desc Called after the `chart` has been fully rendered (and animation completed). Note
  * that this hook will not be called if the rendering has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeDraw
  * @desc Called before drawing `chart` at every animation frame specified by the given
  * easing value. If any plugin returns `false`, the frame drawing is cancelled until
  * another `render` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart drawing.
  */
 /**
  * @method IPlugin#afterDraw
  * @desc Called after the `chart` has been drawn for the specific easing value. Note
  * that this hook will not be called if the drawing has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeDatasetsDraw
  * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
  * the datasets drawing is cancelled until another `render` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart datasets drawing.
  */
 /**
  * @method IPlugin#afterDatasetsDraw
  * @desc Called after the `chart` datasets have been drawn. Note that this hook
  * will not be called if the datasets drawing has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeDatasetDraw
  * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
  * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
  * is cancelled until another `render` is triggered.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart datasets drawing.
  */
 /**
  * @method IPlugin#afterDatasetDraw
  * @desc Called after the `chart` datasets at the given `args.index` have been drawn
  * (datasets are drawn in the reverse order). Note that this hook will not be called
  * if the datasets drawing has been previously cancelled.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeTooltipDraw
  * @desc Called before drawing the `tooltip`. If any plugin returns `false`,
  * the tooltip drawing is cancelled until another `render` is triggered.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Object} args.tooltip - The tooltip.
  * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart tooltip drawing.
  */
 /**
  * @method IPlugin#afterTooltipDraw
  * @desc Called after drawing the `tooltip`. Note that this hook will not
  * be called if the tooltip drawing has been previously cancelled.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Object} args.tooltip - The tooltip.
  * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#beforeEvent
  * @desc Called before processing the specified `event`. If any plugin returns `false`,
  * the event will be discarded.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {IEvent} event - The event object.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#afterEvent
  * @desc Called after the `event` has been consumed. Note that this hook
  * will not be called if the `event` has been previously discarded.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {IEvent} event - The event object.
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#resize
  * @desc Called after the chart as been resized.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
  * @param {Object} options - The plugin options.
  */
 /**
  * @method IPlugin#destroy
  * @desc Called after the chart as been destroyed.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
 
 },{"25":25,"45":45}],32:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 var Ticks = require(34);
 
 defaults._set('scale', {
 	display: true,
 	position: 'left',
 	offset: false,
 
 	// grid line settings
 	gridLines: {
 		display: true,
 		color: 'rgba(0, 0, 0, 0.1)',
 		lineWidth: 1,
 		drawBorder: true,
 		drawOnChartArea: true,
 		drawTicks: true,
 		tickMarkLength: 10,
 		zeroLineWidth: 1,
 		zeroLineColor: 'rgba(0,0,0,0.25)',
 		zeroLineBorderDash: [],
 		zeroLineBorderDashOffset: 0.0,
 		offsetGridLines: false,
 		borderDash: [],
 		borderDashOffset: 0.0
 	},
 
 	// scale label
 	scaleLabel: {
 		// display property
 		display: false,
 
 		// actual label
 		labelString: '',
 
 		// line height
 		lineHeight: 1.2,
 
 		// top/bottom padding
 		padding: {
 			top: 4,
 			bottom: 4
 		}
 	},
 
 	// label settings
 	ticks: {
 		beginAtZero: false,
 		minRotation: 0,
 		maxRotation: 50,
 		mirror: false,
 		padding: 0,
 		reverse: false,
 		display: true,
 		autoSkip: true,
 		autoSkipPadding: 0,
 		labelOffset: 0,
 		// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
 		callback: Ticks.formatters.values,
 		minor: {},
 		major: {}
 	}
 });
 
 function labelsFromTicks(ticks) {
 	var labels = [];
 	var i, ilen;
 
 	for (i = 0, ilen = ticks.length; i < ilen; ++i) {
 		labels.push(ticks[i].label);
 	}
 
 	return labels;
 }
 
 function getLineValue(scale, index, offsetGridLines) {
 	var lineValue = scale.getPixelForTick(index);
 
 	if (offsetGridLines) {
 		if (index === 0) {
 			lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
 		} else {
 			lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
 		}
 	}
 	return lineValue;
 }
 
 module.exports = function(Chart) {
 
 	function computeTextSize(context, tick, font) {
 		return helpers.isArray(tick) ?
 			helpers.longestText(context, font, tick) :
 			context.measureText(tick).width;
 	}
 
 	function parseFontOptions(options) {
 		var valueOrDefault = helpers.valueOrDefault;
 		var globalDefaults = defaults.global;
 		var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
 		var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
 		var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
 
 		return {
 			size: size,
 			style: style,
 			family: family,
 			font: helpers.fontString(size, style, family)
 		};
 	}
 
 	function parseLineHeight(options) {
 		return helpers.options.toLineHeight(
 			helpers.valueOrDefault(options.lineHeight, 1.2),
 			helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
 	}
 
 	Chart.Scale = Element.extend({
 		/**
 		 * Get the padding needed for the scale
 		 * @method getPadding
 		 * @private
 		 * @returns {Padding} the necessary padding
 		 */
 		getPadding: function() {
 			var me = this;
 			return {
 				left: me.paddingLeft || 0,
 				top: me.paddingTop || 0,
 				right: me.paddingRight || 0,
 				bottom: me.paddingBottom || 0
 			};
 		},
 
 		/**
 		 * Returns the scale tick objects ({label, major})
 		 * @since 2.7
 		 */
 		getTicks: function() {
 			return this._ticks;
 		},
 
 		// These methods are ordered by lifecyle. Utilities then follow.
 		// Any function defined here is inherited by all scale types.
 		// Any function can be extended by the scale type
 
 		mergeTicksOptions: function() {
 			var ticks = this.options.ticks;
 			if (ticks.minor === false) {
 				ticks.minor = {
 					display: false
 				};
 			}
 			if (ticks.major === false) {
 				ticks.major = {
 					display: false
 				};
 			}
 			for (var key in ticks) {
 				if (key !== 'major' && key !== 'minor') {
 					if (typeof ticks.minor[key] === 'undefined') {
 						ticks.minor[key] = ticks[key];
 					}
 					if (typeof ticks.major[key] === 'undefined') {
 						ticks.major[key] = ticks[key];
 					}
 				}
 			}
 		},
 		beforeUpdate: function() {
 			helpers.callback(this.options.beforeUpdate, [this]);
 		},
 		update: function(maxWidth, maxHeight, margins) {
 			var me = this;
 			var i, ilen, labels, label, ticks, tick;
 
 			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
 			me.beforeUpdate();
 
 			// Absorb the master measurements
 			me.maxWidth = maxWidth;
 			me.maxHeight = maxHeight;
 			me.margins = helpers.extend({
 				left: 0,
 				right: 0,
 				top: 0,
 				bottom: 0
 			}, margins);
 			me.longestTextCache = me.longestTextCache || {};
 
 			// Dimensions
 			me.beforeSetDimensions();
 			me.setDimensions();
 			me.afterSetDimensions();
 
 			// Data min/max
 			me.beforeDataLimits();
 			me.determineDataLimits();
 			me.afterDataLimits();
 
 			// Ticks - `this.ticks` is now DEPRECATED!
 			// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
 			// and must not be accessed directly from outside this class. `this.ticks` being
 			// around for long time and not marked as private, we can't change its structure
 			// without unexpected breaking changes. If you need to access the scale ticks,
 			// use scale.getTicks() instead.
 
 			me.beforeBuildTicks();
 
 			// New implementations should return an array of objects but for BACKWARD COMPAT,
 			// we still support no return (`this.ticks` internally set by calling this method).
 			ticks = me.buildTicks() || [];
 
 			me.afterBuildTicks();
 
 			me.beforeTickToLabelConversion();
 
 			// New implementations should return the formatted tick labels but for BACKWARD
 			// COMPAT, we still support no return (`this.ticks` internally changed by calling
 			// this method and supposed to contain only string values).
 			labels = me.convertTicksToLabels(ticks) || me.ticks;
 
 			me.afterTickToLabelConversion();
 
 			me.ticks = labels;   // BACKWARD COMPATIBILITY
 
 			// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
 
 			// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
 			for (i = 0, ilen = labels.length; i < ilen; ++i) {
 				label = labels[i];
 				tick = ticks[i];
 				if (!tick) {
 					ticks.push(tick = {
 						label: label,
 						major: false
 					});
 				} else {
 					tick.label = label;
 				}
 			}
 
 			me._ticks = ticks;
 
 			// Tick Rotation
 			me.beforeCalculateTickRotation();
 			me.calculateTickRotation();
 			me.afterCalculateTickRotation();
 			// Fit
 			me.beforeFit();
 			me.fit();
 			me.afterFit();
 			//
 			me.afterUpdate();
 
 			return me.minSize;
 
 		},
 		afterUpdate: function() {
 			helpers.callback(this.options.afterUpdate, [this]);
 		},
 
 		//
 
 		beforeSetDimensions: function() {
 			helpers.callback(this.options.beforeSetDimensions, [this]);
 		},
 		setDimensions: function() {
 			var me = this;
 			// Set the unconstrained dimension before label rotation
 			if (me.isHorizontal()) {
 				// Reset position before calculating rotation
 				me.width = me.maxWidth;
 				me.left = 0;
 				me.right = me.width;
 			} else {
 				me.height = me.maxHeight;
 
 				// Reset position before calculating rotation
 				me.top = 0;
 				me.bottom = me.height;
 			}
 
 			// Reset padding
 			me.paddingLeft = 0;
 			me.paddingTop = 0;
 			me.paddingRight = 0;
 			me.paddingBottom = 0;
 		},
 		afterSetDimensions: function() {
 			helpers.callback(this.options.afterSetDimensions, [this]);
 		},
 
 		// Data limits
 		beforeDataLimits: function() {
 			helpers.callback(this.options.beforeDataLimits, [this]);
 		},
 		determineDataLimits: helpers.noop,
 		afterDataLimits: function() {
 			helpers.callback(this.options.afterDataLimits, [this]);
 		},
 
 		//
 		beforeBuildTicks: function() {
 			helpers.callback(this.options.beforeBuildTicks, [this]);
 		},
 		buildTicks: helpers.noop,
 		afterBuildTicks: function() {
 			helpers.callback(this.options.afterBuildTicks, [this]);
 		},
 
 		beforeTickToLabelConversion: function() {
 			helpers.callback(this.options.beforeTickToLabelConversion, [this]);
 		},
 		convertTicksToLabels: function() {
 			var me = this;
 			// Convert ticks to strings
 			var tickOpts = me.options.ticks;
 			me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
 		},
 		afterTickToLabelConversion: function() {
 			helpers.callback(this.options.afterTickToLabelConversion, [this]);
 		},
 
 		//
 
 		beforeCalculateTickRotation: function() {
 			helpers.callback(this.options.beforeCalculateTickRotation, [this]);
 		},
 		calculateTickRotation: function() {
 			var me = this;
 			var context = me.ctx;
 			var tickOpts = me.options.ticks;
 			var labels = labelsFromTicks(me._ticks);
 
 			// Get the width of each grid by calculating the difference
 			// between x offsets between 0 and 1.
 			var tickFont = parseFontOptions(tickOpts);
 			context.font = tickFont.font;
 
 			var labelRotation = tickOpts.minRotation || 0;
 
 			if (labels.length && me.options.display && me.isHorizontal()) {
 				var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
 				var labelWidth = originalLabelWidth;
 				var cosRotation, sinRotation;
 
 				// Allow 3 pixels x2 padding either side for label readability
 				var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
 
 				// Max label rotation can be set or default to 90 - also act as a loop counter
 				while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
 					var angleRadians = helpers.toRadians(labelRotation);
 					cosRotation = Math.cos(angleRadians);
 					sinRotation = Math.sin(angleRadians);
 
 					if (sinRotation * originalLabelWidth > me.maxHeight) {
 						// go back one step
 						labelRotation--;
 						break;
 					}
 
 					labelRotation++;
 					labelWidth = cosRotation * originalLabelWidth;
 				}
 			}
 
 			me.labelRotation = labelRotation;
 		},
 		afterCalculateTickRotation: function() {
 			helpers.callback(this.options.afterCalculateTickRotation, [this]);
 		},
 
 		//
 
 		beforeFit: function() {
 			helpers.callback(this.options.beforeFit, [this]);
 		},
 		fit: function() {
 			var me = this;
 			// Reset
 			var minSize = me.minSize = {
 				width: 0,
 				height: 0
 			};
 
 			var labels = labelsFromTicks(me._ticks);
 
 			var opts = me.options;
 			var tickOpts = opts.ticks;
 			var scaleLabelOpts = opts.scaleLabel;
 			var gridLineOpts = opts.gridLines;
 			var display = opts.display;
 			var isHorizontal = me.isHorizontal();
 
 			var tickFont = parseFontOptions(tickOpts);
 			var tickMarkLength = opts.gridLines.tickMarkLength;
 
 			// Width
 			if (isHorizontal) {
 				// subtract the margins to line up with the chartArea if we are a full width scale
 				minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
 			} else {
 				minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
 			}
 
 			// height
 			if (isHorizontal) {
 				minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
 			} else {
 				minSize.height = me.maxHeight; // fill all the height
 			}
 
 			// Are we showing a title for the scale?
 			if (scaleLabelOpts.display && display) {
 				var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
 				var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
 				var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;
 
 				if (isHorizontal) {
 					minSize.height += deltaHeight;
 				} else {
 					minSize.width += deltaHeight;
 				}
 			}
 
 			// Don't bother fitting the ticks if we are not showing them
 			if (tickOpts.display && display) {
 				var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
 				var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
 				var lineSpace = tickFont.size * 0.5;
 				var tickPadding = me.options.ticks.padding;
 
 				if (isHorizontal) {
 					// A horizontal axis is more constrained by the height.
 					me.longestLabelWidth = largestTextWidth;
 
 					var angleRadians = helpers.toRadians(me.labelRotation);
 					var cosRotation = Math.cos(angleRadians);
 					var sinRotation = Math.sin(angleRadians);
 
 					// TODO - improve this calculation
 					var labelHeight = (sinRotation * largestTextWidth)
 						+ (tickFont.size * tallestLabelHeightInLines)
 						+ (lineSpace * (tallestLabelHeightInLines - 1))
 						+ lineSpace; // padding
 
 					minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
 
 					me.ctx.font = tickFont.font;
 					var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
 					var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);
 
 					// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
 					// which means that the right padding is dominated by the font height
 					if (me.labelRotation !== 0) {
 						me.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
 						me.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
 					} else {
 						me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
 						me.paddingRight = lastLabelWidth / 2 + 3;
 					}
 				} else {
 					// A vertical axis is more constrained by the width. Labels are the
 					// dominant factor here, so get that length first and account for padding
 					if (tickOpts.mirror) {
 						largestTextWidth = 0;
 					} else {
 						// use lineSpace for consistency with horizontal axis
 						// tickPadding is not implemented for horizontal
 						largestTextWidth += tickPadding + lineSpace;
 					}
 
 					minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
 
 					me.paddingTop = tickFont.size / 2;
 					me.paddingBottom = tickFont.size / 2;
 				}
 			}
 
 			me.handleMargins();
 
 			me.width = minSize.width;
 			me.height = minSize.height;
 		},
 
 		/**
 		 * Handle margins and padding interactions
 		 * @private
 		 */
 		handleMargins: function() {
 			var me = this;
 			if (me.margins) {
 				me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
 				me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
 				me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
 				me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
 			}
 		},
 
 		afterFit: function() {
 			helpers.callback(this.options.afterFit, [this]);
 		},
 
 		// Shared Methods
 		isHorizontal: function() {
 			return this.options.position === 'top' || this.options.position === 'bottom';
 		},
 		isFullWidth: function() {
 			return (this.options.fullWidth);
 		},
 
 		// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
 		getRightValue: function(rawValue) {
 			// Null and undefined values first
 			if (helpers.isNullOrUndef(rawValue)) {
 				return NaN;
 			}
 			// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
 			if (typeof rawValue === 'number' && !isFinite(rawValue)) {
 				return NaN;
 			}
 			// If it is in fact an object, dive in one more level
 			if (rawValue) {
 				if (this.isHorizontal()) {
 					if (rawValue.x !== undefined) {
 						return this.getRightValue(rawValue.x);
 					}
 				} else if (rawValue.y !== undefined) {
 					return this.getRightValue(rawValue.y);
 				}
 			}
 
 			// Value is good, return it
 			return rawValue;
 		},
 
 		/**
 		 * Used to get the value to display in the tooltip for the data at the given index
 		 * @param index
 		 * @param datasetIndex
 		 */
 		getLabelForIndex: helpers.noop,
 
 		/**
 		 * Returns the location of the given data point. Value can either be an index or a numerical value
 		 * The coordinate (0, 0) is at the upper-left corner of the canvas
 		 * @param value
 		 * @param index
 		 * @param datasetIndex
 		 */
 		getPixelForValue: helpers.noop,
 
 		/**
 		 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
 		 * The coordinate (0, 0) is at the upper-left corner of the canvas
 		 * @param pixel
 		 */
 		getValueForPixel: helpers.noop,
 
 		/**
 		 * Returns the location of the tick at the given index
 		 * The coordinate (0, 0) is at the upper-left corner of the canvas
 		 */
 		getPixelForTick: function(index) {
 			var me = this;
 			var offset = me.options.offset;
 			if (me.isHorizontal()) {
 				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
 				var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
 				var pixel = (tickWidth * index) + me.paddingLeft;
 
 				if (offset) {
 					pixel += tickWidth / 2;
 				}
 
 				var finalVal = me.left + Math.round(pixel);
 				finalVal += me.isFullWidth() ? me.margins.left : 0;
 				return finalVal;
 			}
 			var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
 			return me.top + (index * (innerHeight / (me._ticks.length - 1)));
 		},
 
 		/**
 		 * Utility for getting the pixel location of a percentage of scale
 		 * The coordinate (0, 0) is at the upper-left corner of the canvas
 		 */
 		getPixelForDecimal: function(decimal) {
 			var me = this;
 			if (me.isHorizontal()) {
 				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
 				var valueOffset = (innerWidth * decimal) + me.paddingLeft;
 
 				var finalVal = me.left + Math.round(valueOffset);
 				finalVal += me.isFullWidth() ? me.margins.left : 0;
 				return finalVal;
 			}
 			return me.top + (decimal * me.height);
 		},
 
 		/**
 		 * Returns the pixel for the minimum chart value
 		 * The coordinate (0, 0) is at the upper-left corner of the canvas
 		 */
 		getBasePixel: function() {
 			return this.getPixelForValue(this.getBaseValue());
 		},
 
 		getBaseValue: function() {
 			var me = this;
 			var min = me.min;
 			var max = me.max;
 
 			return me.beginAtZero ? 0 :
 				min < 0 && max < 0 ? max :
 				min > 0 && max > 0 ? min :
 				0;
 		},
 
 		/**
 		 * Returns a subset of ticks to be plotted to avoid overlapping labels.
 		 * @private
 		 */
 		_autoSkip: function(ticks) {
 			var skipRatio;
 			var me = this;
 			var isHorizontal = me.isHorizontal();
 			var optionTicks = me.options.ticks.minor;
 			var tickCount = ticks.length;
 			var labelRotationRadians = helpers.toRadians(me.labelRotation);
 			var cosRotation = Math.cos(labelRotationRadians);
 			var longestRotatedLabel = me.longestLabelWidth * cosRotation;
 			var result = [];
 			var i, tick, shouldSkip;
 
 			// figure out the maximum number of gridlines to show
 			var maxTicks;
 			if (optionTicks.maxTicksLimit) {
 				maxTicks = optionTicks.maxTicksLimit;
 			}
 
 			if (isHorizontal) {
 				skipRatio = false;
 
 				if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {
 					skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
 				}
 
 				// if they defined a max number of optionTicks,
 				// increase skipRatio until that number is met
 				if (maxTicks && tickCount > maxTicks) {
 					skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
 				}
 			}
 
 			for (i = 0; i < tickCount; i++) {
 				tick = ticks[i];
 
 				// Since we always show the last tick,we need may need to hide the last shown one before
 				shouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);
 				if (shouldSkip && i !== tickCount - 1) {
 					// leave tick in place but make sure it's not displayed (#4635)
 					delete tick.label;
 				}
 				result.push(tick);
 			}
 			return result;
 		},
 
 		// Actually draw the scale on the canvas
 		// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
 		draw: function(chartArea) {
 			var me = this;
 			var options = me.options;
 			if (!options.display) {
 				return;
 			}
 
 			var context = me.ctx;
 			var globalDefaults = defaults.global;
 			var optionTicks = options.ticks.minor;
 			var optionMajorTicks = options.ticks.major || optionTicks;
 			var gridLines = options.gridLines;
 			var scaleLabel = options.scaleLabel;
 
 			var isRotated = me.labelRotation !== 0;
 			var isHorizontal = me.isHorizontal();
 
 			var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
 			var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
 			var tickFont = parseFontOptions(optionTicks);
 			var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
 			var majorTickFont = parseFontOptions(optionMajorTicks);
 
 			var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
 
 			var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
 			var scaleLabelFont = parseFontOptions(scaleLabel);
 			var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
 			var labelRotationRadians = helpers.toRadians(me.labelRotation);
 
 			var itemsToDraw = [];
 
 			var axisWidth = me.options.gridLines.lineWidth;
 			var xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;
 			var xTickEnd = options.position === 'right' ? me.right + tl : me.right;
 			var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;
 			var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;
 
 			helpers.each(ticks, function(tick, index) {
 				// autoskipper skipped this tick (#4635)
 				if (helpers.isNullOrUndef(tick.label)) {
 					return;
 				}
 
 				var label = tick.label;
 				var lineWidth, lineColor, borderDash, borderDashOffset;
 				if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
 					// Draw the first index specially
 					lineWidth = gridLines.zeroLineWidth;
 					lineColor = gridLines.zeroLineColor;
 					borderDash = gridLines.zeroLineBorderDash;
 					borderDashOffset = gridLines.zeroLineBorderDashOffset;
 				} else {
 					lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
 					lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
 					borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
 					borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
 				}
 
 				// Common properties
 				var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
 				var textAlign = 'middle';
 				var textBaseline = 'middle';
 				var tickPadding = optionTicks.padding;
 
 				if (isHorizontal) {
 					var labelYOffset = tl + tickPadding;
 
 					if (options.position === 'bottom') {
 						// bottom
 						textBaseline = !isRotated ? 'top' : 'middle';
 						textAlign = !isRotated ? 'center' : 'right';
 						labelY = me.top + labelYOffset;
 					} else {
 						// top
 						textBaseline = !isRotated ? 'bottom' : 'middle';
 						textAlign = !isRotated ? 'center' : 'left';
 						labelY = me.bottom - labelYOffset;
 					}
 
 					var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
 					if (xLineValue < me.left) {
 						lineColor = 'rgba(0,0,0,0)';
 					}
 					xLineValue += helpers.aliasPixel(lineWidth);
 
 					labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)
 
 					tx1 = tx2 = x1 = x2 = xLineValue;
 					ty1 = yTickStart;
 					ty2 = yTickEnd;
 					y1 = chartArea.top;
 					y2 = chartArea.bottom + axisWidth;
 				} else {
 					var isLeft = options.position === 'left';
 					var labelXOffset;
 
 					if (optionTicks.mirror) {
 						textAlign = isLeft ? 'left' : 'right';
 						labelXOffset = tickPadding;
 					} else {
 						textAlign = isLeft ? 'right' : 'left';
 						labelXOffset = tl + tickPadding;
 					}
 
 					labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;
 
 					var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
 					if (yLineValue < me.top) {
 						lineColor = 'rgba(0,0,0,0)';
 					}
 					yLineValue += helpers.aliasPixel(lineWidth);
 
 					labelY = me.getPixelForTick(index) + optionTicks.labelOffset;
 
 					tx1 = xTickStart;
 					tx2 = xTickEnd;
 					x1 = chartArea.left;
 					x2 = chartArea.right + axisWidth;
 					ty1 = ty2 = y1 = y2 = yLineValue;
 				}
 
 				itemsToDraw.push({
 					tx1: tx1,
 					ty1: ty1,
 					tx2: tx2,
 					ty2: ty2,
 					x1: x1,
 					y1: y1,
 					x2: x2,
 					y2: y2,
 					labelX: labelX,
 					labelY: labelY,
 					glWidth: lineWidth,
 					glColor: lineColor,
 					glBorderDash: borderDash,
 					glBorderDashOffset: borderDashOffset,
 					rotation: -1 * labelRotationRadians,
 					label: label,
 					major: tick.major,
 					textBaseline: textBaseline,
 					textAlign: textAlign
 				});
 			});
 
 			// Draw all of the tick labels, tick marks, and grid lines at the correct places
 			helpers.each(itemsToDraw, function(itemToDraw) {
 				if (gridLines.display) {
 					context.save();
 					context.lineWidth = itemToDraw.glWidth;
 					context.strokeStyle = itemToDraw.glColor;
 					if (context.setLineDash) {
 						context.setLineDash(itemToDraw.glBorderDash);
 						context.lineDashOffset = itemToDraw.glBorderDashOffset;
 					}
 
 					context.beginPath();
 
 					if (gridLines.drawTicks) {
 						context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
 						context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
 					}
 
 					if (gridLines.drawOnChartArea) {
 						context.moveTo(itemToDraw.x1, itemToDraw.y1);
 						context.lineTo(itemToDraw.x2, itemToDraw.y2);
 					}
 
 					context.stroke();
 					context.restore();
 				}
 
 				if (optionTicks.display) {
 					// Make sure we draw text in the correct color and font
 					context.save();
 					context.translate(itemToDraw.labelX, itemToDraw.labelY);
 					context.rotate(itemToDraw.rotation);
 					context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
 					context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
 					context.textBaseline = itemToDraw.textBaseline;
 					context.textAlign = itemToDraw.textAlign;
 
 					var label = itemToDraw.label;
 					if (helpers.isArray(label)) {
 						var lineCount = label.length;
 						var lineHeight = tickFont.size * 1.5;
 						var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;
 
 						for (var i = 0; i < lineCount; ++i) {
 							// We just make sure the multiline element is a string here..
 							context.fillText('' + label[i], 0, y);
 							// apply same lineSpacing as calculated @ L#320
 							y += lineHeight;
 						}
 					} else {
 						context.fillText(label, 0, 0);
 					}
 					context.restore();
 				}
 			});
 
 			if (scaleLabel.display) {
 				// Draw the scale label
 				var scaleLabelX;
 				var scaleLabelY;
 				var rotation = 0;
 				var halfLineHeight = parseLineHeight(scaleLabel) / 2;
 
 				if (isHorizontal) {
 					scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
 					scaleLabelY = options.position === 'bottom'
 						? me.bottom - halfLineHeight - scaleLabelPadding.bottom
 						: me.top + halfLineHeight + scaleLabelPadding.top;
 				} else {
 					var isLeft = options.position === 'left';
 					scaleLabelX = isLeft
 						? me.left + halfLineHeight + scaleLabelPadding.top
 						: me.right - halfLineHeight - scaleLabelPadding.top;
 					scaleLabelY = me.top + ((me.bottom - me.top) / 2);
 					rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
 				}
 
 				context.save();
 				context.translate(scaleLabelX, scaleLabelY);
 				context.rotate(rotation);
 				context.textAlign = 'center';
 				context.textBaseline = 'middle';
 				context.fillStyle = scaleLabelFontColor; // render in correct colour
 				context.font = scaleLabelFont.font;
 				context.fillText(scaleLabel.labelString, 0, 0);
 				context.restore();
 			}
 
 			if (gridLines.drawBorder) {
 				// Draw the line at the edge of the axis
 				context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
 				context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
 				var x1 = me.left;
 				var x2 = me.right + axisWidth;
 				var y1 = me.top;
 				var y2 = me.bottom + axisWidth;
 
 				var aliasPixel = helpers.aliasPixel(context.lineWidth);
 				if (isHorizontal) {
 					y1 = y2 = options.position === 'top' ? me.bottom : me.top;
 					y1 += aliasPixel;
 					y2 += aliasPixel;
 				} else {
 					x1 = x2 = options.position === 'left' ? me.right : me.left;
 					x1 += aliasPixel;
 					x2 += aliasPixel;
 				}
 
 				context.beginPath();
 				context.moveTo(x1, y1);
 				context.lineTo(x2, y2);
 				context.stroke();
 			}
 		}
 	});
 };
 
 },{"25":25,"26":26,"34":34,"45":45}],33:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var helpers = require(45);
 var layouts = require(30);
 
 module.exports = function(Chart) {
 
 	Chart.scaleService = {
 		// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
 		// use the new chart options to grab the correct scale
 		constructors: {},
 		// Use a registration function so that we can move to an ES6 map when we no longer need to support
 		// old browsers
 
 		// Scale config defaults
 		defaults: {},
 		registerScaleType: function(type, scaleConstructor, scaleDefaults) {
 			this.constructors[type] = scaleConstructor;
 			this.defaults[type] = helpers.clone(scaleDefaults);
 		},
 		getScaleConstructor: function(type) {
 			return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
 		},
 		getScaleDefaults: function(type) {
 			// Return the scale defaults merged with the global settings so that we always use the latest ones
 			return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
 		},
 		updateScaleDefaults: function(type, additions) {
 			var me = this;
 			if (me.defaults.hasOwnProperty(type)) {
 				me.defaults[type] = helpers.extend(me.defaults[type], additions);
 			}
 		},
 		addScalesToLayout: function(chart) {
 			// Adds each scale to the chart.boxes array to be sized accordingly
 			helpers.each(chart.scales, function(scale) {
 				// Set ILayoutItem parameters for backwards compatibility
 				scale.fullWidth = scale.options.fullWidth;
 				scale.position = scale.options.position;
 				scale.weight = scale.options.weight;
 				layouts.addBox(chart, scale);
 			});
 		}
 	};
 };
 
 },{"25":25,"30":30,"45":45}],34:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 
 /**
  * Namespace to hold static tick generation functions
  * @namespace Chart.Ticks
  */
 module.exports = {
 	/**
 	 * Namespace to hold formatters for different types of ticks
 	 * @namespace Chart.Ticks.formatters
 	 */
 	formatters: {
 		/**
 		 * Formatter for value labels
 		 * @method Chart.Ticks.formatters.values
 		 * @param value the value to display
 		 * @return {String|Array} the label to display
 		 */
 		values: function(value) {
 			return helpers.isArray(value) ? value : '' + value;
 		},
 
 		/**
 		 * Formatter for linear numeric ticks
 		 * @method Chart.Ticks.formatters.linear
 		 * @param tickValue {Number} the value to be formatted
 		 * @param index {Number} the position of the tickValue parameter in the ticks array
 		 * @param ticks {Array<Number>} the list of ticks being converted
 		 * @return {String} string representation of the tickValue parameter
 		 */
 		linear: function(tickValue, index, ticks) {
 			// If we have lots of ticks, don't use the ones
 			var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
 
 			// If we have a number like 2.5 as the delta, figure out how many decimal places we need
 			if (Math.abs(delta) > 1) {
 				if (tickValue !== Math.floor(tickValue)) {
 					// not an integer
 					delta = tickValue - Math.floor(tickValue);
 				}
 			}
 
 			var logDelta = helpers.log10(Math.abs(delta));
 			var tickString = '';
 
 			if (tickValue !== 0) {
 				var numDecimal = -1 * Math.floor(logDelta);
 				numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
 				tickString = tickValue.toFixed(numDecimal);
 			} else {
 				tickString = '0'; // never show decimal places for 0
 			}
 
 			return tickString;
 		},
 
 		logarithmic: function(tickValue, index, ticks) {
 			var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));
 
 			if (tickValue === 0) {
 				return '0';
 			} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
 				return tickValue.toExponential();
 			}
 			return '';
 		}
 	}
 };
 
 },{"45":45}],35:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 
 defaults._set('global', {
 	tooltips: {
 		enabled: true,
 		custom: null,
 		mode: 'nearest',
 		position: 'average',
 		intersect: true,
 		backgroundColor: 'rgba(0,0,0,0.8)',
 		titleFontStyle: 'bold',
 		titleSpacing: 2,
 		titleMarginBottom: 6,
 		titleFontColor: '#fff',
 		titleAlign: 'left',
 		bodySpacing: 2,
 		bodyFontColor: '#fff',
 		bodyAlign: 'left',
 		footerFontStyle: 'bold',
 		footerSpacing: 2,
 		footerMarginTop: 6,
 		footerFontColor: '#fff',
 		footerAlign: 'left',
 		yPadding: 6,
 		xPadding: 6,
 		caretPadding: 2,
 		caretSize: 5,
 		cornerRadius: 6,
 		multiKeyBackground: '#fff',
 		displayColors: true,
 		borderColor: 'rgba(0,0,0,0)',
 		borderWidth: 0,
 		callbacks: {
 			// Args are: (tooltipItems, data)
 			beforeTitle: helpers.noop,
 			title: function(tooltipItems, data) {
 				// Pick first xLabel for now
 				var title = '';
 				var labels = data.labels;
 				var labelCount = labels ? labels.length : 0;
 
 				if (tooltipItems.length > 0) {
 					var item = tooltipItems[0];
 
 					if (item.xLabel) {
 						title = item.xLabel;
 					} else if (labelCount > 0 && item.index < labelCount) {
 						title = labels[item.index];
 					}
 				}
 
 				return title;
 			},
 			afterTitle: helpers.noop,
 
 			// Args are: (tooltipItems, data)
 			beforeBody: helpers.noop,
 
 			// Args are: (tooltipItem, data)
 			beforeLabel: helpers.noop,
 			label: function(tooltipItem, data) {
 				var label = data.datasets[tooltipItem.datasetIndex].label || '';
 
 				if (label) {
 					label += ': ';
 				}
 				label += tooltipItem.yLabel;
 				return label;
 			},
 			labelColor: function(tooltipItem, chart) {
 				var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
 				var activeElement = meta.data[tooltipItem.index];
 				var view = activeElement._view;
 				return {
 					borderColor: view.borderColor,
 					backgroundColor: view.backgroundColor
 				};
 			},
 			labelTextColor: function() {
 				return this._options.bodyFontColor;
 			},
 			afterLabel: helpers.noop,
 
 			// Args are: (tooltipItems, data)
 			afterBody: helpers.noop,
 
 			// Args are: (tooltipItems, data)
 			beforeFooter: helpers.noop,
 			footer: helpers.noop,
 			afterFooter: helpers.noop
 		}
 	}
 });
 
 module.exports = function(Chart) {
 
 	/**
  	 * Helper method to merge the opacity into a color
  	 */
 	function mergeOpacity(colorString, opacity) {
 		var color = helpers.color(colorString);
 		return color.alpha(opacity * color.alpha()).rgbaString();
 	}
 
 	// Helper to push or concat based on if the 2nd parameter is an array or not
 	function pushOrConcat(base, toPush) {
 		if (toPush) {
 			if (helpers.isArray(toPush)) {
 				// base = base.concat(toPush);
 				Array.prototype.push.apply(base, toPush);
 			} else {
 				base.push(toPush);
 			}
 		}
 
 		return base;
 	}
 
 	// Private helper to create a tooltip item model
 	// @param element : the chart element (point, arc, bar) to create the tooltip item for
 	// @return : new tooltip item
 	function createTooltipItem(element) {
 		var xScale = element._xScale;
 		var yScale = element._yScale || element._scale; // handle radar || polarArea charts
 		var index = element._index;
 		var datasetIndex = element._datasetIndex;
 
 		return {
 			xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
 			yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
 			index: index,
 			datasetIndex: datasetIndex,
 			x: element._model.x,
 			y: element._model.y
 		};
 	}
 
 	/**
 	 * Helper to get the reset model for the tooltip
 	 * @param tooltipOpts {Object} the tooltip options
 	 */
 	function getBaseModel(tooltipOpts) {
 		var globalDefaults = defaults.global;
 		var valueOrDefault = helpers.valueOrDefault;
 
 		return {
 			// Positioning
 			xPadding: tooltipOpts.xPadding,
 			yPadding: tooltipOpts.yPadding,
 			xAlign: tooltipOpts.xAlign,
 			yAlign: tooltipOpts.yAlign,
 
 			// Body
 			bodyFontColor: tooltipOpts.bodyFontColor,
 			_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
 			_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
 			_bodyAlign: tooltipOpts.bodyAlign,
 			bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
 			bodySpacing: tooltipOpts.bodySpacing,
 
 			// Title
 			titleFontColor: tooltipOpts.titleFontColor,
 			_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
 			_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
 			titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
 			_titleAlign: tooltipOpts.titleAlign,
 			titleSpacing: tooltipOpts.titleSpacing,
 			titleMarginBottom: tooltipOpts.titleMarginBottom,
 
 			// Footer
 			footerFontColor: tooltipOpts.footerFontColor,
 			_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
 			_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
 			footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
 			_footerAlign: tooltipOpts.footerAlign,
 			footerSpacing: tooltipOpts.footerSpacing,
 			footerMarginTop: tooltipOpts.footerMarginTop,
 
 			// Appearance
 			caretSize: tooltipOpts.caretSize,
 			cornerRadius: tooltipOpts.cornerRadius,
 			backgroundColor: tooltipOpts.backgroundColor,
 			opacity: 0,
 			legendColorBackground: tooltipOpts.multiKeyBackground,
 			displayColors: tooltipOpts.displayColors,
 			borderColor: tooltipOpts.borderColor,
 			borderWidth: tooltipOpts.borderWidth
 		};
 	}
 
 	/**
 	 * Get the size of the tooltip
 	 */
 	function getTooltipSize(tooltip, model) {
 		var ctx = tooltip._chart.ctx;
 
 		var height = model.yPadding * 2; // Tooltip Padding
 		var width = 0;
 
 		// Count of all lines in the body
 		var body = model.body;
 		var combinedBodyLength = body.reduce(function(count, bodyItem) {
 			return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
 		}, 0);
 		combinedBodyLength += model.beforeBody.length + model.afterBody.length;
 
 		var titleLineCount = model.title.length;
 		var footerLineCount = model.footer.length;
 		var titleFontSize = model.titleFontSize;
 		var bodyFontSize = model.bodyFontSize;
 		var footerFontSize = model.footerFontSize;
 
 		height += titleLineCount * titleFontSize; // Title Lines
 		height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
 		height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
 		height += combinedBodyLength * bodyFontSize; // Body Lines
 		height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
 		height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
 		height += footerLineCount * (footerFontSize); // Footer Lines
 		height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
 
 		// Title width
 		var widthPadding = 0;
 		var maxLineWidth = function(line) {
 			width = Math.max(width, ctx.measureText(line).width + widthPadding);
 		};
 
 		ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
 		helpers.each(model.title, maxLineWidth);
 
 		// Body width
 		ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
 		helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
 
 		// Body lines may include some extra width due to the color box
 		widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
 		helpers.each(body, function(bodyItem) {
 			helpers.each(bodyItem.before, maxLineWidth);
 			helpers.each(bodyItem.lines, maxLineWidth);
 			helpers.each(bodyItem.after, maxLineWidth);
 		});
 
 		// Reset back to 0
 		widthPadding = 0;
 
 		// Footer width
 		ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
 		helpers.each(model.footer, maxLineWidth);
 
 		// Add padding
 		width += 2 * model.xPadding;
 
 		return {
 			width: width,
 			height: height
 		};
 	}
 
 	/**
 	 * Helper to get the alignment of a tooltip given the size
 	 */
 	function determineAlignment(tooltip, size) {
 		var model = tooltip._model;
 		var chart = tooltip._chart;
 		var chartArea = tooltip._chart.chartArea;
 		var xAlign = 'center';
 		var yAlign = 'center';
 
 		if (model.y < size.height) {
 			yAlign = 'top';
 		} else if (model.y > (chart.height - size.height)) {
 			yAlign = 'bottom';
 		}
 
 		var lf, rf; // functions to determine left, right alignment
 		var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
 		var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
 		var midX = (chartArea.left + chartArea.right) / 2;
 		var midY = (chartArea.top + chartArea.bottom) / 2;
 
 		if (yAlign === 'center') {
 			lf = function(x) {
 				return x <= midX;
 			};
 			rf = function(x) {
 				return x > midX;
 			};
 		} else {
 			lf = function(x) {
 				return x <= (size.width / 2);
 			};
 			rf = function(x) {
 				return x >= (chart.width - (size.width / 2));
 			};
 		}
 
 		olf = function(x) {
 			return x + size.width + model.caretSize + model.caretPadding > chart.width;
 		};
 		orf = function(x) {
 			return x - size.width - model.caretSize - model.caretPadding < 0;
 		};
 		yf = function(y) {
 			return y <= midY ? 'top' : 'bottom';
 		};
 
 		if (lf(model.x)) {
 			xAlign = 'left';
 
 			// Is tooltip too wide and goes over the right side of the chart.?
 			if (olf(model.x)) {
 				xAlign = 'center';
 				yAlign = yf(model.y);
 			}
 		} else if (rf(model.x)) {
 			xAlign = 'right';
 
 			// Is tooltip too wide and goes outside left edge of canvas?
 			if (orf(model.x)) {
 				xAlign = 'center';
 				yAlign = yf(model.y);
 			}
 		}
 
 		var opts = tooltip._options;
 		return {
 			xAlign: opts.xAlign ? opts.xAlign : xAlign,
 			yAlign: opts.yAlign ? opts.yAlign : yAlign
 		};
 	}
 
 	/**
 	 * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
 	 */
 	function getBackgroundPoint(vm, size, alignment, chart) {
 		// Background Position
 		var x = vm.x;
 		var y = vm.y;
 
 		var caretSize = vm.caretSize;
 		var caretPadding = vm.caretPadding;
 		var cornerRadius = vm.cornerRadius;
 		var xAlign = alignment.xAlign;
 		var yAlign = alignment.yAlign;
 		var paddingAndSize = caretSize + caretPadding;
 		var radiusAndPadding = cornerRadius + caretPadding;
 
 		if (xAlign === 'right') {
 			x -= size.width;
 		} else if (xAlign === 'center') {
 			x -= (size.width / 2);
 			if (x + size.width > chart.width) {
 				x = chart.width - size.width;
 			}
 			if (x < 0) {
 				x = 0;
 			}
 		}
 
 		if (yAlign === 'top') {
 			y += paddingAndSize;
 		} else if (yAlign === 'bottom') {
 			y -= size.height + paddingAndSize;
 		} else {
 			y -= (size.height / 2);
 		}
 
 		if (yAlign === 'center') {
 			if (xAlign === 'left') {
 				x += paddingAndSize;
 			} else if (xAlign === 'right') {
 				x -= paddingAndSize;
 			}
 		} else if (xAlign === 'left') {
 			x -= radiusAndPadding;
 		} else if (xAlign === 'right') {
 			x += radiusAndPadding;
 		}
 
 		return {
 			x: x,
 			y: y
 		};
 	}
 
 	Chart.Tooltip = Element.extend({
 		initialize: function() {
 			this._model = getBaseModel(this._options);
 			this._lastActive = [];
 		},
 
 		// Get the title
 		// Args are: (tooltipItem, data)
 		getTitle: function() {
 			var me = this;
 			var opts = me._options;
 			var callbacks = opts.callbacks;
 
 			var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
 			var title = callbacks.title.apply(me, arguments);
 			var afterTitle = callbacks.afterTitle.apply(me, arguments);
 
 			var lines = [];
 			lines = pushOrConcat(lines, beforeTitle);
 			lines = pushOrConcat(lines, title);
 			lines = pushOrConcat(lines, afterTitle);
 
 			return lines;
 		},
 
 		// Args are: (tooltipItem, data)
 		getBeforeBody: function() {
 			var lines = this._options.callbacks.beforeBody.apply(this, arguments);
 			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
 		},
 
 		// Args are: (tooltipItem, data)
 		getBody: function(tooltipItems, data) {
 			var me = this;
 			var callbacks = me._options.callbacks;
 			var bodyItems = [];
 
 			helpers.each(tooltipItems, function(tooltipItem) {
 				var bodyItem = {
 					before: [],
 					lines: [],
 					after: []
 				};
 				pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
 				pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
 				pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
 
 				bodyItems.push(bodyItem);
 			});
 
 			return bodyItems;
 		},
 
 		// Args are: (tooltipItem, data)
 		getAfterBody: function() {
 			var lines = this._options.callbacks.afterBody.apply(this, arguments);
 			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
 		},
 
 		// Get the footer and beforeFooter and afterFooter lines
 		// Args are: (tooltipItem, data)
 		getFooter: function() {
 			var me = this;
 			var callbacks = me._options.callbacks;
 
 			var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
 			var footer = callbacks.footer.apply(me, arguments);
 			var afterFooter = callbacks.afterFooter.apply(me, arguments);
 
 			var lines = [];
 			lines = pushOrConcat(lines, beforeFooter);
 			lines = pushOrConcat(lines, footer);
 			lines = pushOrConcat(lines, afterFooter);
 
 			return lines;
 		},
 
 		update: function(changed) {
 			var me = this;
 			var opts = me._options;
 
 			// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
 			// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
 			// which breaks any animations.
 			var existingModel = me._model;
 			var model = me._model = getBaseModel(opts);
 			var active = me._active;
 
 			var data = me._data;
 
 			// In the case where active.length === 0 we need to keep these at existing values for good animations
 			var alignment = {
 				xAlign: existingModel.xAlign,
 				yAlign: existingModel.yAlign
 			};
 			var backgroundPoint = {
 				x: existingModel.x,
 				y: existingModel.y
 			};
 			var tooltipSize = {
 				width: existingModel.width,
 				height: existingModel.height
 			};
 			var tooltipPosition = {
 				x: existingModel.caretX,
 				y: existingModel.caretY
 			};
 
 			var i, len;
 
 			if (active.length) {
 				model.opacity = 1;
 
 				var labelColors = [];
 				var labelTextColors = [];
 				tooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);
 
 				var tooltipItems = [];
 				for (i = 0, len = active.length; i < len; ++i) {
 					tooltipItems.push(createTooltipItem(active[i]));
 				}
 
 				// If the user provided a filter function, use it to modify the tooltip items
 				if (opts.filter) {
 					tooltipItems = tooltipItems.filter(function(a) {
 						return opts.filter(a, data);
 					});
 				}
 
 				// If the user provided a sorting function, use it to modify the tooltip items
 				if (opts.itemSort) {
 					tooltipItems = tooltipItems.sort(function(a, b) {
 						return opts.itemSort(a, b, data);
 					});
 				}
 
 				// Determine colors for boxes
 				helpers.each(tooltipItems, function(tooltipItem) {
 					labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
 					labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
 				});
 
 
 				// Build the Text Lines
 				model.title = me.getTitle(tooltipItems, data);
 				model.beforeBody = me.getBeforeBody(tooltipItems, data);
 				model.body = me.getBody(tooltipItems, data);
 				model.afterBody = me.getAfterBody(tooltipItems, data);
 				model.footer = me.getFooter(tooltipItems, data);
 
 				// Initial positioning and colors
 				model.x = Math.round(tooltipPosition.x);
 				model.y = Math.round(tooltipPosition.y);
 				model.caretPadding = opts.caretPadding;
 				model.labelColors = labelColors;
 				model.labelTextColors = labelTextColors;
 
 				// data points
 				model.dataPoints = tooltipItems;
 
 				// We need to determine alignment of the tooltip
 				tooltipSize = getTooltipSize(this, model);
 				alignment = determineAlignment(this, tooltipSize);
 				// Final Size and Position
 				backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
 			} else {
 				model.opacity = 0;
 			}
 
 			model.xAlign = alignment.xAlign;
 			model.yAlign = alignment.yAlign;
 			model.x = backgroundPoint.x;
 			model.y = backgroundPoint.y;
 			model.width = tooltipSize.width;
 			model.height = tooltipSize.height;
 
 			// Point where the caret on the tooltip points to
 			model.caretX = tooltipPosition.x;
 			model.caretY = tooltipPosition.y;
 
 			me._model = model;
 
 			if (changed && opts.custom) {
 				opts.custom.call(me, model);
 			}
 
 			return me;
 		},
 		drawCaret: function(tooltipPoint, size) {
 			var ctx = this._chart.ctx;
 			var vm = this._view;
 			var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
 
 			ctx.lineTo(caretPosition.x1, caretPosition.y1);
 			ctx.lineTo(caretPosition.x2, caretPosition.y2);
 			ctx.lineTo(caretPosition.x3, caretPosition.y3);
 		},
 		getCaretPosition: function(tooltipPoint, size, vm) {
 			var x1, x2, x3, y1, y2, y3;
 			var caretSize = vm.caretSize;
 			var cornerRadius = vm.cornerRadius;
 			var xAlign = vm.xAlign;
 			var yAlign = vm.yAlign;
 			var ptX = tooltipPoint.x;
 			var ptY = tooltipPoint.y;
 			var width = size.width;
 			var height = size.height;
 
 			if (yAlign === 'center') {
 				y2 = ptY + (height / 2);
 
 				if (xAlign === 'left') {
 					x1 = ptX;
 					x2 = x1 - caretSize;
 					x3 = x1;
 
 					y1 = y2 + caretSize;
 					y3 = y2 - caretSize;
 				} else {
 					x1 = ptX + width;
 					x2 = x1 + caretSize;
 					x3 = x1;
 
 					y1 = y2 - caretSize;
 					y3 = y2 + caretSize;
 				}
 			} else {
 				if (xAlign === 'left') {
 					x2 = ptX + cornerRadius + (caretSize);
 					x1 = x2 - caretSize;
 					x3 = x2 + caretSize;
 				} else if (xAlign === 'right') {
 					x2 = ptX + width - cornerRadius - caretSize;
 					x1 = x2 - caretSize;
 					x3 = x2 + caretSize;
 				} else {
 					x2 = vm.caretX;
 					x1 = x2 - caretSize;
 					x3 = x2 + caretSize;
 				}
 				if (yAlign === 'top') {
 					y1 = ptY;
 					y2 = y1 - caretSize;
 					y3 = y1;
 				} else {
 					y1 = ptY + height;
 					y2 = y1 + caretSize;
 					y3 = y1;
 					// invert drawing order
 					var tmp = x3;
 					x3 = x1;
 					x1 = tmp;
 				}
 			}
 			return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
 		},
 		drawTitle: function(pt, vm, ctx, opacity) {
 			var title = vm.title;
 
 			if (title.length) {
 				ctx.textAlign = vm._titleAlign;
 				ctx.textBaseline = 'top';
 
 				var titleFontSize = vm.titleFontSize;
 				var titleSpacing = vm.titleSpacing;
 
 				ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
 				ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
 
 				var i, len;
 				for (i = 0, len = title.length; i < len; ++i) {
 					ctx.fillText(title[i], pt.x, pt.y);
 					pt.y += titleFontSize + titleSpacing; // Line Height and spacing
 
 					if (i + 1 === title.length) {
 						pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
 					}
 				}
 			}
 		},
 		drawBody: function(pt, vm, ctx, opacity) {
 			var bodyFontSize = vm.bodyFontSize;
 			var bodySpacing = vm.bodySpacing;
 			var body = vm.body;
 
 			ctx.textAlign = vm._bodyAlign;
 			ctx.textBaseline = 'top';
 			ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
 
 			// Before Body
 			var xLinePadding = 0;
 			var fillLineOfText = function(line) {
 				ctx.fillText(line, pt.x + xLinePadding, pt.y);
 				pt.y += bodyFontSize + bodySpacing;
 			};
 
 			// Before body lines
 			ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
 			helpers.each(vm.beforeBody, fillLineOfText);
 
 			var drawColorBoxes = vm.displayColors;
 			xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;
 
 			// Draw body lines now
 			helpers.each(body, function(bodyItem, i) {
 				var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
 				ctx.fillStyle = textColor;
 				helpers.each(bodyItem.before, fillLineOfText);
 
 				helpers.each(bodyItem.lines, function(line) {
 					// Draw Legend-like boxes if needed
 					if (drawColorBoxes) {
 						// Fill a white rect so that colours merge nicely if the opacity is < 1
 						ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
 						ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
 
 						// Border
 						ctx.lineWidth = 1;
 						ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
 						ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
 
 						// Inner square
 						ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
 						ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
 						ctx.fillStyle = textColor;
 					}
 
 					fillLineOfText(line);
 				});
 
 				helpers.each(bodyItem.after, fillLineOfText);
 			});
 
 			// Reset back to 0 for after body
 			xLinePadding = 0;
 
 			// After body lines
 			helpers.each(vm.afterBody, fillLineOfText);
 			pt.y -= bodySpacing; // Remove last body spacing
 		},
 		drawFooter: function(pt, vm, ctx, opacity) {
 			var footer = vm.footer;
 
 			if (footer.length) {
 				pt.y += vm.footerMarginTop;
 
 				ctx.textAlign = vm._footerAlign;
 				ctx.textBaseline = 'top';
 
 				ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
 				ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
 
 				helpers.each(footer, function(line) {
 					ctx.fillText(line, pt.x, pt.y);
 					pt.y += vm.footerFontSize + vm.footerSpacing;
 				});
 			}
 		},
 		drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
 			ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
 			ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
 			ctx.lineWidth = vm.borderWidth;
 			var xAlign = vm.xAlign;
 			var yAlign = vm.yAlign;
 			var x = pt.x;
 			var y = pt.y;
 			var width = tooltipSize.width;
 			var height = tooltipSize.height;
 			var radius = vm.cornerRadius;
 
 			ctx.beginPath();
 			ctx.moveTo(x + radius, y);
 			if (yAlign === 'top') {
 				this.drawCaret(pt, tooltipSize);
 			}
 			ctx.lineTo(x + width - radius, y);
 			ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
 			if (yAlign === 'center' && xAlign === 'right') {
 				this.drawCaret(pt, tooltipSize);
 			}
 			ctx.lineTo(x + width, y + height - radius);
 			ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
 			if (yAlign === 'bottom') {
 				this.drawCaret(pt, tooltipSize);
 			}
 			ctx.lineTo(x + radius, y + height);
 			ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
 			if (yAlign === 'center' && xAlign === 'left') {
 				this.drawCaret(pt, tooltipSize);
 			}
 			ctx.lineTo(x, y + radius);
 			ctx.quadraticCurveTo(x, y, x + radius, y);
 			ctx.closePath();
 
 			ctx.fill();
 
 			if (vm.borderWidth > 0) {
 				ctx.stroke();
 			}
 		},
 		draw: function() {
 			var ctx = this._chart.ctx;
 			var vm = this._view;
 
 			if (vm.opacity === 0) {
 				return;
 			}
 
 			var tooltipSize = {
 				width: vm.width,
 				height: vm.height
 			};
 			var pt = {
 				x: vm.x,
 				y: vm.y
 			};
 
 			// IE11/Edge does not like very small opacities, so snap to 0
 			var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
 
 			// Truthy/falsey value for empty tooltip
 			var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
 
 			if (this._options.enabled && hasTooltipContent) {
 				// Draw Background
 				this.drawBackground(pt, vm, ctx, tooltipSize, opacity);
 
 				// Draw Title, Body, and Footer
 				pt.x += vm.xPadding;
 				pt.y += vm.yPadding;
 
 				// Titles
 				this.drawTitle(pt, vm, ctx, opacity);
 
 				// Body
 				this.drawBody(pt, vm, ctx, opacity);
 
 				// Footer
 				this.drawFooter(pt, vm, ctx, opacity);
 			}
 		},
 
 		/**
 		 * Handle an event
 		 * @private
 		 * @param {IEvent} event - The event to handle
 		 * @returns {Boolean} true if the tooltip changed
 		 */
 		handleEvent: function(e) {
 			var me = this;
 			var options = me._options;
 			var changed = false;
 
 			me._lastActive = me._lastActive || [];
 
 			// Find Active Elements for tooltips
 			if (e.type === 'mouseout') {
 				me._active = [];
 			} else {
 				me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
 			}
 
 			// Remember Last Actives
 			changed = !helpers.arrayEquals(me._active, me._lastActive);
 
 			// Only handle target event on tooltip change
 			if (changed) {
 				me._lastActive = me._active;
 
 				if (options.enabled || options.custom) {
 					me._eventPosition = {
 						x: e.x,
 						y: e.y
 					};
 
 					me.update(true);
 					me.pivot();
 				}
 			}
 
 			return changed;
 		}
 	});
 
 	/**
 	 * @namespace Chart.Tooltip.positioners
 	 */
 	Chart.Tooltip.positioners = {
 		/**
 		 * Average mode places the tooltip at the average position of the elements shown
 		 * @function Chart.Tooltip.positioners.average
 		 * @param elements {ChartElement[]} the elements being displayed in the tooltip
 		 * @returns {Point} tooltip position
 		 */
 		average: function(elements) {
 			if (!elements.length) {
 				return false;
 			}
 
 			var i, len;
 			var x = 0;
 			var y = 0;
 			var count = 0;
 
 			for (i = 0, len = elements.length; i < len; ++i) {
 				var el = elements[i];
 				if (el && el.hasValue()) {
 					var pos = el.tooltipPosition();
 					x += pos.x;
 					y += pos.y;
 					++count;
 				}
 			}
 
 			return {
 				x: Math.round(x / count),
 				y: Math.round(y / count)
 			};
 		},
 
 		/**
 		 * Gets the tooltip position nearest of the item nearest to the event position
 		 * @function Chart.Tooltip.positioners.nearest
 		 * @param elements {Chart.Element[]} the tooltip elements
 		 * @param eventPosition {Point} the position of the event in canvas coordinates
 		 * @returns {Point} the tooltip position
 		 */
 		nearest: function(elements, eventPosition) {
 			var x = eventPosition.x;
 			var y = eventPosition.y;
 			var minDistance = Number.POSITIVE_INFINITY;
 			var i, len, nearestElement;
 
 			for (i = 0, len = elements.length; i < len; ++i) {
 				var el = elements[i];
 				if (el && el.hasValue()) {
 					var center = el.getCenterPoint();
 					var d = helpers.distanceBetweenPoints(eventPosition, center);
 
 					if (d < minDistance) {
 						minDistance = d;
 						nearestElement = el;
 					}
 				}
 			}
 
 			if (nearestElement) {
 				var tp = nearestElement.tooltipPosition();
 				x = tp.x;
 				y = tp.y;
 			}
 
 			return {
 				x: x,
 				y: y
 			};
 		}
 	};
 };
 
 },{"25":25,"26":26,"45":45}],36:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 
 defaults._set('global', {
 	elements: {
 		arc: {
 			backgroundColor: defaults.global.defaultColor,
 			borderColor: '#fff',
 			borderWidth: 2
 		}
 	}
 });
 
 module.exports = Element.extend({
 	inLabelRange: function(mouseX) {
 		var vm = this._view;
 
 		if (vm) {
 			return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
 		}
 		return false;
 	},
 
 	inRange: function(chartX, chartY) {
 		var vm = this._view;
 
 		if (vm) {
 			var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
 			var	angle = pointRelativePosition.angle;
 			var distance = pointRelativePosition.distance;
 
 			// Sanitise angle range
 			var startAngle = vm.startAngle;
 			var endAngle = vm.endAngle;
 			while (endAngle < startAngle) {
 				endAngle += 2.0 * Math.PI;
 			}
 			while (angle > endAngle) {
 				angle -= 2.0 * Math.PI;
 			}
 			while (angle < startAngle) {
 				angle += 2.0 * Math.PI;
 			}
 
 			// Check if within the range of the open/close angle
 			var betweenAngles = (angle >= startAngle && angle <= endAngle);
 			var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);
 
 			return (betweenAngles && withinRadius);
 		}
 		return false;
 	},
 
 	getCenterPoint: function() {
 		var vm = this._view;
 		var halfAngle = (vm.startAngle + vm.endAngle) / 2;
 		var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
 		return {
 			x: vm.x + Math.cos(halfAngle) * halfRadius,
 			y: vm.y + Math.sin(halfAngle) * halfRadius
 		};
 	},
 
 	getArea: function() {
 		var vm = this._view;
 		return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
 	},
 
 	tooltipPosition: function() {
 		var vm = this._view;
 		var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
 		var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
 
 		return {
 			x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
 			y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
 		};
 	},
 
 	draw: function() {
 		var ctx = this._chart.ctx;
 		var vm = this._view;
 		var sA = vm.startAngle;
 		var eA = vm.endAngle;
 
 		ctx.beginPath();
 
 		ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
 		ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
 
 		ctx.closePath();
 		ctx.strokeStyle = vm.borderColor;
 		ctx.lineWidth = vm.borderWidth;
 
 		ctx.fillStyle = vm.backgroundColor;
 
 		ctx.fill();
 		ctx.lineJoin = 'bevel';
 
 		if (vm.borderWidth) {
 			ctx.stroke();
 		}
 	}
 });
 
 },{"25":25,"26":26,"45":45}],37:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 
 var globalDefaults = defaults.global;
 
 defaults._set('global', {
 	elements: {
 		line: {
 			tension: 0.4,
 			backgroundColor: globalDefaults.defaultColor,
 			borderWidth: 3,
 			borderColor: globalDefaults.defaultColor,
 			borderCapStyle: 'butt',
 			borderDash: [],
 			borderDashOffset: 0.0,
 			borderJoinStyle: 'miter',
 			capBezierPoints: true,
 			fill: true, // do we fill in the area between the line and its base axis
 		}
 	}
 });
 
 module.exports = Element.extend({
 	draw: function() {
 		var me = this;
 		var vm = me._view;
 		var ctx = me._chart.ctx;
 		var spanGaps = vm.spanGaps;
 		var points = me._children.slice(); // clone array
 		var globalOptionLineElements = globalDefaults.elements.line;
 		var lastDrawnIndex = -1;
 		var index, current, previous, currentVM;
 
 		// If we are looping, adding the first point again
 		if (me._loop && points.length) {
 			points.push(points[0]);
 		}
 
 		ctx.save();
 
 		// Stroke Line Options
 		ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
 
 		// IE 9 and 10 do not support line dash
 		if (ctx.setLineDash) {
 			ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
 		}
 
 		ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
 		ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
 		ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
 		ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
 
 		// Stroke Line
 		ctx.beginPath();
 		lastDrawnIndex = -1;
 
 		for (index = 0; index < points.length; ++index) {
 			current = points[index];
 			previous = helpers.previousItem(points, index);
 			currentVM = current._view;
 
 			// First point moves to it's starting position no matter what
 			if (index === 0) {
 				if (!currentVM.skip) {
 					ctx.moveTo(currentVM.x, currentVM.y);
 					lastDrawnIndex = index;
 				}
 			} else {
 				previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
 
 				if (!currentVM.skip) {
 					if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
 						// There was a gap and this is the first point after the gap
 						ctx.moveTo(currentVM.x, currentVM.y);
 					} else {
 						// Line to next point
 						helpers.canvas.lineTo(ctx, previous._view, current._view);
 					}
 					lastDrawnIndex = index;
 				}
 			}
 		}
 
 		ctx.stroke();
 		ctx.restore();
 	}
 });
 
 },{"25":25,"26":26,"45":45}],38:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 
 var defaultColor = defaults.global.defaultColor;
 
 defaults._set('global', {
 	elements: {
 		point: {
 			radius: 3,
 			pointStyle: 'circle',
 			backgroundColor: defaultColor,
 			borderColor: defaultColor,
 			borderWidth: 1,
 			// Hover
 			hitRadius: 1,
 			hoverRadius: 4,
 			hoverBorderWidth: 1
 		}
 	}
 });
 
 function xRange(mouseX) {
 	var vm = this._view;
 	return vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;
 }
 
 function yRange(mouseY) {
 	var vm = this._view;
 	return vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;
 }
 
 module.exports = Element.extend({
 	inRange: function(mouseX, mouseY) {
 		var vm = this._view;
 		return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
 	},
 
 	inLabelRange: xRange,
 	inXRange: xRange,
 	inYRange: yRange,
 
 	getCenterPoint: function() {
 		var vm = this._view;
 		return {
 			x: vm.x,
 			y: vm.y
 		};
 	},
 
 	getArea: function() {
 		return Math.PI * Math.pow(this._view.radius, 2);
 	},
 
 	tooltipPosition: function() {
 		var vm = this._view;
 		return {
 			x: vm.x,
 			y: vm.y,
 			padding: vm.radius + vm.borderWidth
 		};
 	},
 
 	draw: function(chartArea) {
 		var vm = this._view;
 		var model = this._model;
 		var ctx = this._chart.ctx;
 		var pointStyle = vm.pointStyle;
 		var radius = vm.radius;
 		var x = vm.x;
 		var y = vm.y;
 		var color = helpers.color;
 		var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
 		var ratio = 0;
 
 		if (vm.skip) {
 			return;
 		}
 
 		ctx.strokeStyle = vm.borderColor || defaultColor;
 		ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
 		ctx.fillStyle = vm.backgroundColor || defaultColor;
 
 		// Cliping for Points.
 		// going out from inner charArea?
 		if ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {
 			// Point fade out
 			if (model.x < chartArea.left) {
 				ratio = (x - model.x) / (chartArea.left - model.x);
 			} else if (chartArea.right * errMargin < model.x) {
 				ratio = (model.x - x) / (model.x - chartArea.right);
 			} else if (model.y < chartArea.top) {
 				ratio = (y - model.y) / (chartArea.top - model.y);
 			} else if (chartArea.bottom * errMargin < model.y) {
 				ratio = (model.y - y) / (model.y - chartArea.bottom);
 			}
 			ratio = Math.round(ratio * 100) / 100;
 			ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
 			ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
 		}
 
 		helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
 	}
 });
 
 },{"25":25,"26":26,"45":45}],39:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 
 defaults._set('global', {
 	elements: {
 		rectangle: {
 			backgroundColor: defaults.global.defaultColor,
 			borderColor: defaults.global.defaultColor,
 			borderSkipped: 'bottom',
 			borderWidth: 0
 		}
 	}
 });
 
 function isVertical(bar) {
 	return bar._view.width !== undefined;
 }
 
 /**
  * Helper function to get the bounds of the bar regardless of the orientation
  * @param bar {Chart.Element.Rectangle} the bar
  * @return {Bounds} bounds of the bar
  * @private
  */
 function getBarBounds(bar) {
 	var vm = bar._view;
 	var x1, x2, y1, y2;
 
 	if (isVertical(bar)) {
 		// vertical
 		var halfWidth = vm.width / 2;
 		x1 = vm.x - halfWidth;
 		x2 = vm.x + halfWidth;
 		y1 = Math.min(vm.y, vm.base);
 		y2 = Math.max(vm.y, vm.base);
 	} else {
 		// horizontal bar
 		var halfHeight = vm.height / 2;
 		x1 = Math.min(vm.x, vm.base);
 		x2 = Math.max(vm.x, vm.base);
 		y1 = vm.y - halfHeight;
 		y2 = vm.y + halfHeight;
 	}
 
 	return {
 		left: x1,
 		top: y1,
 		right: x2,
 		bottom: y2
 	};
 }
 
 module.exports = Element.extend({
 	draw: function() {
 		var ctx = this._chart.ctx;
 		var vm = this._view;
 		var left, right, top, bottom, signX, signY, borderSkipped;
 		var borderWidth = vm.borderWidth;
 
 		if (!vm.horizontal) {
 			// bar
 			left = vm.x - vm.width / 2;
 			right = vm.x + vm.width / 2;
 			top = vm.y;
 			bottom = vm.base;
 			signX = 1;
 			signY = bottom > top ? 1 : -1;
 			borderSkipped = vm.borderSkipped || 'bottom';
 		} else {
 			// horizontal bar
 			left = vm.base;
 			right = vm.x;
 			top = vm.y - vm.height / 2;
 			bottom = vm.y + vm.height / 2;
 			signX = right > left ? 1 : -1;
 			signY = 1;
 			borderSkipped = vm.borderSkipped || 'left';
 		}
 
 		// Canvas doesn't allow us to stroke inside the width so we can
 		// adjust the sizes to fit if we're setting a stroke on the line
 		if (borderWidth) {
 			// borderWidth shold be less than bar width and bar height.
 			var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
 			borderWidth = borderWidth > barSize ? barSize : borderWidth;
 			var halfStroke = borderWidth / 2;
 			// Adjust borderWidth when bar top position is near vm.base(zero).
 			var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
 			var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
 			var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
 			var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
 			// not become a vertical line?
 			if (borderLeft !== borderRight) {
 				top = borderTop;
 				bottom = borderBottom;
 			}
 			// not become a horizontal line?
 			if (borderTop !== borderBottom) {
 				left = borderLeft;
 				right = borderRight;
 			}
 		}
 
 		ctx.beginPath();
 		ctx.fillStyle = vm.backgroundColor;
 		ctx.strokeStyle = vm.borderColor;
 		ctx.lineWidth = borderWidth;
 
 		// Corner points, from bottom-left to bottom-right clockwise
 		// | 1 2 |
 		// | 0 3 |
 		var corners = [
 			[left, bottom],
 			[left, top],
 			[right, top],
 			[right, bottom]
 		];
 
 		// Find first (starting) corner with fallback to 'bottom'
 		var borders = ['bottom', 'left', 'top', 'right'];
 		var startCorner = borders.indexOf(borderSkipped, 0);
 		if (startCorner === -1) {
 			startCorner = 0;
 		}
 
 		function cornerAt(index) {
 			return corners[(startCorner + index) % 4];
 		}
 
 		// Draw rectangle from 'startCorner'
 		var corner = cornerAt(0);
 		ctx.moveTo(corner[0], corner[1]);
 
 		for (var i = 1; i < 4; i++) {
 			corner = cornerAt(i);
 			ctx.lineTo(corner[0], corner[1]);
 		}
 
 		ctx.fill();
 		if (borderWidth) {
 			ctx.stroke();
 		}
 	},
 
 	height: function() {
 		var vm = this._view;
 		return vm.base - vm.y;
 	},
 
 	inRange: function(mouseX, mouseY) {
 		var inRange = false;
 
 		if (this._view) {
 			var bounds = getBarBounds(this);
 			inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
 		}
 
 		return inRange;
 	},
 
 	inLabelRange: function(mouseX, mouseY) {
 		var me = this;
 		if (!me._view) {
 			return false;
 		}
 
 		var inRange = false;
 		var bounds = getBarBounds(me);
 
 		if (isVertical(me)) {
 			inRange = mouseX >= bounds.left && mouseX <= bounds.right;
 		} else {
 			inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
 		}
 
 		return inRange;
 	},
 
 	inXRange: function(mouseX) {
 		var bounds = getBarBounds(this);
 		return mouseX >= bounds.left && mouseX <= bounds.right;
 	},
 
 	inYRange: function(mouseY) {
 		var bounds = getBarBounds(this);
 		return mouseY >= bounds.top && mouseY <= bounds.bottom;
 	},
 
 	getCenterPoint: function() {
 		var vm = this._view;
 		var x, y;
 		if (isVertical(this)) {
 			x = vm.x;
 			y = (vm.y + vm.base) / 2;
 		} else {
 			x = (vm.x + vm.base) / 2;
 			y = vm.y;
 		}
 
 		return {x: x, y: y};
 	},
 
 	getArea: function() {
 		var vm = this._view;
 		return vm.width * Math.abs(vm.y - vm.base);
 	},
 
 	tooltipPosition: function() {
 		var vm = this._view;
 		return {
 			x: vm.x,
 			y: vm.y
 		};
 	}
 });
 
 },{"25":25,"26":26}],40:[function(require,module,exports){
 'use strict';
 
 module.exports = {};
 module.exports.Arc = require(36);
 module.exports.Line = require(37);
 module.exports.Point = require(38);
 module.exports.Rectangle = require(39);
 
 },{"36":36,"37":37,"38":38,"39":39}],41:[function(require,module,exports){
 'use strict';
 
 var helpers = require(42);
 
 /**
  * @namespace Chart.helpers.canvas
  */
 var exports = module.exports = {
 	/**
 	 * Clears the entire canvas associated to the given `chart`.
 	 * @param {Chart} chart - The chart for which to clear the canvas.
 	 */
 	clear: function(chart) {
 		chart.ctx.clearRect(0, 0, chart.width, chart.height);
 	},
 
 	/**
 	 * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
 	 * given size (width, height) and the same `radius` for all corners.
 	 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
 	 * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
 	 * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
 	 * @param {Number} width - The rectangle's width.
 	 * @param {Number} height - The rectangle's height.
 	 * @param {Number} radius - The rounded amount (in pixels) for the four corners.
 	 * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
 	 */
 	roundedRect: function(ctx, x, y, width, height, radius) {
 		if (radius) {
 			var rx = Math.min(radius, width / 2);
 			var ry = Math.min(radius, height / 2);
 
 			ctx.moveTo(x + rx, y);
 			ctx.lineTo(x + width - rx, y);
 			ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
 			ctx.lineTo(x + width, y + height - ry);
 			ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
 			ctx.lineTo(x + rx, y + height);
 			ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
 			ctx.lineTo(x, y + ry);
 			ctx.quadraticCurveTo(x, y, x + rx, y);
 		} else {
 			ctx.rect(x, y, width, height);
 		}
 	},
 
 	drawPoint: function(ctx, style, radius, x, y) {
 		var type, edgeLength, xOffset, yOffset, height, size;
 
 		if (style && typeof style === 'object') {
 			type = style.toString();
 			if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
 				ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
 				return;
 			}
 		}
 
 		if (isNaN(radius) || radius <= 0) {
 			return;
 		}
 
 		switch (style) {
 		// Default includes circle
 		default:
 			ctx.beginPath();
 			ctx.arc(x, y, radius, 0, Math.PI * 2);
 			ctx.closePath();
 			ctx.fill();
 			break;
 		case 'triangle':
 			ctx.beginPath();
 			edgeLength = 3 * radius / Math.sqrt(3);
 			height = edgeLength * Math.sqrt(3) / 2;
 			ctx.moveTo(x - edgeLength / 2, y + height / 3);
 			ctx.lineTo(x + edgeLength / 2, y + height / 3);
 			ctx.lineTo(x, y - 2 * height / 3);
 			ctx.closePath();
 			ctx.fill();
 			break;
 		case 'rect':
 			size = 1 / Math.SQRT2 * radius;
 			ctx.beginPath();
 			ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
 			ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
 			break;
 		case 'rectRounded':
 			var offset = radius / Math.SQRT2;
 			var leftX = x - offset;
 			var topY = y - offset;
 			var sideSize = Math.SQRT2 * radius;
 			ctx.beginPath();
 			this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
 			ctx.closePath();
 			ctx.fill();
 			break;
 		case 'rectRot':
 			size = 1 / Math.SQRT2 * radius;
 			ctx.beginPath();
 			ctx.moveTo(x - size, y);
 			ctx.lineTo(x, y + size);
 			ctx.lineTo(x + size, y);
 			ctx.lineTo(x, y - size);
 			ctx.closePath();
 			ctx.fill();
 			break;
 		case 'cross':
 			ctx.beginPath();
 			ctx.moveTo(x, y + radius);
 			ctx.lineTo(x, y - radius);
 			ctx.moveTo(x - radius, y);
 			ctx.lineTo(x + radius, y);
 			ctx.closePath();
 			break;
 		case 'crossRot':
 			ctx.beginPath();
 			xOffset = Math.cos(Math.PI / 4) * radius;
 			yOffset = Math.sin(Math.PI / 4) * radius;
 			ctx.moveTo(x - xOffset, y - yOffset);
 			ctx.lineTo(x + xOffset, y + yOffset);
 			ctx.moveTo(x - xOffset, y + yOffset);
 			ctx.lineTo(x + xOffset, y - yOffset);
 			ctx.closePath();
 			break;
 		case 'star':
 			ctx.beginPath();
 			ctx.moveTo(x, y + radius);
 			ctx.lineTo(x, y - radius);
 			ctx.moveTo(x - radius, y);
 			ctx.lineTo(x + radius, y);
 			xOffset = Math.cos(Math.PI / 4) * radius;
 			yOffset = Math.sin(Math.PI / 4) * radius;
 			ctx.moveTo(x - xOffset, y - yOffset);
 			ctx.lineTo(x + xOffset, y + yOffset);
 			ctx.moveTo(x - xOffset, y + yOffset);
 			ctx.lineTo(x + xOffset, y - yOffset);
 			ctx.closePath();
 			break;
 		case 'line':
 			ctx.beginPath();
 			ctx.moveTo(x - radius, y);
 			ctx.lineTo(x + radius, y);
 			ctx.closePath();
 			break;
 		case 'dash':
 			ctx.beginPath();
 			ctx.moveTo(x, y);
 			ctx.lineTo(x + radius, y);
 			ctx.closePath();
 			break;
 		}
 
 		ctx.stroke();
 	},
 
 	clipArea: function(ctx, area) {
 		ctx.save();
 		ctx.beginPath();
 		ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
 		ctx.clip();
 	},
 
 	unclipArea: function(ctx) {
 		ctx.restore();
 	},
 
 	lineTo: function(ctx, previous, target, flip) {
 		if (target.steppedLine) {
 			if ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {
 				ctx.lineTo(previous.x, target.y);
 			} else {
 				ctx.lineTo(target.x, previous.y);
 			}
 			ctx.lineTo(target.x, target.y);
 			return;
 		}
 
 		if (!target.tension) {
 			ctx.lineTo(target.x, target.y);
 			return;
 		}
 
 		ctx.bezierCurveTo(
 			flip ? previous.controlPointPreviousX : previous.controlPointNextX,
 			flip ? previous.controlPointPreviousY : previous.controlPointNextY,
 			flip ? target.controlPointNextX : target.controlPointPreviousX,
 			flip ? target.controlPointNextY : target.controlPointPreviousY,
 			target.x,
 			target.y);
 	}
 };
 
 // DEPRECATIONS
 
 /**
  * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
  * @namespace Chart.helpers.clear
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.clear = exports.clear;
 
 /**
  * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
  * @namespace Chart.helpers.drawRoundedRectangle
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.drawRoundedRectangle = function(ctx) {
 	ctx.beginPath();
 	exports.roundedRect.apply(exports, arguments);
 	ctx.closePath();
 };
 
 },{"42":42}],42:[function(require,module,exports){
 'use strict';
 
 /**
  * @namespace Chart.helpers
  */
 var helpers = {
 	/**
 	 * An empty function that can be used, for example, for optional callback.
 	 */
 	noop: function() {},
 
 	/**
 	 * Returns a unique id, sequentially generated from a global variable.
 	 * @returns {Number}
 	 * @function
 	 */
 	uid: (function() {
 		var id = 0;
 		return function() {
 			return id++;
 		};
 	}()),
 
 	/**
 	 * Returns true if `value` is neither null nor undefined, else returns false.
 	 * @param {*} value - The value to test.
 	 * @returns {Boolean}
 	 * @since 2.7.0
 	 */
 	isNullOrUndef: function(value) {
 		return value === null || typeof value === 'undefined';
 	},
 
 	/**
 	 * Returns true if `value` is an array, else returns false.
 	 * @param {*} value - The value to test.
 	 * @returns {Boolean}
 	 * @function
 	 */
 	isArray: Array.isArray ? Array.isArray : function(value) {
 		return Object.prototype.toString.call(value) === '[object Array]';
 	},
 
 	/**
 	 * Returns true if `value` is an object (excluding null), else returns false.
 	 * @param {*} value - The value to test.
 	 * @returns {Boolean}
 	 * @since 2.7.0
 	 */
 	isObject: function(value) {
 		return value !== null && Object.prototype.toString.call(value) === '[object Object]';
 	},
 
 	/**
 	 * Returns `value` if defined, else returns `defaultValue`.
 	 * @param {*} value - The value to return if defined.
 	 * @param {*} defaultValue - The value to return if `value` is undefined.
 	 * @returns {*}
 	 */
 	valueOrDefault: function(value, defaultValue) {
 		return typeof value === 'undefined' ? defaultValue : value;
 	},
 
 	/**
 	 * Returns value at the given `index` in array if defined, else returns `defaultValue`.
 	 * @param {Array} value - The array to lookup for value at `index`.
 	 * @param {Number} index - The index in `value` to lookup for value.
 	 * @param {*} defaultValue - The value to return if `value[index]` is undefined.
 	 * @returns {*}
 	 */
 	valueAtIndexOrDefault: function(value, index, defaultValue) {
 		return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
 	},
 
 	/**
 	 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 	 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 	 * @param {Function} fn - The function to call.
 	 * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
 	 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
 	 * @returns {*}
 	 */
 	callback: function(fn, args, thisArg) {
 		if (fn && typeof fn.call === 'function') {
 			return fn.apply(thisArg, args);
 		}
 	},
 
 	/**
 	 * Note(SB) for performance sake, this method should only be used when loopable type
 	 * is unknown or in none intensive code (not called often and small loopable). Else
 	 * it's preferable to use a regular for() loop and save extra function calls.
 	 * @param {Object|Array} loopable - The object or array to be iterated.
 	 * @param {Function} fn - The function to call for each item.
 	 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
 	 * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
 	 */
 	each: function(loopable, fn, thisArg, reverse) {
 		var i, len, keys;
 		if (helpers.isArray(loopable)) {
 			len = loopable.length;
 			if (reverse) {
 				for (i = len - 1; i >= 0; i--) {
 					fn.call(thisArg, loopable[i], i);
 				}
 			} else {
 				for (i = 0; i < len; i++) {
 					fn.call(thisArg, loopable[i], i);
 				}
 			}
 		} else if (helpers.isObject(loopable)) {
 			keys = Object.keys(loopable);
 			len = keys.length;
 			for (i = 0; i < len; i++) {
 				fn.call(thisArg, loopable[keys[i]], keys[i]);
 			}
 		}
 	},
 
 	/**
 	 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 	 * @see http://stackoverflow.com/a/14853974
 	 * @param {Array} a0 - The array to compare
 	 * @param {Array} a1 - The array to compare
 	 * @returns {Boolean}
 	 */
 	arrayEquals: function(a0, a1) {
 		var i, ilen, v0, v1;
 
 		if (!a0 || !a1 || a0.length !== a1.length) {
 			return false;
 		}
 
 		for (i = 0, ilen = a0.length; i < ilen; ++i) {
 			v0 = a0[i];
 			v1 = a1[i];
 
 			if (v0 instanceof Array && v1 instanceof Array) {
 				if (!helpers.arrayEquals(v0, v1)) {
 					return false;
 				}
 			} else if (v0 !== v1) {
 				// NOTE: two different object instances will never be equal: {x:20} != {x:20}
 				return false;
 			}
 		}
 
 		return true;
 	},
 
 	/**
 	 * Returns a deep copy of `source` without keeping references on objects and arrays.
 	 * @param {*} source - The value to clone.
 	 * @returns {*}
 	 */
 	clone: function(source) {
 		if (helpers.isArray(source)) {
 			return source.map(helpers.clone);
 		}
 
 		if (helpers.isObject(source)) {
 			var target = {};
 			var keys = Object.keys(source);
 			var klen = keys.length;
 			var k = 0;
 
 			for (; k < klen; ++k) {
 				target[keys[k]] = helpers.clone(source[keys[k]]);
 			}
 
 			return target;
 		}
 
 		return source;
 	},
 
 	/**
 	 * The default merger when Chart.helpers.merge is called without merger option.
 	 * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
 	 * @private
 	 */
 	_merger: function(key, target, source, options) {
 		var tval = target[key];
 		var sval = source[key];
 
 		if (helpers.isObject(tval) && helpers.isObject(sval)) {
 			helpers.merge(tval, sval, options);
 		} else {
 			target[key] = helpers.clone(sval);
 		}
 	},
 
 	/**
 	 * Merges source[key] in target[key] only if target[key] is undefined.
 	 * @private
 	 */
 	_mergerIf: function(key, target, source) {
 		var tval = target[key];
 		var sval = source[key];
 
 		if (helpers.isObject(tval) && helpers.isObject(sval)) {
 			helpers.mergeIf(tval, sval);
 		} else if (!target.hasOwnProperty(key)) {
 			target[key] = helpers.clone(sval);
 		}
 	},
 
 	/**
 	 * Recursively deep copies `source` properties into `target` with the given `options`.
 	 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
 	 * @param {Object} target - The target object in which all sources are merged into.
 	 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
 	 * @param {Object} [options] - Merging options:
 	 * @param {Function} [options.merger] - The merge method (key, target, source, options)
 	 * @returns {Object} The `target` object.
 	 */
 	merge: function(target, source, options) {
 		var sources = helpers.isArray(source) ? source : [source];
 		var ilen = sources.length;
 		var merge, i, keys, klen, k;
 
 		if (!helpers.isObject(target)) {
 			return target;
 		}
 
 		options = options || {};
 		merge = options.merger || helpers._merger;
 
 		for (i = 0; i < ilen; ++i) {
 			source = sources[i];
 			if (!helpers.isObject(source)) {
 				continue;
 			}
 
 			keys = Object.keys(source);
 			for (k = 0, klen = keys.length; k < klen; ++k) {
 				merge(keys[k], target, source, options);
 			}
 		}
 
 		return target;
 	},
 
 	/**
 	 * Recursively deep copies `source` properties into `target` *only* if not defined in target.
 	 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
 	 * @param {Object} target - The target object in which all sources are merged into.
 	 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
 	 * @returns {Object} The `target` object.
 	 */
 	mergeIf: function(target, source) {
 		return helpers.merge(target, source, {merger: helpers._mergerIf});
 	},
 
 	/**
 	 * Applies the contents of two or more objects together into the first object.
 	 * @param {Object} target - The target object in which all objects are merged into.
 	 * @param {Object} arg1 - Object containing additional properties to merge in target.
 	 * @param {Object} argN - Additional objects containing properties to merge in target.
 	 * @returns {Object} The `target` object.
 	 */
 	extend: function(target) {
 		var setFn = function(value, key) {
 			target[key] = value;
 		};
 		for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
 			helpers.each(arguments[i], setFn);
 		}
 		return target;
 	},
 
 	/**
 	 * Basic javascript inheritance based on the model created in Backbone.js
 	 */
 	inherits: function(extensions) {
 		var me = this;
 		var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
 			return me.apply(this, arguments);
 		};
 
 		var Surrogate = function() {
 			this.constructor = ChartElement;
 		};
 
 		Surrogate.prototype = me.prototype;
 		ChartElement.prototype = new Surrogate();
 		ChartElement.extend = helpers.inherits;
 
 		if (extensions) {
 			helpers.extend(ChartElement.prototype, extensions);
 		}
 
 		ChartElement.__super__ = me.prototype;
 		return ChartElement;
 	}
 };
 
 module.exports = helpers;
 
 // DEPRECATIONS
 
 /**
  * Provided for backward compatibility, use Chart.helpers.callback instead.
  * @function Chart.helpers.callCallback
  * @deprecated since version 2.6.0
  * @todo remove at version 3
  * @private
  */
 helpers.callCallback = helpers.callback;
 
 /**
  * Provided for backward compatibility, use Array.prototype.indexOf instead.
  * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
  * @function Chart.helpers.indexOf
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.indexOf = function(array, item, fromIndex) {
 	return Array.prototype.indexOf.call(array, item, fromIndex);
 };
 
 /**
  * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
  * @function Chart.helpers.getValueOrDefault
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.getValueOrDefault = helpers.valueOrDefault;
 
 /**
  * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
  * @function Chart.helpers.getValueAtIndexOrDefault
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
 
 },{}],43:[function(require,module,exports){
 'use strict';
 
 var helpers = require(42);
 
 /**
  * Easing functions adapted from Robert Penner's easing equations.
  * @namespace Chart.helpers.easingEffects
  * @see http://www.robertpenner.com/easing/
  */
 var effects = {
 	linear: function(t) {
 		return t;
 	},
 
 	easeInQuad: function(t) {
 		return t * t;
 	},
 
 	easeOutQuad: function(t) {
 		return -t * (t - 2);
 	},
 
 	easeInOutQuad: function(t) {
 		if ((t /= 0.5) < 1) {
 			return 0.5 * t * t;
 		}
 		return -0.5 * ((--t) * (t - 2) - 1);
 	},
 
 	easeInCubic: function(t) {
 		return t * t * t;
 	},
 
 	easeOutCubic: function(t) {
 		return (t = t - 1) * t * t + 1;
 	},
 
 	easeInOutCubic: function(t) {
 		if ((t /= 0.5) < 1) {
 			return 0.5 * t * t * t;
 		}
 		return 0.5 * ((t -= 2) * t * t + 2);
 	},
 
 	easeInQuart: function(t) {
 		return t * t * t * t;
 	},
 
 	easeOutQuart: function(t) {
 		return -((t = t - 1) * t * t * t - 1);
 	},
 
 	easeInOutQuart: function(t) {
 		if ((t /= 0.5) < 1) {
 			return 0.5 * t * t * t * t;
 		}
 		return -0.5 * ((t -= 2) * t * t * t - 2);
 	},
 
 	easeInQuint: function(t) {
 		return t * t * t * t * t;
 	},
 
 	easeOutQuint: function(t) {
 		return (t = t - 1) * t * t * t * t + 1;
 	},
 
 	easeInOutQuint: function(t) {
 		if ((t /= 0.5) < 1) {
 			return 0.5 * t * t * t * t * t;
 		}
 		return 0.5 * ((t -= 2) * t * t * t * t + 2);
 	},
 
 	easeInSine: function(t) {
 		return -Math.cos(t * (Math.PI / 2)) + 1;
 	},
 
 	easeOutSine: function(t) {
 		return Math.sin(t * (Math.PI / 2));
 	},
 
 	easeInOutSine: function(t) {
 		return -0.5 * (Math.cos(Math.PI * t) - 1);
 	},
 
 	easeInExpo: function(t) {
 		return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
 	},
 
 	easeOutExpo: function(t) {
 		return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
 	},
 
 	easeInOutExpo: function(t) {
 		if (t === 0) {
 			return 0;
 		}
 		if (t === 1) {
 			return 1;
 		}
 		if ((t /= 0.5) < 1) {
 			return 0.5 * Math.pow(2, 10 * (t - 1));
 		}
 		return 0.5 * (-Math.pow(2, -10 * --t) + 2);
 	},
 
 	easeInCirc: function(t) {
 		if (t >= 1) {
 			return t;
 		}
 		return -(Math.sqrt(1 - t * t) - 1);
 	},
 
 	easeOutCirc: function(t) {
 		return Math.sqrt(1 - (t = t - 1) * t);
 	},
 
 	easeInOutCirc: function(t) {
 		if ((t /= 0.5) < 1) {
 			return -0.5 * (Math.sqrt(1 - t * t) - 1);
 		}
 		return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
 	},
 
 	easeInElastic: function(t) {
 		var s = 1.70158;
 		var p = 0;
 		var a = 1;
 		if (t === 0) {
 			return 0;
 		}
 		if (t === 1) {
 			return 1;
 		}
 		if (!p) {
 			p = 0.3;
 		}
 		if (a < 1) {
 			a = 1;
 			s = p / 4;
 		} else {
 			s = p / (2 * Math.PI) * Math.asin(1 / a);
 		}
 		return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
 	},
 
 	easeOutElastic: function(t) {
 		var s = 1.70158;
 		var p = 0;
 		var a = 1;
 		if (t === 0) {
 			return 0;
 		}
 		if (t === 1) {
 			return 1;
 		}
 		if (!p) {
 			p = 0.3;
 		}
 		if (a < 1) {
 			a = 1;
 			s = p / 4;
 		} else {
 			s = p / (2 * Math.PI) * Math.asin(1 / a);
 		}
 		return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
 	},
 
 	easeInOutElastic: function(t) {
 		var s = 1.70158;
 		var p = 0;
 		var a = 1;
 		if (t === 0) {
 			return 0;
 		}
 		if ((t /= 0.5) === 2) {
 			return 1;
 		}
 		if (!p) {
 			p = 0.45;
 		}
 		if (a < 1) {
 			a = 1;
 			s = p / 4;
 		} else {
 			s = p / (2 * Math.PI) * Math.asin(1 / a);
 		}
 		if (t < 1) {
 			return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
 		}
 		return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
 	},
 	easeInBack: function(t) {
 		var s = 1.70158;
 		return t * t * ((s + 1) * t - s);
 	},
 
 	easeOutBack: function(t) {
 		var s = 1.70158;
 		return (t = t - 1) * t * ((s + 1) * t + s) + 1;
 	},
 
 	easeInOutBack: function(t) {
 		var s = 1.70158;
 		if ((t /= 0.5) < 1) {
 			return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
 		}
 		return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
 	},
 
 	easeInBounce: function(t) {
 		return 1 - effects.easeOutBounce(1 - t);
 	},
 
 	easeOutBounce: function(t) {
 		if (t < (1 / 2.75)) {
 			return 7.5625 * t * t;
 		}
 		if (t < (2 / 2.75)) {
 			return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
 		}
 		if (t < (2.5 / 2.75)) {
 			return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
 		}
 		return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
 	},
 
 	easeInOutBounce: function(t) {
 		if (t < 0.5) {
 			return effects.easeInBounce(t * 2) * 0.5;
 		}
 		return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
 	}
 };
 
 module.exports = {
 	effects: effects
 };
 
 // DEPRECATIONS
 
 /**
  * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
  * @function Chart.helpers.easingEffects
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.easingEffects = effects;
 
 },{"42":42}],44:[function(require,module,exports){
 'use strict';
 
 var helpers = require(42);
 
 /**
  * @alias Chart.helpers.options
  * @namespace
  */
 module.exports = {
 	/**
 	 * Converts the given line height `value` in pixels for a specific font `size`.
 	 * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
 	 * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
 	 * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
 	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
 	 * @since 2.7.0
 	 */
 	toLineHeight: function(value, size) {
 		var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
 		if (!matches || matches[1] === 'normal') {
 			return size * 1.2;
 		}
 
 		value = +matches[2];
 
 		switch (matches[3]) {
 		case 'px':
 			return value;
 		case '%':
 			value /= 100;
 			break;
 		default:
 			break;
 		}
 
 		return size * value;
 	},
 
 	/**
 	 * Converts the given value into a padding object with pre-computed width/height.
 	 * @param {Number|Object} value - If a number, set the value to all TRBL component,
 	 *  else, if and object, use defined properties and sets undefined ones to 0.
 	 * @returns {Object} The padding values (top, right, bottom, left, width, height)
 	 * @since 2.7.0
 	 */
 	toPadding: function(value) {
 		var t, r, b, l;
 
 		if (helpers.isObject(value)) {
 			t = +value.top || 0;
 			r = +value.right || 0;
 			b = +value.bottom || 0;
 			l = +value.left || 0;
 		} else {
 			t = r = b = l = +value || 0;
 		}
 
 		return {
 			top: t,
 			right: r,
 			bottom: b,
 			left: l,
 			height: t + b,
 			width: l + r
 		};
 	},
 
 	/**
 	 * Evaluates the given `inputs` sequentially and returns the first defined value.
 	 * @param {Array[]} inputs - An array of values, falling back to the last value.
 	 * @param {Object} [context] - If defined and the current value is a function, the value
 	 * is called with `context` as first argument and the result becomes the new input.
 	 * @param {Number} [index] - If defined and the current value is an array, the value
 	 * at `index` become the new input.
 	 * @since 2.7.0
 	 */
 	resolve: function(inputs, context, index) {
 		var i, ilen, value;
 
 		for (i = 0, ilen = inputs.length; i < ilen; ++i) {
 			value = inputs[i];
 			if (value === undefined) {
 				continue;
 			}
 			if (context !== undefined && typeof value === 'function') {
 				value = value(context);
 			}
 			if (index !== undefined && helpers.isArray(value)) {
 				value = value[index];
 			}
 			if (value !== undefined) {
 				return value;
 			}
 		}
 	}
 };
 
 },{"42":42}],45:[function(require,module,exports){
 'use strict';
 
 module.exports = require(42);
 module.exports.easing = require(43);
 module.exports.canvas = require(41);
 module.exports.options = require(44);
 
 },{"41":41,"42":42,"43":43,"44":44}],46:[function(require,module,exports){
 /**
  * Platform fallback implementation (minimal).
  * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
  */
 
 module.exports = {
 	acquireContext: function(item) {
 		if (item && item.canvas) {
 			// Support for any object associated to a canvas (including a context2d)
 			item = item.canvas;
 		}
 
 		return item && item.getContext('2d') || null;
 	}
 };
 
 },{}],47:[function(require,module,exports){
 /**
  * Chart.Platform implementation for targeting a web browser
  */
 
 'use strict';
 
 var helpers = require(45);
 
 var EXPANDO_KEY = '$chartjs';
 var CSS_PREFIX = 'chartjs-';
 var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
 var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
 var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
 
 /**
  * DOM event types -> Chart.js event types.
  * Note: only events with different types are mapped.
  * @see https://developer.mozilla.org/en-US/docs/Web/Events
  */
 var EVENT_TYPES = {
 	touchstart: 'mousedown',
 	touchmove: 'mousemove',
 	touchend: 'mouseup',
 	pointerenter: 'mouseenter',
 	pointerdown: 'mousedown',
 	pointermove: 'mousemove',
 	pointerup: 'mouseup',
 	pointerleave: 'mouseout',
 	pointerout: 'mouseout'
 };
 
 /**
  * The "used" size is the final value of a dimension property after all calculations have
  * been performed. This method uses the computed style of `element` but returns undefined
  * if the computed style is not expressed in pixels. That can happen in some cases where
  * `element` has a size relative to its parent and this last one is not yet displayed,
  * for example because of `display: none` on a parent node.
  * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
  * @returns {Number} Size in pixels or undefined if unknown.
  */
 function readUsedSize(element, property) {
 	var value = helpers.getStyle(element, property);
 	var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
 	return matches ? Number(matches[1]) : undefined;
 }
 
 /**
  * Initializes the canvas style and render size without modifying the canvas display size,
  * since responsiveness is handled by the controller.resize() method. The config is used
  * to determine the aspect ratio to apply in case no explicit height has been specified.
  */
 function initCanvas(canvas, config) {
 	var style = canvas.style;
 
 	// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
 	// returns null or '' if no explicit value has been set to the canvas attribute.
 	var renderHeight = canvas.getAttribute('height');
 	var renderWidth = canvas.getAttribute('width');
 
 	// Chart.js modifies some canvas values that we want to restore on destroy
 	canvas[EXPANDO_KEY] = {
 		initial: {
 			height: renderHeight,
 			width: renderWidth,
 			style: {
 				display: style.display,
 				height: style.height,
 				width: style.width
 			}
 		}
 	};
 
 	// Force canvas to display as block to avoid extra space caused by inline
 	// elements, which would interfere with the responsive resize process.
 	// https://github.com/chartjs/Chart.js/issues/2538
 	style.display = style.display || 'block';
 
 	if (renderWidth === null || renderWidth === '') {
 		var displayWidth = readUsedSize(canvas, 'width');
 		if (displayWidth !== undefined) {
 			canvas.width = displayWidth;
 		}
 	}
 
 	if (renderHeight === null || renderHeight === '') {
 		if (canvas.style.height === '') {
 			// If no explicit render height and style height, let's apply the aspect ratio,
 			// which one can be specified by the user but also by charts as default option
 			// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
 			canvas.height = canvas.width / (config.options.aspectRatio || 2);
 		} else {
 			var displayHeight = readUsedSize(canvas, 'height');
 			if (displayWidth !== undefined) {
 				canvas.height = displayHeight;
 			}
 		}
 	}
 
 	return canvas;
 }
 
 /**
  * Detects support for options object argument in addEventListener.
  * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
  * @private
  */
 var supportsEventListenerOptions = (function() {
 	var supports = false;
 	try {
 		var options = Object.defineProperty({}, 'passive', {
 			get: function() {
 				supports = true;
 			}
 		});
 		window.addEventListener('e', null, options);
 	} catch (e) {
 		// continue regardless of error
 	}
 	return supports;
 }());
 
 // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
 // https://github.com/chartjs/Chart.js/issues/4287
 var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
 
 function addEventListener(node, type, listener) {
 	node.addEventListener(type, listener, eventListenerOptions);
 }
 
 function removeEventListener(node, type, listener) {
 	node.removeEventListener(type, listener, eventListenerOptions);
 }
 
 function createEvent(type, chart, x, y, nativeEvent) {
 	return {
 		type: type,
 		chart: chart,
 		native: nativeEvent || null,
 		x: x !== undefined ? x : null,
 		y: y !== undefined ? y : null,
 	};
 }
 
 function fromNativeEvent(event, chart) {
 	var type = EVENT_TYPES[event.type] || event.type;
 	var pos = helpers.getRelativePosition(event, chart);
 	return createEvent(type, chart, pos.x, pos.y, event);
 }
 
 function throttled(fn, thisArg) {
 	var ticking = false;
 	var args = [];
 
 	return function() {
 		args = Array.prototype.slice.call(arguments);
 		thisArg = thisArg || this;
 
 		if (!ticking) {
 			ticking = true;
 			helpers.requestAnimFrame.call(window, function() {
 				ticking = false;
 				fn.apply(thisArg, args);
 			});
 		}
 	};
 }
 
 // Implementation based on https://github.com/marcj/css-element-queries
 function createResizer(handler) {
 	var resizer = document.createElement('div');
 	var cls = CSS_PREFIX + 'size-monitor';
 	var maxSize = 1000000;
 	var style =
 		'position:absolute;' +
 		'left:0;' +
 		'top:0;' +
 		'right:0;' +
 		'bottom:0;' +
 		'overflow:hidden;' +
 		'pointer-events:none;' +
 		'visibility:hidden;' +
 		'z-index:-1;';
 
 	resizer.style.cssText = style;
 	resizer.className = cls;
 	resizer.innerHTML =
 		'<div class="' + cls + '-expand" style="' + style + '">' +
 			'<div style="' +
 				'position:absolute;' +
 				'width:' + maxSize + 'px;' +
 				'height:' + maxSize + 'px;' +
 				'left:0;' +
 				'top:0">' +
 			'</div>' +
 		'</div>' +
 		'<div class="' + cls + '-shrink" style="' + style + '">' +
 			'<div style="' +
 				'position:absolute;' +
 				'width:200%;' +
 				'height:200%;' +
 				'left:0; ' +
 				'top:0">' +
 			'</div>' +
 		'</div>';
 
 	var expand = resizer.childNodes[0];
 	var shrink = resizer.childNodes[1];
 
 	resizer._reset = function() {
 		expand.scrollLeft = maxSize;
 		expand.scrollTop = maxSize;
 		shrink.scrollLeft = maxSize;
 		shrink.scrollTop = maxSize;
 	};
 	var onScroll = function() {
 		resizer._reset();
 		handler();
 	};
 
 	addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
 	addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
 
 	return resizer;
 }
 
 // https://davidwalsh.name/detect-node-insertion
 function watchForRender(node, handler) {
 	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
 	var proxy = expando.renderProxy = function(e) {
 		if (e.animationName === CSS_RENDER_ANIMATION) {
 			handler();
 		}
 	};
 
 	helpers.each(ANIMATION_START_EVENTS, function(type) {
 		addEventListener(node, type, proxy);
 	});
 
 	// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
 	// is removed then added back immediately (same animation frame?). Accessing the
 	// `offsetParent` property will force a reflow and re-evaluate the CSS animation.
 	// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
 	// https://github.com/chartjs/Chart.js/issues/4737
 	expando.reflow = !!node.offsetParent;
 
 	node.classList.add(CSS_RENDER_MONITOR);
 }
 
 function unwatchForRender(node) {
 	var expando = node[EXPANDO_KEY] || {};
 	var proxy = expando.renderProxy;
 
 	if (proxy) {
 		helpers.each(ANIMATION_START_EVENTS, function(type) {
 			removeEventListener(node, type, proxy);
 		});
 
 		delete expando.renderProxy;
 	}
 
 	node.classList.remove(CSS_RENDER_MONITOR);
 }
 
 function addResizeListener(node, listener, chart) {
 	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
 
 	// Let's keep track of this added resizer and thus avoid DOM query when removing it.
 	var resizer = expando.resizer = createResizer(throttled(function() {
 		if (expando.resizer) {
 			return listener(createEvent('resize', chart));
 		}
 	}));
 
 	// The resizer needs to be attached to the node parent, so we first need to be
 	// sure that `node` is attached to the DOM before injecting the resizer element.
 	watchForRender(node, function() {
 		if (expando.resizer) {
 			var container = node.parentNode;
 			if (container && container !== resizer.parentNode) {
 				container.insertBefore(resizer, container.firstChild);
 			}
 
 			// The container size might have changed, let's reset the resizer state.
 			resizer._reset();
 		}
 	});
 }
 
 function removeResizeListener(node) {
 	var expando = node[EXPANDO_KEY] || {};
 	var resizer = expando.resizer;
 
 	delete expando.resizer;
 	unwatchForRender(node);
 
 	if (resizer && resizer.parentNode) {
 		resizer.parentNode.removeChild(resizer);
 	}
 }
 
 function injectCSS(platform, css) {
 	// http://stackoverflow.com/q/3922139
 	var style = platform._style || document.createElement('style');
 	if (!platform._style) {
 		platform._style = style;
 		css = '/* Chart.js */\n' + css;
 		style.setAttribute('type', 'text/css');
 		document.getElementsByTagName('head')[0].appendChild(style);
 	}
 
 	style.appendChild(document.createTextNode(css));
 }
 
 module.exports = {
 	/**
 	 * This property holds whether this platform is enabled for the current environment.
 	 * Currently used by platform.js to select the proper implementation.
 	 * @private
 	 */
 	_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
 
 	initialize: function() {
 		var keyframes = 'from{opacity:0.99}to{opacity:1}';
 
 		injectCSS(this,
 			// DOM rendering detection
 			// https://davidwalsh.name/detect-node-insertion
 			'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
 			'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
 			'.' + CSS_RENDER_MONITOR + '{' +
 				'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
 				'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
 			'}'
 		);
 	},
 
 	acquireContext: function(item, config) {
 		if (typeof item === 'string') {
 			item = document.getElementById(item);
 		} else if (item.length) {
 			// Support for array based queries (such as jQuery)
 			item = item[0];
 		}
 
 		if (item && item.canvas) {
 			// Support for any object associated to a canvas (including a context2d)
 			item = item.canvas;
 		}
 
 		// To prevent canvas fingerprinting, some add-ons undefine the getContext
 		// method, for example: https://github.com/kkapsner/CanvasBlocker
 		// https://github.com/chartjs/Chart.js/issues/2807
 		var context = item && item.getContext && item.getContext('2d');
 
 		// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
 		// inside an iframe or when running in a protected environment. We could guess the
 		// types from their toString() value but let's keep things flexible and assume it's
 		// a sufficient condition if the item has a context2D which has item as `canvas`.
 		// https://github.com/chartjs/Chart.js/issues/3887
 		// https://github.com/chartjs/Chart.js/issues/4102
 		// https://github.com/chartjs/Chart.js/issues/4152
 		if (context && context.canvas === item) {
 			initCanvas(item, config);
 			return context;
 		}
 
 		return null;
 	},
 
 	releaseContext: function(context) {
 		var canvas = context.canvas;
 		if (!canvas[EXPANDO_KEY]) {
 			return;
 		}
 
 		var initial = canvas[EXPANDO_KEY].initial;
 		['height', 'width'].forEach(function(prop) {
 			var value = initial[prop];
 			if (helpers.isNullOrUndef(value)) {
 				canvas.removeAttribute(prop);
 			} else {
 				canvas.setAttribute(prop, value);
 			}
 		});
 
 		helpers.each(initial.style || {}, function(value, key) {
 			canvas.style[key] = value;
 		});
 
 		// The canvas render size might have been changed (and thus the state stack discarded),
 		// we can't use save() and restore() to restore the initial state. So make sure that at
 		// least the canvas context is reset to the default state by setting the canvas width.
 		// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
 		canvas.width = canvas.width;
 
 		delete canvas[EXPANDO_KEY];
 	},
 
 	addEventListener: function(chart, type, listener) {
 		var canvas = chart.canvas;
 		if (type === 'resize') {
 			// Note: the resize event is not supported on all browsers.
 			addResizeListener(canvas, listener, chart);
 			return;
 		}
 
 		var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
 		var proxies = expando.proxies || (expando.proxies = {});
 		var proxy = proxies[chart.id + '_' + type] = function(event) {
 			listener(fromNativeEvent(event, chart));
 		};
 
 		addEventListener(canvas, type, proxy);
 	},
 
 	removeEventListener: function(chart, type, listener) {
 		var canvas = chart.canvas;
 		if (type === 'resize') {
 			// Note: the resize event is not supported on all browsers.
 			removeResizeListener(canvas, listener);
 			return;
 		}
 
 		var expando = listener[EXPANDO_KEY] || {};
 		var proxies = expando.proxies || {};
 		var proxy = proxies[chart.id + '_' + type];
 		if (!proxy) {
 			return;
 		}
 
 		removeEventListener(canvas, type, proxy);
 	}
 };
 
 // DEPRECATIONS
 
 /**
  * Provided for backward compatibility, use EventTarget.addEventListener instead.
  * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
  * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
  * @function Chart.helpers.addEvent
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.addEvent = addEventListener;
 
 /**
  * Provided for backward compatibility, use EventTarget.removeEventListener instead.
  * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
  * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
  * @function Chart.helpers.removeEvent
  * @deprecated since version 2.7.0
  * @todo remove at version 3
  * @private
  */
 helpers.removeEvent = removeEventListener;
 
 },{"45":45}],48:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 var basic = require(46);
 var dom = require(47);
 
 // @TODO Make possible to select another platform at build time.
 var implementation = dom._enabled ? dom : basic;
 
 /**
  * @namespace Chart.platform
  * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
  * @since 2.4.0
  */
 module.exports = helpers.extend({
 	/**
 	 * @since 2.7.0
 	 */
 	initialize: function() {},
 
 	/**
 	 * Called at chart construction time, returns a context2d instance implementing
 	 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
 	 * @param {*} item - The native item from which to acquire context (platform specific)
 	 * @param {Object} options - The chart options
 	 * @returns {CanvasRenderingContext2D} context2d instance
 	 */
 	acquireContext: function() {},
 
 	/**
 	 * Called at chart destruction time, releases any resources associated to the context
 	 * previously returned by the acquireContext() method.
 	 * @param {CanvasRenderingContext2D} context - The context2d instance
 	 * @returns {Boolean} true if the method succeeded, else false
 	 */
 	releaseContext: function() {},
 
 	/**
 	 * Registers the specified listener on the given chart.
 	 * @param {Chart} chart - Chart from which to listen for event
 	 * @param {String} type - The ({@link IEvent}) type to listen for
 	 * @param {Function} listener - Receives a notification (an object that implements
 	 * the {@link IEvent} interface) when an event of the specified type occurs.
 	 */
 	addEventListener: function() {},
 
 	/**
 	 * Removes the specified listener previously registered with addEventListener.
 	 * @param {Chart} chart -Chart from which to remove the listener
 	 * @param {String} type - The ({@link IEvent}) type to remove
 	 * @param {Function} listener - The listener function to remove from the event target.
 	 */
 	removeEventListener: function() {}
 
 }, implementation);
 
 /**
  * @interface IPlatform
  * Allows abstracting platform dependencies away from the chart
  * @borrows Chart.platform.acquireContext as acquireContext
  * @borrows Chart.platform.releaseContext as releaseContext
  * @borrows Chart.platform.addEventListener as addEventListener
  * @borrows Chart.platform.removeEventListener as removeEventListener
  */
 
 /**
  * @interface IEvent
  * @prop {String} type - The event type name, possible values are:
  * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
  * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
  * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
  * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
  * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
  */
 
 },{"45":45,"46":46,"47":47}],49:[function(require,module,exports){
 'use strict';
 
 module.exports = {};
 module.exports.filler = require(50);
 module.exports.legend = require(51);
 module.exports.title = require(52);
 
 },{"50":50,"51":51,"52":52}],50:[function(require,module,exports){
 /**
  * Plugin based on discussion from the following Chart.js issues:
  * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
  * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
  */
 
 'use strict';
 
 var defaults = require(25);
 var elements = require(40);
 var helpers = require(45);
 
 defaults._set('global', {
 	plugins: {
 		filler: {
 			propagate: true
 		}
 	}
 });
 
 var mappers = {
 	dataset: function(source) {
 		var index = source.fill;
 		var chart = source.chart;
 		var meta = chart.getDatasetMeta(index);
 		var visible = meta && chart.isDatasetVisible(index);
 		var points = (visible && meta.dataset._children) || [];
 		var length = points.length || 0;
 
 		return !length ? null : function(point, i) {
 			return (i < length && points[i]._view) || null;
 		};
 	},
 
 	boundary: function(source) {
 		var boundary = source.boundary;
 		var x = boundary ? boundary.x : null;
 		var y = boundary ? boundary.y : null;
 
 		return function(point) {
 			return {
 				x: x === null ? point.x : x,
 				y: y === null ? point.y : y,
 			};
 		};
 	}
 };
 
 // @todo if (fill[0] === '#')
 function decodeFill(el, index, count) {
 	var model = el._model || {};
 	var fill = model.fill;
 	var target;
 
 	if (fill === undefined) {
 		fill = !!model.backgroundColor;
 	}
 
 	if (fill === false || fill === null) {
 		return false;
 	}
 
 	if (fill === true) {
 		return 'origin';
 	}
 
 	target = parseFloat(fill, 10);
 	if (isFinite(target) && Math.floor(target) === target) {
 		if (fill[0] === '-' || fill[0] === '+') {
 			target = index + target;
 		}
 
 		if (target === index || target < 0 || target >= count) {
 			return false;
 		}
 
 		return target;
 	}
 
 	switch (fill) {
 	// compatibility
 	case 'bottom':
 		return 'start';
 	case 'top':
 		return 'end';
 	case 'zero':
 		return 'origin';
 	// supported boundaries
 	case 'origin':
 	case 'start':
 	case 'end':
 		return fill;
 	// invalid fill values
 	default:
 		return false;
 	}
 }
 
 function computeBoundary(source) {
 	var model = source.el._model || {};
 	var scale = source.el._scale || {};
 	var fill = source.fill;
 	var target = null;
 	var horizontal;
 
 	if (isFinite(fill)) {
 		return null;
 	}
 
 	// Backward compatibility: until v3, we still need to support boundary values set on
 	// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
 	// controllers might still use it (e.g. the Smith chart).
 
 	if (fill === 'start') {
 		target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
 	} else if (fill === 'end') {
 		target = model.scaleTop === undefined ? scale.top : model.scaleTop;
 	} else if (model.scaleZero !== undefined) {
 		target = model.scaleZero;
 	} else if (scale.getBasePosition) {
 		target = scale.getBasePosition();
 	} else if (scale.getBasePixel) {
 		target = scale.getBasePixel();
 	}
 
 	if (target !== undefined && target !== null) {
 		if (target.x !== undefined && target.y !== undefined) {
 			return target;
 		}
 
 		if (typeof target === 'number' && isFinite(target)) {
 			horizontal = scale.isHorizontal();
 			return {
 				x: horizontal ? target : null,
 				y: horizontal ? null : target
 			};
 		}
 	}
 
 	return null;
 }
 
 function resolveTarget(sources, index, propagate) {
 	var source = sources[index];
 	var fill = source.fill;
 	var visited = [index];
 	var target;
 
 	if (!propagate) {
 		return fill;
 	}
 
 	while (fill !== false && visited.indexOf(fill) === -1) {
 		if (!isFinite(fill)) {
 			return fill;
 		}
 
 		target = sources[fill];
 		if (!target) {
 			return false;
 		}
 
 		if (target.visible) {
 			return fill;
 		}
 
 		visited.push(fill);
 		fill = target.fill;
 	}
 
 	return false;
 }
 
 function createMapper(source) {
 	var fill = source.fill;
 	var type = 'dataset';
 
 	if (fill === false) {
 		return null;
 	}
 
 	if (!isFinite(fill)) {
 		type = 'boundary';
 	}
 
 	return mappers[type](source);
 }
 
 function isDrawable(point) {
 	return point && !point.skip;
 }
 
 function drawArea(ctx, curve0, curve1, len0, len1) {
 	var i;
 
 	if (!len0 || !len1) {
 		return;
 	}
 
 	// building first area curve (normal)
 	ctx.moveTo(curve0[0].x, curve0[0].y);
 	for (i = 1; i < len0; ++i) {
 		helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
 	}
 
 	// joining the two area curves
 	ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
 
 	// building opposite area curve (reverse)
 	for (i = len1 - 1; i > 0; --i) {
 		helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
 	}
 }
 
 function doFill(ctx, points, mapper, view, color, loop) {
 	var count = points.length;
 	var span = view.spanGaps;
 	var curve0 = [];
 	var curve1 = [];
 	var len0 = 0;
 	var len1 = 0;
 	var i, ilen, index, p0, p1, d0, d1;
 
 	ctx.beginPath();
 
 	for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
 		index = i % count;
 		p0 = points[index]._view;
 		p1 = mapper(p0, index, view);
 		d0 = isDrawable(p0);
 		d1 = isDrawable(p1);
 
 		if (d0 && d1) {
 			len0 = curve0.push(p0);
 			len1 = curve1.push(p1);
 		} else if (len0 && len1) {
 			if (!span) {
 				drawArea(ctx, curve0, curve1, len0, len1);
 				len0 = len1 = 0;
 				curve0 = [];
 				curve1 = [];
 			} else {
 				if (d0) {
 					curve0.push(p0);
 				}
 				if (d1) {
 					curve1.push(p1);
 				}
 			}
 		}
 	}
 
 	drawArea(ctx, curve0, curve1, len0, len1);
 
 	ctx.closePath();
 	ctx.fillStyle = color;
 	ctx.fill();
 }
 
 module.exports = {
 	id: 'filler',
 
 	afterDatasetsUpdate: function(chart, options) {
 		var count = (chart.data.datasets || []).length;
 		var propagate = options.propagate;
 		var sources = [];
 		var meta, i, el, source;
 
 		for (i = 0; i < count; ++i) {
 			meta = chart.getDatasetMeta(i);
 			el = meta.dataset;
 			source = null;
 
 			if (el && el._model && el instanceof elements.Line) {
 				source = {
 					visible: chart.isDatasetVisible(i),
 					fill: decodeFill(el, i, count),
 					chart: chart,
 					el: el
 				};
 			}
 
 			meta.$filler = source;
 			sources.push(source);
 		}
 
 		for (i = 0; i < count; ++i) {
 			source = sources[i];
 			if (!source) {
 				continue;
 			}
 
 			source.fill = resolveTarget(sources, i, propagate);
 			source.boundary = computeBoundary(source);
 			source.mapper = createMapper(source);
 		}
 	},
 
 	beforeDatasetDraw: function(chart, args) {
 		var meta = args.meta.$filler;
 		if (!meta) {
 			return;
 		}
 
 		var ctx = chart.ctx;
 		var el = meta.el;
 		var view = el._view;
 		var points = el._children || [];
 		var mapper = meta.mapper;
 		var color = view.backgroundColor || defaults.global.defaultColor;
 
 		if (mapper && color && points.length) {
 			helpers.canvas.clipArea(ctx, chart.chartArea);
 			doFill(ctx, points, mapper, view, color, el._loop);
 			helpers.canvas.unclipArea(ctx);
 		}
 	}
 };
 
 },{"25":25,"40":40,"45":45}],51:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 var layouts = require(30);
 
 var noop = helpers.noop;
 
 defaults._set('global', {
 	legend: {
 		display: true,
 		position: 'top',
 		fullWidth: true,
 		reverse: false,
 		weight: 1000,
 
 		// a callback that will handle
 		onClick: function(e, legendItem) {
 			var index = legendItem.datasetIndex;
 			var ci = this.chart;
 			var meta = ci.getDatasetMeta(index);
 
 			// See controller.isDatasetVisible comment
 			meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
 
 			// We hid a dataset ... rerender the chart
 			ci.update();
 		},
 
 		onHover: null,
 
 		labels: {
 			boxWidth: 40,
 			padding: 10,
 			// Generates labels shown in the legend
 			// Valid properties to return:
 			// text : text to display
 			// fillStyle : fill of coloured box
 			// strokeStyle: stroke of coloured box
 			// hidden : if this legend item refers to a hidden item
 			// lineCap : cap style for line
 			// lineDash
 			// lineDashOffset :
 			// lineJoin :
 			// lineWidth :
 			generateLabels: function(chart) {
 				var data = chart.data;
 				return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
 					return {
 						text: dataset.label,
 						fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
 						hidden: !chart.isDatasetVisible(i),
 						lineCap: dataset.borderCapStyle,
 						lineDash: dataset.borderDash,
 						lineDashOffset: dataset.borderDashOffset,
 						lineJoin: dataset.borderJoinStyle,
 						lineWidth: dataset.borderWidth,
 						strokeStyle: dataset.borderColor,
 						pointStyle: dataset.pointStyle,
 
 						// Below is extra data used for toggling the datasets
 						datasetIndex: i
 					};
 				}, this) : [];
 			}
 		}
 	},
 
 	legendCallback: function(chart) {
 		var text = [];
 		text.push('<ul class="' + chart.id + '-legend">');
 		for (var i = 0; i < chart.data.datasets.length; i++) {
 			text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
 			if (chart.data.datasets[i].label) {
 				text.push(chart.data.datasets[i].label);
 			}
 			text.push('</li>');
 		}
 		text.push('</ul>');
 		return text.join('');
 	}
 });
 
 /**
  * Helper function to get the box width based on the usePointStyle option
  * @param labelopts {Object} the label options on the legend
  * @param fontSize {Number} the label font size
  * @return {Number} width of the color box area
  */
 function getBoxWidth(labelOpts, fontSize) {
 	return labelOpts.usePointStyle ?
 		fontSize * Math.SQRT2 :
 		labelOpts.boxWidth;
 }
 
 /**
  * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
  */
 var Legend = Element.extend({
 
 	initialize: function(config) {
 		helpers.extend(this, config);
 
 		// Contains hit boxes for each dataset (in dataset order)
 		this.legendHitBoxes = [];
 
 		// Are we in doughnut mode which has a different data type
 		this.doughnutMode = false;
 	},
 
 	// These methods are ordered by lifecycle. Utilities then follow.
 	// Any function defined here is inherited by all legend types.
 	// Any function can be extended by the legend type
 
 	beforeUpdate: noop,
 	update: function(maxWidth, maxHeight, margins) {
 		var me = this;
 
 		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
 		me.beforeUpdate();
 
 		// Absorb the master measurements
 		me.maxWidth = maxWidth;
 		me.maxHeight = maxHeight;
 		me.margins = margins;
 
 		// Dimensions
 		me.beforeSetDimensions();
 		me.setDimensions();
 		me.afterSetDimensions();
 		// Labels
 		me.beforeBuildLabels();
 		me.buildLabels();
 		me.afterBuildLabels();
 
 		// Fit
 		me.beforeFit();
 		me.fit();
 		me.afterFit();
 		//
 		me.afterUpdate();
 
 		return me.minSize;
 	},
 	afterUpdate: noop,
 
 	//
 
 	beforeSetDimensions: noop,
 	setDimensions: function() {
 		var me = this;
 		// Set the unconstrained dimension before label rotation
 		if (me.isHorizontal()) {
 			// Reset position before calculating rotation
 			me.width = me.maxWidth;
 			me.left = 0;
 			me.right = me.width;
 		} else {
 			me.height = me.maxHeight;
 
 			// Reset position before calculating rotation
 			me.top = 0;
 			me.bottom = me.height;
 		}
 
 		// Reset padding
 		me.paddingLeft = 0;
 		me.paddingTop = 0;
 		me.paddingRight = 0;
 		me.paddingBottom = 0;
 
 		// Reset minSize
 		me.minSize = {
 			width: 0,
 			height: 0
 		};
 	},
 	afterSetDimensions: noop,
 
 	//
 
 	beforeBuildLabels: noop,
 	buildLabels: function() {
 		var me = this;
 		var labelOpts = me.options.labels || {};
 		var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];
 
 		if (labelOpts.filter) {
 			legendItems = legendItems.filter(function(item) {
 				return labelOpts.filter(item, me.chart.data);
 			});
 		}
 
 		if (me.options.reverse) {
 			legendItems.reverse();
 		}
 
 		me.legendItems = legendItems;
 	},
 	afterBuildLabels: noop,
 
 	//
 
 	beforeFit: noop,
 	fit: function() {
 		var me = this;
 		var opts = me.options;
 		var labelOpts = opts.labels;
 		var display = opts.display;
 
 		var ctx = me.ctx;
 
 		var globalDefault = defaults.global;
 		var valueOrDefault = helpers.valueOrDefault;
 		var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
 		var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
 		var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
 		var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
 
 		// Reset hit boxes
 		var hitboxes = me.legendHitBoxes = [];
 
 		var minSize = me.minSize;
 		var isHorizontal = me.isHorizontal();
 
 		if (isHorizontal) {
 			minSize.width = me.maxWidth; // fill all the width
 			minSize.height = display ? 10 : 0;
 		} else {
 			minSize.width = display ? 10 : 0;
 			minSize.height = me.maxHeight; // fill all the height
 		}
 
 		// Increase sizes here
 		if (display) {
 			ctx.font = labelFont;
 
 			if (isHorizontal) {
 				// Labels
 
 				// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
 				var lineWidths = me.lineWidths = [0];
 				var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;
 
 				ctx.textAlign = 'left';
 				ctx.textBaseline = 'top';
 
 				helpers.each(me.legendItems, function(legendItem, i) {
 					var boxWidth = getBoxWidth(labelOpts, fontSize);
 					var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
 
 					if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
 						totalHeight += fontSize + (labelOpts.padding);
 						lineWidths[lineWidths.length] = me.left;
 					}
 
 					// Store the hitbox width and height here. Final position will be updated in `draw`
 					hitboxes[i] = {
 						left: 0,
 						top: 0,
 						width: width,
 						height: fontSize
 					};
 
 					lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
 				});
 
 				minSize.height += totalHeight;
 
 			} else {
 				var vPadding = labelOpts.padding;
 				var columnWidths = me.columnWidths = [];
 				var totalWidth = labelOpts.padding;
 				var currentColWidth = 0;
 				var currentColHeight = 0;
 				var itemHeight = fontSize + vPadding;
 
 				helpers.each(me.legendItems, function(legendItem, i) {
 					var boxWidth = getBoxWidth(labelOpts, fontSize);
 					var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
 
 					// If too tall, go to new column
 					if (currentColHeight + itemHeight > minSize.height) {
 						totalWidth += currentColWidth + labelOpts.padding;
 						columnWidths.push(currentColWidth); // previous column width
 
 						currentColWidth = 0;
 						currentColHeight = 0;
 					}
 
 					// Get max width
 					currentColWidth = Math.max(currentColWidth, itemWidth);
 					currentColHeight += itemHeight;
 
 					// Store the hitbox width and height here. Final position will be updated in `draw`
 					hitboxes[i] = {
 						left: 0,
 						top: 0,
 						width: itemWidth,
 						height: fontSize
 					};
 				});
 
 				totalWidth += currentColWidth;
 				columnWidths.push(currentColWidth);
 				minSize.width += totalWidth;
 			}
 		}
 
 		me.width = minSize.width;
 		me.height = minSize.height;
 	},
 	afterFit: noop,
 
 	// Shared Methods
 	isHorizontal: function() {
 		return this.options.position === 'top' || this.options.position === 'bottom';
 	},
 
 	// Actually draw the legend on the canvas
 	draw: function() {
 		var me = this;
 		var opts = me.options;
 		var labelOpts = opts.labels;
 		var globalDefault = defaults.global;
 		var lineDefault = globalDefault.elements.line;
 		var legendWidth = me.width;
 		var lineWidths = me.lineWidths;
 
 		if (opts.display) {
 			var ctx = me.ctx;
 			var valueOrDefault = helpers.valueOrDefault;
 			var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
 			var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
 			var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
 			var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
 			var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
 			var cursor;
 
 			// Canvas setup
 			ctx.textAlign = 'left';
 			ctx.textBaseline = 'middle';
 			ctx.lineWidth = 0.5;
 			ctx.strokeStyle = fontColor; // for strikethrough effect
 			ctx.fillStyle = fontColor; // render in correct colour
 			ctx.font = labelFont;
 
 			var boxWidth = getBoxWidth(labelOpts, fontSize);
 			var hitboxes = me.legendHitBoxes;
 
 			// current position
 			var drawLegendBox = function(x, y, legendItem) {
 				if (isNaN(boxWidth) || boxWidth <= 0) {
 					return;
 				}
 
 				// Set the ctx for the box
 				ctx.save();
 
 				ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
 				ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
 				ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
 				ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
 				ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
 				ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
 				var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);
 
 				if (ctx.setLineDash) {
 					// IE 9 and 10 do not support line dash
 					ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
 				}
 
 				if (opts.labels && opts.labels.usePointStyle) {
 					// Recalculate x and y for drawPoint() because its expecting
 					// x and y to be center of figure (instead of top left)
 					var radius = fontSize * Math.SQRT2 / 2;
 					var offSet = radius / Math.SQRT2;
 					var centerX = x + offSet;
 					var centerY = y + offSet;
 
 					// Draw pointStyle as legend symbol
 					helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
 				} else {
 					// Draw box as legend symbol
 					if (!isLineWidthZero) {
 						ctx.strokeRect(x, y, boxWidth, fontSize);
 					}
 					ctx.fillRect(x, y, boxWidth, fontSize);
 				}
 
 				ctx.restore();
 			};
 			var fillText = function(x, y, legendItem, textWidth) {
 				var halfFontSize = fontSize / 2;
 				var xLeft = boxWidth + halfFontSize + x;
 				var yMiddle = y + halfFontSize;
 
 				ctx.fillText(legendItem.text, xLeft, yMiddle);
 
 				if (legendItem.hidden) {
 					// Strikethrough the text if hidden
 					ctx.beginPath();
 					ctx.lineWidth = 2;
 					ctx.moveTo(xLeft, yMiddle);
 					ctx.lineTo(xLeft + textWidth, yMiddle);
 					ctx.stroke();
 				}
 			};
 
 			// Horizontal
 			var isHorizontal = me.isHorizontal();
 			if (isHorizontal) {
 				cursor = {
 					x: me.left + ((legendWidth - lineWidths[0]) / 2),
 					y: me.top + labelOpts.padding,
 					line: 0
 				};
 			} else {
 				cursor = {
 					x: me.left + labelOpts.padding,
 					y: me.top + labelOpts.padding,
 					line: 0
 				};
 			}
 
 			var itemHeight = fontSize + labelOpts.padding;
 			helpers.each(me.legendItems, function(legendItem, i) {
 				var textWidth = ctx.measureText(legendItem.text).width;
 				var width = boxWidth + (fontSize / 2) + textWidth;
 				var x = cursor.x;
 				var y = cursor.y;
 
 				if (isHorizontal) {
 					if (x + width >= legendWidth) {
 						y = cursor.y += itemHeight;
 						cursor.line++;
 						x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
 					}
 				} else if (y + itemHeight > me.bottom) {
 					x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
 					y = cursor.y = me.top + labelOpts.padding;
 					cursor.line++;
 				}
 
 				drawLegendBox(x, y, legendItem);
 
 				hitboxes[i].left = x;
 				hitboxes[i].top = y;
 
 				// Fill the actual label
 				fillText(x, y, legendItem, textWidth);
 
 				if (isHorizontal) {
 					cursor.x += width + (labelOpts.padding);
 				} else {
 					cursor.y += itemHeight;
 				}
 
 			});
 		}
 	},
 
 	/**
 	 * Handle an event
 	 * @private
 	 * @param {IEvent} event - The event to handle
 	 * @return {Boolean} true if a change occured
 	 */
 	handleEvent: function(e) {
 		var me = this;
 		var opts = me.options;
 		var type = e.type === 'mouseup' ? 'click' : e.type;
 		var changed = false;
 
 		if (type === 'mousemove') {
 			if (!opts.onHover) {
 				return;
 			}
 		} else if (type === 'click') {
 			if (!opts.onClick) {
 				return;
 			}
 		} else {
 			return;
 		}
 
 		// Chart event already has relative position in it
 		var x = e.x;
 		var y = e.y;
 
 		if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
 			// See if we are touching one of the dataset boxes
 			var lh = me.legendHitBoxes;
 			for (var i = 0; i < lh.length; ++i) {
 				var hitBox = lh[i];
 
 				if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
 					// Touching an element
 					if (type === 'click') {
 						// use e.native for backwards compatibility
 						opts.onClick.call(me, e.native, me.legendItems[i]);
 						changed = true;
 						break;
 					} else if (type === 'mousemove') {
 						// use e.native for backwards compatibility
 						opts.onHover.call(me, e.native, me.legendItems[i]);
 						changed = true;
 						break;
 					}
 				}
 			}
 		}
 
 		return changed;
 	}
 });
 
 function createNewLegendAndAttach(chart, legendOpts) {
 	var legend = new Legend({
 		ctx: chart.ctx,
 		options: legendOpts,
 		chart: chart
 	});
 
 	layouts.configure(chart, legend, legendOpts);
 	layouts.addBox(chart, legend);
 	chart.legend = legend;
 }
 
 module.exports = {
 	id: 'legend',
 
 	/**
 	 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
 	 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
 	 * the plugin, which one will be re-exposed in the chart.js file.
 	 * https://github.com/chartjs/Chart.js/pull/2640
 	 * @private
 	 */
 	_element: Legend,
 
 	beforeInit: function(chart) {
 		var legendOpts = chart.options.legend;
 
 		if (legendOpts) {
 			createNewLegendAndAttach(chart, legendOpts);
 		}
 	},
 
 	beforeUpdate: function(chart) {
 		var legendOpts = chart.options.legend;
 		var legend = chart.legend;
 
 		if (legendOpts) {
 			helpers.mergeIf(legendOpts, defaults.global.legend);
 
 			if (legend) {
 				layouts.configure(chart, legend, legendOpts);
 				legend.options = legendOpts;
 			} else {
 				createNewLegendAndAttach(chart, legendOpts);
 			}
 		} else if (legend) {
 			layouts.removeBox(chart, legend);
 			delete chart.legend;
 		}
 	},
 
 	afterEvent: function(chart, e) {
 		var legend = chart.legend;
 		if (legend) {
 			legend.handleEvent(e);
 		}
 	}
 };
 
 },{"25":25,"26":26,"30":30,"45":45}],52:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var Element = require(26);
 var helpers = require(45);
 var layouts = require(30);
 
 var noop = helpers.noop;
 
 defaults._set('global', {
 	title: {
 		display: false,
 		fontStyle: 'bold',
 		fullWidth: true,
 		lineHeight: 1.2,
 		padding: 10,
 		position: 'top',
 		text: '',
 		weight: 2000         // by default greater than legend (1000) to be above
 	}
 });
 
 /**
  * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
  */
 var Title = Element.extend({
 	initialize: function(config) {
 		var me = this;
 		helpers.extend(me, config);
 
 		// Contains hit boxes for each dataset (in dataset order)
 		me.legendHitBoxes = [];
 	},
 
 	// These methods are ordered by lifecycle. Utilities then follow.
 
 	beforeUpdate: noop,
 	update: function(maxWidth, maxHeight, margins) {
 		var me = this;
 
 		// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
 		me.beforeUpdate();
 
 		// Absorb the master measurements
 		me.maxWidth = maxWidth;
 		me.maxHeight = maxHeight;
 		me.margins = margins;
 
 		// Dimensions
 		me.beforeSetDimensions();
 		me.setDimensions();
 		me.afterSetDimensions();
 		// Labels
 		me.beforeBuildLabels();
 		me.buildLabels();
 		me.afterBuildLabels();
 
 		// Fit
 		me.beforeFit();
 		me.fit();
 		me.afterFit();
 		//
 		me.afterUpdate();
 
 		return me.minSize;
 
 	},
 	afterUpdate: noop,
 
 	//
 
 	beforeSetDimensions: noop,
 	setDimensions: function() {
 		var me = this;
 		// Set the unconstrained dimension before label rotation
 		if (me.isHorizontal()) {
 			// Reset position before calculating rotation
 			me.width = me.maxWidth;
 			me.left = 0;
 			me.right = me.width;
 		} else {
 			me.height = me.maxHeight;
 
 			// Reset position before calculating rotation
 			me.top = 0;
 			me.bottom = me.height;
 		}
 
 		// Reset padding
 		me.paddingLeft = 0;
 		me.paddingTop = 0;
 		me.paddingRight = 0;
 		me.paddingBottom = 0;
 
 		// Reset minSize
 		me.minSize = {
 			width: 0,
 			height: 0
 		};
 	},
 	afterSetDimensions: noop,
 
 	//
 
 	beforeBuildLabels: noop,
 	buildLabels: noop,
 	afterBuildLabels: noop,
 
 	//
 
 	beforeFit: noop,
 	fit: function() {
 		var me = this;
 		var valueOrDefault = helpers.valueOrDefault;
 		var opts = me.options;
 		var display = opts.display;
 		var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
 		var minSize = me.minSize;
 		var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
 		var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
 		var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;
 
 		if (me.isHorizontal()) {
 			minSize.width = me.maxWidth; // fill all the width
 			minSize.height = textSize;
 		} else {
 			minSize.width = textSize;
 			minSize.height = me.maxHeight; // fill all the height
 		}
 
 		me.width = minSize.width;
 		me.height = minSize.height;
 
 	},
 	afterFit: noop,
 
 	// Shared Methods
 	isHorizontal: function() {
 		var pos = this.options.position;
 		return pos === 'top' || pos === 'bottom';
 	},
 
 	// Actually draw the title block on the canvas
 	draw: function() {
 		var me = this;
 		var ctx = me.ctx;
 		var valueOrDefault = helpers.valueOrDefault;
 		var opts = me.options;
 		var globalDefaults = defaults.global;
 
 		if (opts.display) {
 			var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
 			var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
 			var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
 			var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
 			var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
 			var offset = lineHeight / 2 + opts.padding;
 			var rotation = 0;
 			var top = me.top;
 			var left = me.left;
 			var bottom = me.bottom;
 			var right = me.right;
 			var maxWidth, titleX, titleY;
 
 			ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
 			ctx.font = titleFont;
 
 			// Horizontal
 			if (me.isHorizontal()) {
 				titleX = left + ((right - left) / 2); // midpoint of the width
 				titleY = top + offset;
 				maxWidth = right - left;
 			} else {
 				titleX = opts.position === 'left' ? left + offset : right - offset;
 				titleY = top + ((bottom - top) / 2);
 				maxWidth = bottom - top;
 				rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
 			}
 
 			ctx.save();
 			ctx.translate(titleX, titleY);
 			ctx.rotate(rotation);
 			ctx.textAlign = 'center';
 			ctx.textBaseline = 'middle';
 
 			var text = opts.text;
 			if (helpers.isArray(text)) {
 				var y = 0;
 				for (var i = 0; i < text.length; ++i) {
 					ctx.fillText(text[i], 0, y, maxWidth);
 					y += lineHeight;
 				}
 			} else {
 				ctx.fillText(text, 0, 0, maxWidth);
 			}
 
 			ctx.restore();
 		}
 	}
 });
 
 function createNewTitleBlockAndAttach(chart, titleOpts) {
 	var title = new Title({
 		ctx: chart.ctx,
 		options: titleOpts,
 		chart: chart
 	});
 
 	layouts.configure(chart, title, titleOpts);
 	layouts.addBox(chart, title);
 	chart.titleBlock = title;
 }
 
 module.exports = {
 	id: 'title',
 
 	/**
 	 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
 	 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
 	 * the plugin, which one will be re-exposed in the chart.js file.
 	 * https://github.com/chartjs/Chart.js/pull/2640
 	 * @private
 	 */
 	_element: Title,
 
 	beforeInit: function(chart) {
 		var titleOpts = chart.options.title;
 
 		if (titleOpts) {
 			createNewTitleBlockAndAttach(chart, titleOpts);
 		}
 	},
 
 	beforeUpdate: function(chart) {
 		var titleOpts = chart.options.title;
 		var titleBlock = chart.titleBlock;
 
 		if (titleOpts) {
 			helpers.mergeIf(titleOpts, defaults.global.title);
 
 			if (titleBlock) {
 				layouts.configure(chart, titleBlock, titleOpts);
 				titleBlock.options = titleOpts;
 			} else {
 				createNewTitleBlockAndAttach(chart, titleOpts);
 			}
 		} else if (titleBlock) {
 			layouts.removeBox(chart, titleBlock);
 			delete chart.titleBlock;
 		}
 	}
 };
 
 },{"25":25,"26":26,"30":30,"45":45}],53:[function(require,module,exports){
 'use strict';
 
 module.exports = function(Chart) {
 
 	// Default config for a category scale
 	var defaultConfig = {
 		position: 'bottom'
 	};
 
 	var DatasetScale = Chart.Scale.extend({
 		/**
 		* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
 		* else fall back to data.labels
 		* @private
 		*/
 		getLabels: function() {
 			var data = this.chart.data;
 			return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
 		},
 
 		determineDataLimits: function() {
 			var me = this;
 			var labels = me.getLabels();
 			me.minIndex = 0;
 			me.maxIndex = labels.length - 1;
 			var findIndex;
 
 			if (me.options.ticks.min !== undefined) {
 				// user specified min value
 				findIndex = labels.indexOf(me.options.ticks.min);
 				me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
 			}
 
 			if (me.options.ticks.max !== undefined) {
 				// user specified max value
 				findIndex = labels.indexOf(me.options.ticks.max);
 				me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
 			}
 
 			me.min = labels[me.minIndex];
 			me.max = labels[me.maxIndex];
 		},
 
 		buildTicks: function() {
 			var me = this;
 			var labels = me.getLabels();
 			// If we are viewing some subset of labels, slice the original array
 			me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
 		},
 
 		getLabelForIndex: function(index, datasetIndex) {
 			var me = this;
 			var data = me.chart.data;
 			var isHorizontal = me.isHorizontal();
 
 			if (data.yLabels && !isHorizontal) {
 				return me.getRightValue(data.datasets[datasetIndex].data[index]);
 			}
 			return me.ticks[index - me.minIndex];
 		},
 
 		// Used to get data value locations.  Value can either be an index or a numerical value
 		getPixelForValue: function(value, index) {
 			var me = this;
 			var offset = me.options.offset;
 			// 1 is added because we need the length but we have the indexes
 			var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);
 
 			// If value is a data object, then index is the index in the data array,
 			// not the index of the scale. We need to change that.
 			var valueCategory;
 			if (value !== undefined && value !== null) {
 				valueCategory = me.isHorizontal() ? value.x : value.y;
 			}
 			if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
 				var labels = me.getLabels();
 				value = valueCategory || value;
 				var idx = labels.indexOf(value);
 				index = idx !== -1 ? idx : index;
 			}
 
 			if (me.isHorizontal()) {
 				var valueWidth = me.width / offsetAmt;
 				var widthOffset = (valueWidth * (index - me.minIndex));
 
 				if (offset) {
 					widthOffset += (valueWidth / 2);
 				}
 
 				return me.left + Math.round(widthOffset);
 			}
 			var valueHeight = me.height / offsetAmt;
 			var heightOffset = (valueHeight * (index - me.minIndex));
 
 			if (offset) {
 				heightOffset += (valueHeight / 2);
 			}
 
 			return me.top + Math.round(heightOffset);
 		},
 		getPixelForTick: function(index) {
 			return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
 		},
 		getValueForPixel: function(pixel) {
 			var me = this;
 			var offset = me.options.offset;
 			var value;
 			var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
 			var horz = me.isHorizontal();
 			var valueDimension = (horz ? me.width : me.height) / offsetAmt;
 
 			pixel -= horz ? me.left : me.top;
 
 			if (offset) {
 				pixel -= (valueDimension / 2);
 			}
 
 			if (pixel <= 0) {
 				value = 0;
 			} else {
 				value = Math.round(pixel / valueDimension);
 			}
 
 			return value + me.minIndex;
 		},
 		getBasePixel: function() {
 			return this.bottom;
 		}
 	});
 
 	Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
 
 };
 
 },{}],54:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var helpers = require(45);
 var Ticks = require(34);
 
 module.exports = function(Chart) {
 
 	var defaultConfig = {
 		position: 'left',
 		ticks: {
 			callback: Ticks.formatters.linear
 		}
 	};
 
 	var LinearScale = Chart.LinearScaleBase.extend({
 
 		determineDataLimits: function() {
 			var me = this;
 			var opts = me.options;
 			var chart = me.chart;
 			var data = chart.data;
 			var datasets = data.datasets;
 			var isHorizontal = me.isHorizontal();
 			var DEFAULT_MIN = 0;
 			var DEFAULT_MAX = 1;
 
 			function IDMatches(meta) {
 				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
 			}
 
 			// First Calculate the range
 			me.min = null;
 			me.max = null;
 
 			var hasStacks = opts.stacked;
 			if (hasStacks === undefined) {
 				helpers.each(datasets, function(dataset, datasetIndex) {
 					if (hasStacks) {
 						return;
 					}
 
 					var meta = chart.getDatasetMeta(datasetIndex);
 					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
 						meta.stack !== undefined) {
 						hasStacks = true;
 					}
 				});
 			}
 
 			if (opts.stacked || hasStacks) {
 				var valuesPerStack = {};
 
 				helpers.each(datasets, function(dataset, datasetIndex) {
 					var meta = chart.getDatasetMeta(datasetIndex);
 					var key = [
 						meta.type,
 						// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
 						((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
 						meta.stack
 					].join('.');
 
 					if (valuesPerStack[key] === undefined) {
 						valuesPerStack[key] = {
 							positiveValues: [],
 							negativeValues: []
 						};
 					}
 
 					// Store these per type
 					var positiveValues = valuesPerStack[key].positiveValues;
 					var negativeValues = valuesPerStack[key].negativeValues;
 
 					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
 						helpers.each(dataset.data, function(rawValue, index) {
 							var value = +me.getRightValue(rawValue);
 							if (isNaN(value) || meta.data[index].hidden) {
 								return;
 							}
 
 							positiveValues[index] = positiveValues[index] || 0;
 							negativeValues[index] = negativeValues[index] || 0;
 
 							if (opts.relativePoints) {
 								positiveValues[index] = 100;
 							} else if (value < 0) {
 								negativeValues[index] += value;
 							} else {
 								positiveValues[index] += value;
 							}
 						});
 					}
 				});
 
 				helpers.each(valuesPerStack, function(valuesForType) {
 					var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
 					var minVal = helpers.min(values);
 					var maxVal = helpers.max(values);
 					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
 					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
 				});
 
 			} else {
 				helpers.each(datasets, function(dataset, datasetIndex) {
 					var meta = chart.getDatasetMeta(datasetIndex);
 					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
 						helpers.each(dataset.data, function(rawValue, index) {
 							var value = +me.getRightValue(rawValue);
 							if (isNaN(value) || meta.data[index].hidden) {
 								return;
 							}
 
 							if (me.min === null) {
 								me.min = value;
 							} else if (value < me.min) {
 								me.min = value;
 							}
 
 							if (me.max === null) {
 								me.max = value;
 							} else if (value > me.max) {
 								me.max = value;
 							}
 						});
 					}
 				});
 			}
 
 			me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
 			me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
 
 			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
 			this.handleTickRangeOptions();
 		},
 		getTickLimit: function() {
 			var maxTicks;
 			var me = this;
 			var tickOpts = me.options.ticks;
 
 			if (me.isHorizontal()) {
 				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
 			} else {
 				// The factor of 2 used to scale the font size has been experimentally determined.
 				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
 				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
 			}
 
 			return maxTicks;
 		},
 		// Called after the ticks are built. We need
 		handleDirectionalChanges: function() {
 			if (!this.isHorizontal()) {
 				// We are in a vertical orientation. The top value is the highest. So reverse the array
 				this.ticks.reverse();
 			}
 		},
 		getLabelForIndex: function(index, datasetIndex) {
 			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
 		},
 		// Utils
 		getPixelForValue: function(value) {
 			// This must be called after fit has been run so that
 			// this.left, this.top, this.right, and this.bottom have been defined
 			var me = this;
 			var start = me.start;
 
 			var rightValue = +me.getRightValue(value);
 			var pixel;
 			var range = me.end - start;
 
 			if (me.isHorizontal()) {
 				pixel = me.left + (me.width / range * (rightValue - start));
 			} else {
 				pixel = me.bottom - (me.height / range * (rightValue - start));
 			}
 			return pixel;
 		},
 		getValueForPixel: function(pixel) {
 			var me = this;
 			var isHorizontal = me.isHorizontal();
 			var innerDimension = isHorizontal ? me.width : me.height;
 			var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
 			return me.start + ((me.end - me.start) * offset);
 		},
 		getPixelForTick: function(index) {
 			return this.getPixelForValue(this.ticksAsNumbers[index]);
 		}
 	});
 	Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
 
 };
 
 },{"25":25,"34":34,"45":45}],55:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 
 /**
  * Generate a set of linear ticks
  * @param generationOptions the options used to generate the ticks
  * @param dataRange the range of the data
  * @returns {Array<Number>} array of tick values
  */
 function generateTicks(generationOptions, dataRange) {
 	var ticks = [];
 	// To get a "nice" value for the tick spacing, we will use the appropriately named
 	// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
 	// for details.
 
 	var spacing;
 	if (generationOptions.stepSize && generationOptions.stepSize > 0) {
 		spacing = generationOptions.stepSize;
 	} else {
 		var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
 		spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
 	}
 	var niceMin = Math.floor(dataRange.min / spacing) * spacing;
 	var niceMax = Math.ceil(dataRange.max / spacing) * spacing;
 
 	// If min, max and stepSize is set and they make an evenly spaced scale use it.
 	if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
 		// If very close to our whole number, use it.
 		if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
 			niceMin = generationOptions.min;
 			niceMax = generationOptions.max;
 		}
 	}
 
 	var numSpaces = (niceMax - niceMin) / spacing;
 	// If very close to our rounded value, use it.
 	if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
 		numSpaces = Math.round(numSpaces);
 	} else {
 		numSpaces = Math.ceil(numSpaces);
 	}
 
 	var precision = 1;
 	if (spacing < 1) {
 		precision = Math.pow(10, spacing.toString().length - 2);
 		niceMin = Math.round(niceMin * precision) / precision;
 		niceMax = Math.round(niceMax * precision) / precision;
 	}
 	ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
 	for (var j = 1; j < numSpaces; ++j) {
 		ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);
 	}
 	ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
 
 	return ticks;
 }
 
 
 module.exports = function(Chart) {
 
 	var noop = helpers.noop;
 
 	Chart.LinearScaleBase = Chart.Scale.extend({
 		getRightValue: function(value) {
 			if (typeof value === 'string') {
 				return +value;
 			}
 			return Chart.Scale.prototype.getRightValue.call(this, value);
 		},
 
 		handleTickRangeOptions: function() {
 			var me = this;
 			var opts = me.options;
 			var tickOpts = opts.ticks;
 
 			// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
 			// do nothing since that would make the chart weird. If the user really wants a weird chart
 			// axis, they can manually override it
 			if (tickOpts.beginAtZero) {
 				var minSign = helpers.sign(me.min);
 				var maxSign = helpers.sign(me.max);
 
 				if (minSign < 0 && maxSign < 0) {
 					// move the top up to 0
 					me.max = 0;
 				} else if (minSign > 0 && maxSign > 0) {
 					// move the bottom down to 0
 					me.min = 0;
 				}
 			}
 
 			var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
 			var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;
 
 			if (tickOpts.min !== undefined) {
 				me.min = tickOpts.min;
 			} else if (tickOpts.suggestedMin !== undefined) {
 				if (me.min === null) {
 					me.min = tickOpts.suggestedMin;
 				} else {
 					me.min = Math.min(me.min, tickOpts.suggestedMin);
 				}
 			}
 
 			if (tickOpts.max !== undefined) {
 				me.max = tickOpts.max;
 			} else if (tickOpts.suggestedMax !== undefined) {
 				if (me.max === null) {
 					me.max = tickOpts.suggestedMax;
 				} else {
 					me.max = Math.max(me.max, tickOpts.suggestedMax);
 				}
 			}
 
 			if (setMin !== setMax) {
 				// We set the min or the max but not both.
 				// So ensure that our range is good
 				// Inverted or 0 length range can happen when
 				// ticks.min is set, and no datasets are visible
 				if (me.min >= me.max) {
 					if (setMin) {
 						me.max = me.min + 1;
 					} else {
 						me.min = me.max - 1;
 					}
 				}
 			}
 
 			if (me.min === me.max) {
 				me.max++;
 
 				if (!tickOpts.beginAtZero) {
 					me.min--;
 				}
 			}
 		},
 		getTickLimit: noop,
 		handleDirectionalChanges: noop,
 
 		buildTicks: function() {
 			var me = this;
 			var opts = me.options;
 			var tickOpts = opts.ticks;
 
 			// Figure out what the max number of ticks we can support it is based on the size of
 			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
 			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
 			// the graph. Make sure we always have at least 2 ticks
 			var maxTicks = me.getTickLimit();
 			maxTicks = Math.max(2, maxTicks);
 
 			var numericGeneratorOptions = {
 				maxTicks: maxTicks,
 				min: tickOpts.min,
 				max: tickOpts.max,
 				stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
 			};
 			var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
 
 			me.handleDirectionalChanges();
 
 			// At this point, we need to update our max and min given the tick values since we have expanded the
 			// range of the scale
 			me.max = helpers.max(ticks);
 			me.min = helpers.min(ticks);
 
 			if (tickOpts.reverse) {
 				ticks.reverse();
 
 				me.start = me.max;
 				me.end = me.min;
 			} else {
 				me.start = me.min;
 				me.end = me.max;
 			}
 		},
 		convertTicksToLabels: function() {
 			var me = this;
 			me.ticksAsNumbers = me.ticks.slice();
 			me.zeroLineIndex = me.ticks.indexOf(0);
 
 			Chart.Scale.prototype.convertTicksToLabels.call(me);
 		}
 	});
 };
 
 },{"45":45}],56:[function(require,module,exports){
 'use strict';
 
 var helpers = require(45);
 var Ticks = require(34);
 
 /**
  * Generate a set of logarithmic ticks
  * @param generationOptions the options used to generate the ticks
  * @param dataRange the range of the data
  * @returns {Array<Number>} array of tick values
  */
 function generateTicks(generationOptions, dataRange) {
 	var ticks = [];
 	var valueOrDefault = helpers.valueOrDefault;
 
 	// Figure out what the max number of ticks we can support it is based on the size of
 	// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
 	// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
 	// the graph
 	var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
 
 	var endExp = Math.floor(helpers.log10(dataRange.max));
 	var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
 	var exp, significand;
 
 	if (tickVal === 0) {
 		exp = Math.floor(helpers.log10(dataRange.minNotZero));
 		significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
 
 		ticks.push(tickVal);
 		tickVal = significand * Math.pow(10, exp);
 	} else {
 		exp = Math.floor(helpers.log10(tickVal));
 		significand = Math.floor(tickVal / Math.pow(10, exp));
 	}
 	var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
 
 	do {
 		ticks.push(tickVal);
 
 		++significand;
 		if (significand === 10) {
 			significand = 1;
 			++exp;
 			precision = exp >= 0 ? 1 : precision;
 		}
 
 		tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
 	} while (exp < endExp || (exp === endExp && significand < endSignificand));
 
 	var lastTick = valueOrDefault(generationOptions.max, tickVal);
 	ticks.push(lastTick);
 
 	return ticks;
 }
 
 
 module.exports = function(Chart) {
 
 	var defaultConfig = {
 		position: 'left',
 
 		// label settings
 		ticks: {
 			callback: Ticks.formatters.logarithmic
 		}
 	};
 
 	var LogarithmicScale = Chart.Scale.extend({
 		determineDataLimits: function() {
 			var me = this;
 			var opts = me.options;
 			var chart = me.chart;
 			var data = chart.data;
 			var datasets = data.datasets;
 			var isHorizontal = me.isHorizontal();
 			function IDMatches(meta) {
 				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
 			}
 
 			// Calculate Range
 			me.min = null;
 			me.max = null;
 			me.minNotZero = null;
 
 			var hasStacks = opts.stacked;
 			if (hasStacks === undefined) {
 				helpers.each(datasets, function(dataset, datasetIndex) {
 					if (hasStacks) {
 						return;
 					}
 
 					var meta = chart.getDatasetMeta(datasetIndex);
 					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
 						meta.stack !== undefined) {
 						hasStacks = true;
 					}
 				});
 			}
 
 			if (opts.stacked || hasStacks) {
 				var valuesPerStack = {};
 
 				helpers.each(datasets, function(dataset, datasetIndex) {
 					var meta = chart.getDatasetMeta(datasetIndex);
 					var key = [
 						meta.type,
 						// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
 						((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
 						meta.stack
 					].join('.');
 
 					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
 						if (valuesPerStack[key] === undefined) {
 							valuesPerStack[key] = [];
 						}
 
 						helpers.each(dataset.data, function(rawValue, index) {
 							var values = valuesPerStack[key];
 							var value = +me.getRightValue(rawValue);
 							// invalid, hidden and negative values are ignored
 							if (isNaN(value) || meta.data[index].hidden || value < 0) {
 								return;
 							}
 							values[index] = values[index] || 0;
 							values[index] += value;
 						});
 					}
 				});
 
 				helpers.each(valuesPerStack, function(valuesForType) {
 					if (valuesForType.length > 0) {
 						var minVal = helpers.min(valuesForType);
 						var maxVal = helpers.max(valuesForType);
 						me.min = me.min === null ? minVal : Math.min(me.min, minVal);
 						me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
 					}
 				});
 
 			} else {
 				helpers.each(datasets, function(dataset, datasetIndex) {
 					var meta = chart.getDatasetMeta(datasetIndex);
 					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
 						helpers.each(dataset.data, function(rawValue, index) {
 							var value = +me.getRightValue(rawValue);
 							// invalid, hidden and negative values are ignored
 							if (isNaN(value) || meta.data[index].hidden || value < 0) {
 								return;
 							}
 
 							if (me.min === null) {
 								me.min = value;
 							} else if (value < me.min) {
 								me.min = value;
 							}
 
 							if (me.max === null) {
 								me.max = value;
 							} else if (value > me.max) {
 								me.max = value;
 							}
 
 							if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
 								me.minNotZero = value;
 							}
 						});
 					}
 				});
 			}
 
 			// Common base implementation to handle ticks.min, ticks.max
 			this.handleTickRangeOptions();
 		},
 		handleTickRangeOptions: function() {
 			var me = this;
 			var opts = me.options;
 			var tickOpts = opts.ticks;
 			var valueOrDefault = helpers.valueOrDefault;
 			var DEFAULT_MIN = 1;
 			var DEFAULT_MAX = 10;
 
 			me.min = valueOrDefault(tickOpts.min, me.min);
 			me.max = valueOrDefault(tickOpts.max, me.max);
 
 			if (me.min === me.max) {
 				if (me.min !== 0 && me.min !== null) {
 					me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
 					me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
 				} else {
 					me.min = DEFAULT_MIN;
 					me.max = DEFAULT_MAX;
 				}
 			}
 			if (me.min === null) {
 				me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);
 			}
 			if (me.max === null) {
 				me.max = me.min !== 0
 					? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)
 					: DEFAULT_MAX;
 			}
 			if (me.minNotZero === null) {
 				if (me.min > 0) {
 					me.minNotZero = me.min;
 				} else if (me.max < 1) {
 					me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));
 				} else {
 					me.minNotZero = DEFAULT_MIN;
 				}
 			}
 		},
 		buildTicks: function() {
 			var me = this;
 			var opts = me.options;
 			var tickOpts = opts.ticks;
 			var reverse = !me.isHorizontal();
 
 			var generationOptions = {
 				min: tickOpts.min,
 				max: tickOpts.max
 			};
 			var ticks = me.ticks = generateTicks(generationOptions, me);
 
 			// At this point, we need to update our max and min given the tick values since we have expanded the
 			// range of the scale
 			me.max = helpers.max(ticks);
 			me.min = helpers.min(ticks);
 
 			if (tickOpts.reverse) {
 				reverse = !reverse;
 				me.start = me.max;
 				me.end = me.min;
 			} else {
 				me.start = me.min;
 				me.end = me.max;
 			}
 			if (reverse) {
 				ticks.reverse();
 			}
 		},
 		convertTicksToLabels: function() {
 			this.tickValues = this.ticks.slice();
 
 			Chart.Scale.prototype.convertTicksToLabels.call(this);
 		},
 		// Get the correct tooltip label
 		getLabelForIndex: function(index, datasetIndex) {
 			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
 		},
 		getPixelForTick: function(index) {
 			return this.getPixelForValue(this.tickValues[index]);
 		},
 		/**
 		 * Returns the value of the first tick.
 		 * @param {Number} value - The minimum not zero value.
 		 * @return {Number} The first tick value.
 		 * @private
 		 */
 		_getFirstTickValue: function(value) {
 			var exp = Math.floor(helpers.log10(value));
 			var significand = Math.floor(value / Math.pow(10, exp));
 
 			return significand * Math.pow(10, exp);
 		},
 		getPixelForValue: function(value) {
 			var me = this;
 			var reverse = me.options.ticks.reverse;
 			var log10 = helpers.log10;
 			var firstTickValue = me._getFirstTickValue(me.minNotZero);
 			var offset = 0;
 			var innerDimension, pixel, start, end, sign;
 
 			value = +me.getRightValue(value);
 			if (reverse) {
 				start = me.end;
 				end = me.start;
 				sign = -1;
 			} else {
 				start = me.start;
 				end = me.end;
 				sign = 1;
 			}
 			if (me.isHorizontal()) {
 				innerDimension = me.width;
 				pixel = reverse ? me.right : me.left;
 			} else {
 				innerDimension = me.height;
 				sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
 				pixel = reverse ? me.top : me.bottom;
 			}
 			if (value !== start) {
 				if (start === 0) { // include zero tick
 					offset = helpers.getValueOrDefault(
 						me.options.ticks.fontSize,
 						Chart.defaults.global.defaultFontSize
 					);
 					innerDimension -= offset;
 					start = firstTickValue;
 				}
 				if (value !== 0) {
 					offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
 				}
 				pixel += sign * offset;
 			}
 			return pixel;
 		},
 		getValueForPixel: function(pixel) {
 			var me = this;
 			var reverse = me.options.ticks.reverse;
 			var log10 = helpers.log10;
 			var firstTickValue = me._getFirstTickValue(me.minNotZero);
 			var innerDimension, start, end, value;
 
 			if (reverse) {
 				start = me.end;
 				end = me.start;
 			} else {
 				start = me.start;
 				end = me.end;
 			}
 			if (me.isHorizontal()) {
 				innerDimension = me.width;
 				value = reverse ? me.right - pixel : pixel - me.left;
 			} else {
 				innerDimension = me.height;
 				value = reverse ? pixel - me.top : me.bottom - pixel;
 			}
 			if (value !== start) {
 				if (start === 0) { // include zero tick
 					var offset = helpers.getValueOrDefault(
 						me.options.ticks.fontSize,
 						Chart.defaults.global.defaultFontSize
 					);
 					value -= offset;
 					innerDimension -= offset;
 					start = firstTickValue;
 				}
 				value *= log10(end) - log10(start);
 				value /= innerDimension;
 				value = Math.pow(10, log10(start) + value);
 			}
 			return value;
 		}
 	});
 	Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
 
 };
 
 },{"34":34,"45":45}],57:[function(require,module,exports){
 'use strict';
 
 var defaults = require(25);
 var helpers = require(45);
 var Ticks = require(34);
 
 module.exports = function(Chart) {
 
 	var globalDefaults = defaults.global;
 
 	var defaultConfig = {
 		display: true,
 
 		// Boolean - Whether to animate scaling the chart from the centre
 		animate: true,
 		position: 'chartArea',
 
 		angleLines: {
 			display: true,
 			color: 'rgba(0, 0, 0, 0.1)',
 			lineWidth: 1
 		},
 
 		gridLines: {
 			circular: false
 		},
 
 		// label settings
 		ticks: {
 			// Boolean - Show a backdrop to the scale label
 			showLabelBackdrop: true,
 
 			// String - The colour of the label backdrop
 			backdropColor: 'rgba(255,255,255,0.75)',
 
 			// Number - The backdrop padding above & below the label in pixels
 			backdropPaddingY: 2,
 
 			// Number - The backdrop padding to the side of the label in pixels
 			backdropPaddingX: 2,
 
 			callback: Ticks.formatters.linear
 		},
 
 		pointLabels: {
 			// Boolean - if true, show point labels
 			display: true,
 
 			// Number - Point label font size in pixels
 			fontSize: 10,
 
 			// Function - Used to convert point labels
 			callback: function(label) {
 				return label;
 			}
 		}
 	};
 
 	function getValueCount(scale) {
 		var opts = scale.options;
 		return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
 	}
 
 	function getPointLabelFontOptions(scale) {
 		var pointLabelOptions = scale.options.pointLabels;
 		var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
 		var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
 		var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
 		var font = helpers.fontString(fontSize, fontStyle, fontFamily);
 
 		return {
 			size: fontSize,
 			style: fontStyle,
 			family: fontFamily,
 			font: font
 		};
 	}
 
 	function measureLabelSize(ctx, fontSize, label) {
 		if (helpers.isArray(label)) {
 			return {
 				w: helpers.longestText(ctx, ctx.font, label),
 				h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
 			};
 		}
 
 		return {
 			w: ctx.measureText(label).width,
 			h: fontSize
 		};
 	}
 
 	function determineLimits(angle, pos, size, min, max) {
 		if (angle === min || angle === max) {
 			return {
 				start: pos - (size / 2),
 				end: pos + (size / 2)
 			};
 		} else if (angle < min || angle > max) {
 			return {
 				start: pos - size - 5,
 				end: pos
 			};
 		}
 
 		return {
 			start: pos,
 			end: pos + size + 5
 		};
 	}
 
 	/**
 	 * Helper function to fit a radial linear scale with point labels
 	 */
 	function fitWithPointLabels(scale) {
 		/*
 		 * Right, this is really confusing and there is a lot of maths going on here
 		 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
 		 *
 		 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
 		 *
 		 * Solution:
 		 *
 		 * We assume the radius of the polygon is half the size of the canvas at first
 		 * at each index we check if the text overlaps.
 		 *
 		 * Where it does, we store that angle and that index.
 		 *
 		 * After finding the largest index and angle we calculate how much we need to remove
 		 * from the shape radius to move the point inwards by that x.
 		 *
 		 * We average the left and right distances to get the maximum shape radius that can fit in the box
 		 * along with labels.
 		 *
 		 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
 		 * on each side, removing that from the size, halving it and adding the left x protrusion width.
 		 *
 		 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
 		 * and position it in the most space efficient manner
 		 *
 		 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
 		 */
 
 		var plFont = getPointLabelFontOptions(scale);
 
 		// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
 		// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
 		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
 		var furthestLimits = {
 			r: scale.width,
 			l: 0,
 			t: scale.height,
 			b: 0
 		};
 		var furthestAngles = {};
 		var i, textSize, pointPosition;
 
 		scale.ctx.font = plFont.font;
 		scale._pointLabelSizes = [];
 
 		var valueCount = getValueCount(scale);
 		for (i = 0; i < valueCount; i++) {
 			pointPosition = scale.getPointPosition(i, largestPossibleRadius);
 			textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
 			scale._pointLabelSizes[i] = textSize;
 
 			// Add quarter circle to make degree 0 mean top of circle
 			var angleRadians = scale.getIndexAngle(i);
 			var angle = helpers.toDegrees(angleRadians) % 360;
 			var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
 			var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
 
 			if (hLimits.start < furthestLimits.l) {
 				furthestLimits.l = hLimits.start;
 				furthestAngles.l = angleRadians;
 			}
 
 			if (hLimits.end > furthestLimits.r) {
 				furthestLimits.r = hLimits.end;
 				furthestAngles.r = angleRadians;
 			}
 
 			if (vLimits.start < furthestLimits.t) {
 				furthestLimits.t = vLimits.start;
 				furthestAngles.t = angleRadians;
 			}
 
 			if (vLimits.end > furthestLimits.b) {
 				furthestLimits.b = vLimits.end;
 				furthestAngles.b = angleRadians;
 			}
 		}
 
 		scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
 	}
 
 	/**
 	 * Helper function to fit a radial linear scale with no point labels
 	 */
 	function fit(scale) {
 		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
 		scale.drawingArea = Math.round(largestPossibleRadius);
 		scale.setCenterPoint(0, 0, 0, 0);
 	}
 
 	function getTextAlignForAngle(angle) {
 		if (angle === 0 || angle === 180) {
 			return 'center';
 		} else if (angle < 180) {
 			return 'left';
 		}
 
 		return 'right';
 	}
 
 	function fillText(ctx, text, position, fontSize) {
 		if (helpers.isArray(text)) {
 			var y = position.y;
 			var spacing = 1.5 * fontSize;
 
 			for (var i = 0; i < text.length; ++i) {
 				ctx.fillText(text[i], position.x, y);
 				y += spacing;
 			}
 		} else {
 			ctx.fillText(text, position.x, position.y);
 		}
 	}
 
 	function adjustPointPositionForLabelHeight(angle, textSize, position) {
 		if (angle === 90 || angle === 270) {
 			position.y -= (textSize.h / 2);
 		} else if (angle > 270 || angle < 90) {
 			position.y -= textSize.h;
 		}
 	}
 
 	function drawPointLabels(scale) {
 		var ctx = scale.ctx;
 		var opts = scale.options;
 		var angleLineOpts = opts.angleLines;
 		var pointLabelOpts = opts.pointLabels;
 
 		ctx.lineWidth = angleLineOpts.lineWidth;
 		ctx.strokeStyle = angleLineOpts.color;
 
 		var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
 
 		// Point Label Font
 		var plFont = getPointLabelFontOptions(scale);
 
 		ctx.textBaseline = 'top';
 
 		for (var i = getValueCount(scale) - 1; i >= 0; i--) {
 			if (angleLineOpts.display) {
 				var outerPosition = scale.getPointPosition(i, outerDistance);
 				ctx.beginPath();
 				ctx.moveTo(scale.xCenter, scale.yCenter);
 				ctx.lineTo(outerPosition.x, outerPosition.y);
 				ctx.stroke();
 				ctx.closePath();
 			}
 
 			if (pointLabelOpts.display) {
 				// Extra 3px out for some label spacing
 				var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);
 
 				// Keep this in loop since we may support array properties here
 				var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
 				ctx.font = plFont.font;
 				ctx.fillStyle = pointLabelFontColor;
 
 				var angleRadians = scale.getIndexAngle(i);
 				var angle = helpers.toDegrees(angleRadians);
 				ctx.textAlign = getTextAlignForAngle(angle);
 				adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
 				fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
 			}
 		}
 	}
 
 	function drawRadiusLine(scale, gridLineOpts, radius, index) {
 		var ctx = scale.ctx;
 		ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
 		ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
 
 		if (scale.options.gridLines.circular) {
 			// Draw circular arcs between the points
 			ctx.beginPath();
 			ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
 			ctx.closePath();
 			ctx.stroke();
 		} else {
 			// Draw straight lines connecting each index
 			var valueCount = getValueCount(scale);
 
 			if (valueCount === 0) {
 				return;
 			}
 
 			ctx.beginPath();
 			var pointPosition = scale.getPointPosition(0, radius);
 			ctx.moveTo(pointPosition.x, pointPosition.y);
 
 			for (var i = 1; i < valueCount; i++) {
 				pointPosition = scale.getPointPosition(i, radius);
 				ctx.lineTo(pointPosition.x, pointPosition.y);
 			}
 
 			ctx.closePath();
 			ctx.stroke();
 		}
 	}
 
 	function numberOrZero(param) {
 		return helpers.isNumber(param) ? param : 0;
 	}
 
 	var LinearRadialScale = Chart.LinearScaleBase.extend({
 		setDimensions: function() {
 			var me = this;
 			var opts = me.options;
 			var tickOpts = opts.ticks;
 			// Set the unconstrained dimension before label rotation
 			me.width = me.maxWidth;
 			me.height = me.maxHeight;
 			me.xCenter = Math.round(me.width / 2);
 			me.yCenter = Math.round(me.height / 2);
 
 			var minSize = helpers.min([me.height, me.width]);
 			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
 			me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
 		},
 		determineDataLimits: function() {
 			var me = this;
 			var chart = me.chart;
 			var min = Number.POSITIVE_INFINITY;
 			var max = Number.NEGATIVE_INFINITY;
 
 			helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
 				if (chart.isDatasetVisible(datasetIndex)) {
 					var meta = chart.getDatasetMeta(datasetIndex);
 
 					helpers.each(dataset.data, function(rawValue, index) {
 						var value = +me.getRightValue(rawValue);
 						if (isNaN(value) || meta.data[index].hidden) {
 							return;
 						}
 
 						min = Math.min(value, min);
 						max = Math.max(value, max);
 					});
 				}
 			});
 
 			me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
 			me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);
 
 			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
 			me.handleTickRangeOptions();
 		},
 		getTickLimit: function() {
 			var tickOpts = this.options.ticks;
 			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
 			return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
 		},
 		convertTicksToLabels: function() {
 			var me = this;
 
 			Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);
 
 			// Point labels
 			me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
 		},
 		getLabelForIndex: function(index, datasetIndex) {
 			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
 		},
 		fit: function() {
 			if (this.options.pointLabels.display) {
 				fitWithPointLabels(this);
 			} else {
 				fit(this);
 			}
 		},
 		/**
 		 * Set radius reductions and determine new radius and center point
 		 * @private
 		 */
 		setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
 			var me = this;
 			var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
 			var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
 			var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
 			var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
 
 			radiusReductionLeft = numberOrZero(radiusReductionLeft);
 			radiusReductionRight = numberOrZero(radiusReductionRight);
 			radiusReductionTop = numberOrZero(radiusReductionTop);
 			radiusReductionBottom = numberOrZero(radiusReductionBottom);
 
 			me.drawingArea = Math.min(
 				Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
 				Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
 			me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
 		},
 		setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
 			var me = this;
 			var maxRight = me.width - rightMovement - me.drawingArea;
 			var maxLeft = leftMovement + me.drawingArea;
 			var maxTop = topMovement + me.drawingArea;
 			var maxBottom = me.height - bottomMovement - me.drawingArea;
 
 			me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
 			me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
 		},
 
 		getIndexAngle: function(index) {
 			var angleMultiplier = (Math.PI * 2) / getValueCount(this);
 			var startAngle = this.chart.options && this.chart.options.startAngle ?
 				this.chart.options.startAngle :
 				0;
 
 			var startAngleRadians = startAngle * Math.PI * 2 / 360;
 
 			// Start from the top instead of right, so remove a quarter of the circle
 			return index * angleMultiplier + startAngleRadians;
 		},
 		getDistanceFromCenterForValue: function(value) {
 			var me = this;
 
 			if (value === null) {
 				return 0; // null always in center
 			}
 
 			// Take into account half font size + the yPadding of the top value
 			var scalingFactor = me.drawingArea / (me.max - me.min);
 			if (me.options.ticks.reverse) {
 				return (me.max - value) * scalingFactor;
 			}
 			return (value - me.min) * scalingFactor;
 		},
 		getPointPosition: function(index, distanceFromCenter) {
 			var me = this;
 			var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
 			return {
 				x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
 				y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
 			};
 		},
 		getPointPositionForValue: function(index, value) {
 			return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
 		},
 
 		getBasePosition: function() {
 			var me = this;
 			var min = me.min;
 			var max = me.max;
 
 			return me.getPointPositionForValue(0,
 				me.beginAtZero ? 0 :
 				min < 0 && max < 0 ? max :
 				min > 0 && max > 0 ? min :
 				0);
 		},
 
 		draw: function() {
 			var me = this;
 			var opts = me.options;
 			var gridLineOpts = opts.gridLines;
 			var tickOpts = opts.ticks;
 			var valueOrDefault = helpers.valueOrDefault;
 
 			if (opts.display) {
 				var ctx = me.ctx;
 				var startAngle = this.getIndexAngle(0);
 
 				// Tick Font
 				var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
 				var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
 				var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
 				var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
 
 				helpers.each(me.ticks, function(label, index) {
 					// Don't draw a centre value (if it is minimum)
 					if (index > 0 || tickOpts.reverse) {
 						var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
 
 						// Draw circular lines around the scale
 						if (gridLineOpts.display && index !== 0) {
 							drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
 						}
 
 						if (tickOpts.display) {
 							var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
 							ctx.font = tickLabelFont;
 
 							ctx.save();
 							ctx.translate(me.xCenter, me.yCenter);
 							ctx.rotate(startAngle);
 
 							if (tickOpts.showLabelBackdrop) {
 								var labelWidth = ctx.measureText(label).width;
 								ctx.fillStyle = tickOpts.backdropColor;
 								ctx.fillRect(
 									-labelWidth / 2 - tickOpts.backdropPaddingX,
 									-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
 									labelWidth + tickOpts.backdropPaddingX * 2,
 									tickFontSize + tickOpts.backdropPaddingY * 2
 								);
 							}
 
 							ctx.textAlign = 'center';
 							ctx.textBaseline = 'middle';
 							ctx.fillStyle = tickFontColor;
 							ctx.fillText(label, 0, -yCenterOffset);
 							ctx.restore();
 						}
 					}
 				});
 
 				if (opts.angleLines.display || opts.pointLabels.display) {
 					drawPointLabels(me);
 				}
 			}
 		}
 	});
 	Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
 
 };
 
 },{"25":25,"34":34,"45":45}],58:[function(require,module,exports){
 /* global window: false */
 'use strict';
 
 var moment = require(1);
 moment = typeof moment === 'function' ? moment : window.moment;
 
 var defaults = require(25);
 var helpers = require(45);
 
 // Integer constants are from the ES6 spec.
 var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
 var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
 
 var INTERVALS = {
 	millisecond: {
 		common: true,
 		size: 1,
 		steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
 	},
 	second: {
 		common: true,
 		size: 1000,
 		steps: [1, 2, 5, 10, 30]
 	},
 	minute: {
 		common: true,
 		size: 60000,
 		steps: [1, 2, 5, 10, 30]
 	},
 	hour: {
 		common: true,
 		size: 3600000,
 		steps: [1, 2, 3, 6, 12]
 	},
 	day: {
 		common: true,
 		size: 86400000,
 		steps: [1, 2, 5]
 	},
 	week: {
 		common: false,
 		size: 604800000,
 		steps: [1, 2, 3, 4]
 	},
 	month: {
 		common: true,
 		size: 2.628e9,
 		steps: [1, 2, 3]
 	},
 	quarter: {
 		common: false,
 		size: 7.884e9,
 		steps: [1, 2, 3, 4]
 	},
 	year: {
 		common: true,
 		size: 3.154e10
 	}
 };
 
 var UNITS = Object.keys(INTERVALS);
 
 function sorter(a, b) {
 	return a - b;
 }
 
 function arrayUnique(items) {
 	var hash = {};
 	var out = [];
 	var i, ilen, item;
 
 	for (i = 0, ilen = items.length; i < ilen; ++i) {
 		item = items[i];
 		if (!hash[item]) {
 			hash[item] = true;
 			out.push(item);
 		}
 	}
 
 	return out;
 }
 
 /**
  * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
  * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
  * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
  * extremity (left + width or top + height). Note that it would be more optimized to directly
  * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
  * to create the lookup table. The table ALWAYS contains at least two items: min and max.
  *
  * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
  * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
  * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
  * If 'series', timestamps will be positioned at the same distance from each other. In this
  * case, only timestamps that break the time linearity are registered, meaning that in the
  * best case, all timestamps are linear, the table contains only min and max.
  */
 function buildLookupTable(timestamps, min, max, distribution) {
 	if (distribution === 'linear' || !timestamps.length) {
 		return [
 			{time: min, pos: 0},
 			{time: max, pos: 1}
 		];
 	}
 
 	var table = [];
 	var items = [min];
 	var i, ilen, prev, curr, next;
 
 	for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
 		curr = timestamps[i];
 		if (curr > min && curr < max) {
 			items.push(curr);
 		}
 	}
 
 	items.push(max);
 
 	for (i = 0, ilen = items.length; i < ilen; ++i) {
 		next = items[i + 1];
 		prev = items[i - 1];
 		curr = items[i];
 
 		// only add points that breaks the scale linearity
 		if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
 			table.push({time: curr, pos: i / (ilen - 1)});
 		}
 	}
 
 	return table;
 }
 
 // @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
 function lookup(table, key, value) {
 	var lo = 0;
 	var hi = table.length - 1;
 	var mid, i0, i1;
 
 	while (lo >= 0 && lo <= hi) {
 		mid = (lo + hi) >> 1;
 		i0 = table[mid - 1] || null;
 		i1 = table[mid];
 
 		if (!i0) {
 			// given value is outside table (before first item)
 			return {lo: null, hi: i1};
 		} else if (i1[key] < value) {
 			lo = mid + 1;
 		} else if (i0[key] > value) {
 			hi = mid - 1;
 		} else {
 			return {lo: i0, hi: i1};
 		}
 	}
 
 	// given value is outside table (after last item)
 	return {lo: i1, hi: null};
 }
 
 /**
  * Linearly interpolates the given source `value` using the table items `skey` values and
  * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
  * returns the position for a timestamp equal to 42. If value is out of bounds, values at
  * index [0, 1] or [n - 1, n] are used for the interpolation.
  */
 function interpolate(table, skey, sval, tkey) {
 	var range = lookup(table, skey, sval);
 
 	// Note: the lookup table ALWAYS contains at least 2 items (min and max)
 	var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
 	var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
 
 	var span = next[skey] - prev[skey];
 	var ratio = span ? (sval - prev[skey]) / span : 0;
 	var offset = (next[tkey] - prev[tkey]) * ratio;
 
 	return prev[tkey] + offset;
 }
 
 /**
  * Convert the given value to a moment object using the given time options.
  * @see http://momentjs.com/docs/#/parsing/
  */
 function momentify(value, options) {
 	var parser = options.parser;
 	var format = options.parser || options.format;
 
 	if (typeof parser === 'function') {
 		return parser(value);
 	}
 
 	if (typeof value === 'string' && typeof format === 'string') {
 		return moment(value, format);
 	}
 
 	if (!(value instanceof moment)) {
 		value = moment(value);
 	}
 
 	if (value.isValid()) {
 		return value;
 	}
 
 	// Labels are in an incompatible moment format and no `parser` has been provided.
 	// The user might still use the deprecated `format` option to convert his inputs.
 	if (typeof format === 'function') {
 		return format(value);
 	}
 
 	return value;
 }
 
 function parse(input, scale) {
 	if (helpers.isNullOrUndef(input)) {
 		return null;
 	}
 
 	var options = scale.options.time;
 	var value = momentify(scale.getRightValue(input), options);
 	if (!value.isValid()) {
 		return null;
 	}
 
 	if (options.round) {
 		value.startOf(options.round);
 	}
 
 	return value.valueOf();
 }
 
 /**
  * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
  * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
  */
 function determineStepSize(min, max, unit, capacity) {
 	var range = max - min;
 	var interval = INTERVALS[unit];
 	var milliseconds = interval.size;
 	var steps = interval.steps;
 	var i, ilen, factor;
 
 	if (!steps) {
 		return Math.ceil(range / (capacity * milliseconds));
 	}
 
 	for (i = 0, ilen = steps.length; i < ilen; ++i) {
 		factor = steps[i];
 		if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
 			break;
 		}
 	}
 
 	return factor;
 }
 
 /**
  * Figures out what unit results in an appropriate number of auto-generated ticks
  */
 function determineUnitForAutoTicks(minUnit, min, max, capacity) {
 	var ilen = UNITS.length;
 	var i, interval, factor;
 
 	for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
 		interval = INTERVALS[UNITS[i]];
 		factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;
 
 		if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
 			return UNITS[i];
 		}
 	}
 
 	return UNITS[ilen - 1];
 }
 
 /**
  * Figures out what unit to format a set of ticks with
  */
 function determineUnitForFormatting(ticks, minUnit, min, max) {
 	var duration = moment.duration(moment(max).diff(moment(min)));
 	var ilen = UNITS.length;
 	var i, unit;
 
 	for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
 		unit = UNITS[i];
 		if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
 			return unit;
 		}
 	}
 
 	return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
 }
 
 function determineMajorUnit(unit) {
 	for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
 		if (INTERVALS[UNITS[i]].common) {
 			return UNITS[i];
 		}
 	}
 }
 
 /**
  * Generates a maximum of `capacity` timestamps between min and max, rounded to the
  * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
  * Important: this method can return ticks outside the min and max range, it's the
  * responsibility of the calling code to clamp values if needed.
  */
 function generate(min, max, capacity, options) {
 	var timeOpts = options.time;
 	var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
 	var major = determineMajorUnit(minor);
 	var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
 	var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
 	var majorTicksEnabled = options.ticks.major.enabled;
 	var interval = INTERVALS[minor];
 	var first = moment(min);
 	var last = moment(max);
 	var ticks = [];
 	var time;
 
 	if (!stepSize) {
 		stepSize = determineStepSize(min, max, minor, capacity);
 	}
 
 	// For 'week' unit, handle the first day of week option
 	if (weekday) {
 		first = first.isoWeekday(weekday);
 		last = last.isoWeekday(weekday);
 	}
 
 	// Align first/last ticks on unit
 	first = first.startOf(weekday ? 'day' : minor);
 	last = last.startOf(weekday ? 'day' : minor);
 
 	// Make sure that the last tick include max
 	if (last < max) {
 		last.add(1, minor);
 	}
 
 	time = moment(first);
 
 	if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
 		// Align the first tick on the previous `minor` unit aligned on the `major` unit:
 		// we first aligned time on the previous `major` unit then add the number of full
 		// stepSize there is between first and the previous major time.
 		time.startOf(major);
 		time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
 	}
 
 	for (; time < last; time.add(stepSize, minor)) {
 		ticks.push(+time);
 	}
 
 	ticks.push(+time);
 
 	return ticks;
 }
 
 /**
  * Returns the right and left offsets from edges in the form of {left, right}.
  * Offsets are added when the `offset` option is true.
  */
 function computeOffsets(table, ticks, min, max, options) {
 	var left = 0;
 	var right = 0;
 	var upper, lower;
 
 	if (options.offset && ticks.length) {
 		if (!options.time.min) {
 			upper = ticks.length > 1 ? ticks[1] : max;
 			lower = ticks[0];
 			left = (
 				interpolate(table, 'time', upper, 'pos') -
 				interpolate(table, 'time', lower, 'pos')
 			) / 2;
 		}
 		if (!options.time.max) {
 			upper = ticks[ticks.length - 1];
 			lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
 			right = (
 				interpolate(table, 'time', upper, 'pos') -
 				interpolate(table, 'time', lower, 'pos')
 			) / 2;
 		}
 	}
 
 	return {left: left, right: right};
 }
 
 function ticksFromTimestamps(values, majorUnit) {
 	var ticks = [];
 	var i, ilen, value, major;
 
 	for (i = 0, ilen = values.length; i < ilen; ++i) {
 		value = values[i];
 		major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;
 
 		ticks.push({
 			value: value,
 			major: major
 		});
 	}
 
 	return ticks;
 }
 
 function determineLabelFormat(data, timeOpts) {
 	var i, momentDate, hasTime;
 	var ilen = data.length;
 
 	// find the label with the most parts (milliseconds, minutes, etc.)
 	// format all labels with the same level of detail as the most specific label
 	for (i = 0; i < ilen; i++) {
 		momentDate = momentify(data[i], timeOpts);
 		if (momentDate.millisecond() !== 0) {
 			return 'MMM D, YYYY h:mm:ss.SSS a';
 		}
 		if (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {
 			hasTime = true;
 		}
 	}
 	if (hasTime) {
 		return 'MMM D, YYYY h:mm:ss a';
 	}
 	return 'MMM D, YYYY';
 }
 
 module.exports = function(Chart) {
 
 	var defaultConfig = {
 		position: 'bottom',
 
 		/**
 		 * Data distribution along the scale:
 		 * - 'linear': data are spread according to their time (distances can vary),
 		 * - 'series': data are spread at the same distance from each other.
 		 * @see https://github.com/chartjs/Chart.js/pull/4507
 		 * @since 2.7.0
 		 */
 		distribution: 'linear',
 
 		/**
 		 * Scale boundary strategy (bypassed by min/max time options)
 		 * - `data`: make sure data are fully visible, ticks outside are removed
 		 * - `ticks`: make sure ticks are fully visible, data outside are truncated
 		 * @see https://github.com/chartjs/Chart.js/pull/4556
 		 * @since 2.7.0
 		 */
 		bounds: 'data',
 
 		time: {
 			parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
 			format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
 			unit: false, // false == automatic or override with week, month, year, etc.
 			round: false, // none, or override with week, month, year, etc.
 			displayFormat: false, // DEPRECATED
 			isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
 			minUnit: 'millisecond',
 
 			// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
 			displayFormats: {
 				millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
 				second: 'h:mm:ss a', // 11:20:01 AM
 				minute: 'h:mm a', // 11:20 AM
 				hour: 'hA', // 5PM
 				day: 'MMM D', // Sep 4
 				week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
 				month: 'MMM YYYY', // Sept 2015
 				quarter: '[Q]Q - YYYY', // Q3
 				year: 'YYYY' // 2015
 			},
 		},
 		ticks: {
 			autoSkip: false,
 
 			/**
 			 * Ticks generation input values:
 			 * - 'auto': generates "optimal" ticks based on scale size and time options.
 			 * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
 			 * - 'labels': generates ticks from user given `data.labels` values ONLY.
 			 * @see https://github.com/chartjs/Chart.js/pull/4507
 			 * @since 2.7.0
 			 */
 			source: 'auto',
 
 			major: {
 				enabled: false
 			}
 		}
 	};
 
 	var TimeScale = Chart.Scale.extend({
 		initialize: function() {
 			if (!moment) {
 				throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
 			}
 
 			this.mergeTicksOptions();
 
 			Chart.Scale.prototype.initialize.call(this);
 		},
 
 		update: function() {
 			var me = this;
 			var options = me.options;
 
 			// DEPRECATIONS: output a message only one time per update
 			if (options.time && options.time.format) {
 				console.warn('options.time.format is deprecated and replaced by options.time.parser.');
 			}
 
 			return Chart.Scale.prototype.update.apply(me, arguments);
 		},
 
 		/**
 		 * Allows data to be referenced via 't' attribute
 		 */
 		getRightValue: function(rawValue) {
 			if (rawValue && rawValue.t !== undefined) {
 				rawValue = rawValue.t;
 			}
 			return Chart.Scale.prototype.getRightValue.call(this, rawValue);
 		},
 
 		determineDataLimits: function() {
 			var me = this;
 			var chart = me.chart;
 			var timeOpts = me.options.time;
 			var unit = timeOpts.unit || 'day';
 			var min = MAX_INTEGER;
 			var max = MIN_INTEGER;
 			var timestamps = [];
 			var datasets = [];
 			var labels = [];
 			var i, j, ilen, jlen, data, timestamp;
 
 			// Convert labels to timestamps
 			for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
 				labels.push(parse(chart.data.labels[i], me));
 			}
 
 			// Convert data to timestamps
 			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
 				if (chart.isDatasetVisible(i)) {
 					data = chart.data.datasets[i].data;
 
 					// Let's consider that all data have the same format.
 					if (helpers.isObject(data[0])) {
 						datasets[i] = [];
 
 						for (j = 0, jlen = data.length; j < jlen; ++j) {
 							timestamp = parse(data[j], me);
 							timestamps.push(timestamp);
 							datasets[i][j] = timestamp;
 						}
 					} else {
 						timestamps.push.apply(timestamps, labels);
 						datasets[i] = labels.slice(0);
 					}
 				} else {
 					datasets[i] = [];
 				}
 			}
 
 			if (labels.length) {
 				// Sort labels **after** data have been converted
 				labels = arrayUnique(labels).sort(sorter);
 				min = Math.min(min, labels[0]);
 				max = Math.max(max, labels[labels.length - 1]);
 			}
 
 			if (timestamps.length) {
 				timestamps = arrayUnique(timestamps).sort(sorter);
 				min = Math.min(min, timestamps[0]);
 				max = Math.max(max, timestamps[timestamps.length - 1]);
 			}
 
 			min = parse(timeOpts.min, me) || min;
 			max = parse(timeOpts.max, me) || max;
 
 			// In case there is no valid min/max, set limits based on unit time option
 			min = min === MAX_INTEGER ? +moment().startOf(unit) : min;
 			max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;
 
 			// Make sure that max is strictly higher than min (required by the lookup table)
 			me.min = Math.min(min, max);
 			me.max = Math.max(min + 1, max);
 
 			// PRIVATE
 			me._horizontal = me.isHorizontal();
 			me._table = [];
 			me._timestamps = {
 				data: timestamps,
 				datasets: datasets,
 				labels: labels
 			};
 		},
 
 		buildTicks: function() {
 			var me = this;
 			var min = me.min;
 			var max = me.max;
 			var options = me.options;
 			var timeOpts = options.time;
 			var timestamps = [];
 			var ticks = [];
 			var i, ilen, timestamp;
 
 			switch (options.ticks.source) {
 			case 'data':
 				timestamps = me._timestamps.data;
 				break;
 			case 'labels':
 				timestamps = me._timestamps.labels;
 				break;
 			case 'auto':
 			default:
 				timestamps = generate(min, max, me.getLabelCapacity(min), options);
 			}
 
 			if (options.bounds === 'ticks' && timestamps.length) {
 				min = timestamps[0];
 				max = timestamps[timestamps.length - 1];
 			}
 
 			// Enforce limits with user min/max options
 			min = parse(timeOpts.min, me) || min;
 			max = parse(timeOpts.max, me) || max;
 
 			// Remove ticks outside the min/max range
 			for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
 				timestamp = timestamps[i];
 				if (timestamp >= min && timestamp <= max) {
 					ticks.push(timestamp);
 				}
 			}
 
 			me.min = min;
 			me.max = max;
 
 			// PRIVATE
 			me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
 			me._majorUnit = determineMajorUnit(me._unit);
 			me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
 			me._offsets = computeOffsets(me._table, ticks, min, max, options);
 			me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);
 
 			return ticksFromTimestamps(ticks, me._majorUnit);
 		},
 
 		getLabelForIndex: function(index, datasetIndex) {
 			var me = this;
 			var data = me.chart.data;
 			var timeOpts = me.options.time;
 			var label = data.labels && index < data.labels.length ? data.labels[index] : '';
 			var value = data.datasets[datasetIndex].data[index];
 
 			if (helpers.isObject(value)) {
 				label = me.getRightValue(value);
 			}
 			if (timeOpts.tooltipFormat) {
 				return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
 			}
 			if (typeof label === 'string') {
 				return label;
 			}
 
 			return momentify(label, timeOpts).format(me._labelFormat);
 		},
 
 		/**
 		 * Function to format an individual tick mark
 		 * @private
 		 */
 		tickFormatFunction: function(tick, index, ticks, formatOverride) {
 			var me = this;
 			var options = me.options;
 			var time = tick.valueOf();
 			var formats = options.time.displayFormats;
 			var minorFormat = formats[me._unit];
 			var majorUnit = me._majorUnit;
 			var majorFormat = formats[majorUnit];
 			var majorTime = tick.clone().startOf(majorUnit).valueOf();
 			var majorTickOpts = options.ticks.major;
 			var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
 			var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
 			var tickOpts = major ? majorTickOpts : options.ticks.minor;
 			var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);
 
 			return formatter ? formatter(label, index, ticks) : label;
 		},
 
 		convertTicksToLabels: function(ticks) {
 			var labels = [];
 			var i, ilen;
 
 			for (i = 0, ilen = ticks.length; i < ilen; ++i) {
 				labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
 			}
 
 			return labels;
 		},
 
 		/**
 		 * @private
 		 */
 		getPixelForOffset: function(time) {
 			var me = this;
 			var size = me._horizontal ? me.width : me.height;
 			var start = me._horizontal ? me.left : me.top;
 			var pos = interpolate(me._table, 'time', time, 'pos');
 
 			return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
 		},
 
 		getPixelForValue: function(value, index, datasetIndex) {
 			var me = this;
 			var time = null;
 
 			if (index !== undefined && datasetIndex !== undefined) {
 				time = me._timestamps.datasets[datasetIndex][index];
 			}
 
 			if (time === null) {
 				time = parse(value, me);
 			}
 
 			if (time !== null) {
 				return me.getPixelForOffset(time);
 			}
 		},
 
 		getPixelForTick: function(index) {
 			var ticks = this.getTicks();
 			return index >= 0 && index < ticks.length ?
 				this.getPixelForOffset(ticks[index].value) :
 				null;
 		},
 
 		getValueForPixel: function(pixel) {
 			var me = this;
 			var size = me._horizontal ? me.width : me.height;
 			var start = me._horizontal ? me.left : me.top;
 			var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
 			var time = interpolate(me._table, 'pos', pos, 'time');
 
 			return moment(time);
 		},
 
 		/**
 		 * Crude approximation of what the label width might be
 		 * @private
 		 */
 		getLabelWidth: function(label) {
 			var me = this;
 			var ticksOpts = me.options.ticks;
 			var tickLabelWidth = me.ctx.measureText(label).width;
 			var angle = helpers.toRadians(ticksOpts.maxRotation);
 			var cosRotation = Math.cos(angle);
 			var sinRotation = Math.sin(angle);
 			var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);
 
 			return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
 		},
 
 		/**
 		 * @private
 		 */
 		getLabelCapacity: function(exampleTime) {
 			var me = this;
 
 			var formatOverride = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation
 
 			var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
 			var tickLabelWidth = me.getLabelWidth(exampleLabel);
 			var innerWidth = me.isHorizontal() ? me.width : me.height;
 
 			var capacity = Math.floor(innerWidth / tickLabelWidth);
 			return capacity > 0 ? capacity : 1;
 		}
 	});
 
 	Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
 };
 
 },{"1":1,"25":25,"45":45}]},{},[7])(7)
 });
 </script>  
<script type="text/javascript">  
 function show(obj) {
   document.getElementById(obj).style.display='block'; 
   document.getElementById("hide_" + obj).style.display=''; 
   document.getElementById("show_" + obj).style.display='none'; 
 } 
 function hide(obj) { 
   document.getElementById(obj).style.display='none'; 
   document.getElementById("hide_" + obj).style.display='none'; 
   document.getElementById("show_" + obj).style.display=''; 
 } 
 </script>  
<script type="text/javascript">  
 /*!
  * jQuery JavaScript Library v1.12.4
  * http://jquery.com/
  *
  * Includes Sizzle.js
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2016-05-20T17:17Z
  */
 
 (function( global, factory ) {
 
 	if ( typeof module === "object" && typeof module.exports === "object" ) {
 		// For CommonJS and CommonJS-like environments where a proper `window`
 		// is present, execute the factory and get jQuery.
 		// For environments that do not have a `window` with a `document`
 		// (such as Node.js), expose a factory as module.exports.
 		// This accentuates the need for the creation of a real `window`.
 		// e.g. var jQuery = require("jquery")(window);
 		// See ticket #14549 for more info.
 		module.exports = global.document ?
 			factory( global, true ) :
 			function( w ) {
 				if ( !w.document ) {
 					throw new Error( "jQuery requires a window with a document" );
 				}
 				return factory( w );
 			};
 	} else {
 		factory( global );
 	}
 
 // Pass this if window is not defined yet
 }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
 
 // Support: Firefox 18+
 // Can't be in strict mode, several libs including ASP.NET trace
 // the stack via arguments.caller.callee and Firefox dies if
 // you try to trace through "use strict" call chains. (#13335)
 //"use strict";
 var deletedIds = [];
 
 var document = window.document;
 
 var slice = deletedIds.slice;
 
 var concat = deletedIds.concat;
 
 var push = deletedIds.push;
 
 var indexOf = deletedIds.indexOf;
 
 var class2type = {};
 
 var toString = class2type.toString;
 
 var hasOwn = class2type.hasOwnProperty;
 
 var support = {};
 
 
 
 var
 	version = "1.12.4",
 
 	// Define a local copy of jQuery
 	jQuery = function( selector, context ) {
 
 		// The jQuery object is actually just the init constructor 'enhanced'
 		// Need init if jQuery is called (just allow error to be thrown if not included)
 		return new jQuery.fn.init( selector, context );
 	},
 
 	// Support: Android<4.1, IE<9
 	// Make sure we trim BOM and NBSP
 	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
 
 	// Matches dashed string for camelizing
 	rmsPrefix = /^-ms-/,
 	rdashAlpha = /-([\da-z])/gi,
 
 	// Used by jQuery.camelCase as callback to replace()
 	fcamelCase = function( all, letter ) {
 		return letter.toUpperCase();
 	};
 
 jQuery.fn = jQuery.prototype = {
 
 	// The current version of jQuery being used
 	jquery: version,
 
 	constructor: jQuery,
 
 	// Start with an empty selector
 	selector: "",
 
 	// The default length of a jQuery object is 0
 	length: 0,
 
 	toArray: function() {
 		return slice.call( this );
 	},
 
 	// Get the Nth element in the matched element set OR
 	// Get the whole matched element set as a clean array
 	get: function( num ) {
 		return num != null ?
 
 			// Return just the one element from the set
 			( num < 0 ? this[ num + this.length ] : this[ num ] ) :
 
 			// Return all the elements in a clean array
 			slice.call( this );
 	},
 
 	// Take an array of elements and push it onto the stack
 	// (returning the new matched element set)
 	pushStack: function( elems ) {
 
 		// Build a new jQuery matched element set
 		var ret = jQuery.merge( this.constructor(), elems );
 
 		// Add the old object onto the stack (as a reference)
 		ret.prevObject = this;
 		ret.context = this.context;
 
 		// Return the newly-formed element set
 		return ret;
 	},
 
 	// Execute a callback for every element in the matched set.
 	each: function( callback ) {
 		return jQuery.each( this, callback );
 	},
 
 	map: function( callback ) {
 		return this.pushStack( jQuery.map( this, function( elem, i ) {
 			return callback.call( elem, i, elem );
 		} ) );
 	},
 
 	slice: function() {
 		return this.pushStack( slice.apply( this, arguments ) );
 	},
 
 	first: function() {
 		return this.eq( 0 );
 	},
 
 	last: function() {
 		return this.eq( -1 );
 	},
 
 	eq: function( i ) {
 		var len = this.length,
 			j = +i + ( i < 0 ? len : 0 );
 		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
 	},
 
 	end: function() {
 		return this.prevObject || this.constructor();
 	},
 
 	// For internal use only.
 	// Behaves like an Array's method, not like a jQuery method.
 	push: push,
 	sort: deletedIds.sort,
 	splice: deletedIds.splice
 };
 
 jQuery.extend = jQuery.fn.extend = function() {
 	var src, copyIsArray, copy, name, options, clone,
 		target = arguments[ 0 ] || {},
 		i = 1,
 		length = arguments.length,
 		deep = false;
 
 	// Handle a deep copy situation
 	if ( typeof target === "boolean" ) {
 		deep = target;
 
 		// skip the boolean and the target
 		target = arguments[ i ] || {};
 		i++;
 	}
 
 	// Handle case when target is a string or something (possible in deep copy)
 	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
 		target = {};
 	}
 
 	// extend jQuery itself if only one argument is passed
 	if ( i === length ) {
 		target = this;
 		i--;
 	}
 
 	for ( ; i < length; i++ ) {
 
 		// Only deal with non-null/undefined values
 		if ( ( options = arguments[ i ] ) != null ) {
 
 			// Extend the base object
 			for ( name in options ) {
 				src = target[ name ];
 				copy = options[ name ];
 
 				// Prevent never-ending loop
 				if ( target === copy ) {
 					continue;
 				}
 
 				// Recurse if we're merging plain objects or arrays
 				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
 					( copyIsArray = jQuery.isArray( copy ) ) ) ) {
 
 					if ( copyIsArray ) {
 						copyIsArray = false;
 						clone = src && jQuery.isArray( src ) ? src : [];
 
 					} else {
 						clone = src && jQuery.isPlainObject( src ) ? src : {};
 					}
 
 					// Never move original objects, clone them
 					target[ name ] = jQuery.extend( deep, clone, copy );
 
 				// Don't bring in undefined values
 				} else if ( copy !== undefined ) {
 					target[ name ] = copy;
 				}
 			}
 		}
 	}
 
 	// Return the modified object
 	return target;
 };
 
 jQuery.extend( {
 
 	// Unique for each copy of jQuery on the page
 	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
 
 	// Assume jQuery is ready without the ready module
 	isReady: true,
 
 	error: function( msg ) {
 		throw new Error( msg );
 	},
 
 	noop: function() {},
 
 	// See test/unit/core.js for details concerning isFunction.
 	// Since version 1.3, DOM methods and functions like alert
 	// aren't supported. They return false on IE (#2968).
 	isFunction: function( obj ) {
 		return jQuery.type( obj ) === "function";
 	},
 
 	isArray: Array.isArray || function( obj ) {
 		return jQuery.type( obj ) === "array";
 	},
 
 	isWindow: function( obj ) {
 		/* jshint eqeqeq: false */
 		return obj != null && obj == obj.window;
 	},
 
 	isNumeric: function( obj ) {
 
 		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
 		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
 		// subtraction forces infinities to NaN
 		// adding 1 corrects loss of precision from parseFloat (#15100)
 		var realStringObj = obj && obj.toString();
 		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
 	},
 
 	isEmptyObject: function( obj ) {
 		var name;
 		for ( name in obj ) {
 			return false;
 		}
 		return true;
 	},
 
 	isPlainObject: function( obj ) {
 		var key;
 
 		// Must be an Object.
 		// Because of IE, we also have to check the presence of the constructor property.
 		// Make sure that DOM nodes and window objects don't pass through, as well
 		if ( !obj || jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
 			return false;
 		}
 
 		try {
 
 			// Not own constructor property must be Object
 			if ( obj.constructor &&
 				!hasOwn.call( obj, "constructor" ) &&
 				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
 				return false;
 			}
 		} catch ( e ) {
 
 			// IE8,9 Will throw exceptions on certain host objects #9897
 			return false;
 		}
 
 		// Support: IE<9
 		// Handle iteration over inherited properties before own properties.
 		if ( !support.ownFirst ) {
 			for ( key in obj ) {
 				return hasOwn.call( obj, key );
 			}
 		}
 
 		// Own properties are enumerated firstly, so to speed up,
 		// if last one is own, then all properties are own.
 		for ( key in obj ) {}
 
 		return key === undefined || hasOwn.call( obj, key );
 	},
 
 	type: function( obj ) {
 		if ( obj == null ) {
 			return obj + "";
 		}
 		return typeof obj === "object" || typeof obj === "function" ?
 			class2type[ toString.call( obj ) ] || "object" :
 			typeof obj;
 	},
 
 	// Workarounds based on findings by Jim Driscoll
 	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
 	globalEval: function( data ) {
 		if ( data && jQuery.trim( data ) ) {
 
 			// We use execScript on Internet Explorer
 			// We use an anonymous function so that context is window
 			// rather than jQuery in Firefox
 			( window.execScript || function( data ) {
 				window[ "eval" ].call( window, data ); // jscs:ignore requireDotNotation
 			} )( data );
 		}
 	},
 
 	// Convert dashed to camelCase; used by the css and data modules
 	// Microsoft forgot to hump their vendor prefix (#9572)
 	camelCase: function( string ) {
 		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
 	},
 
 	nodeName: function( elem, name ) {
 		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
 	},
 
 	each: function( obj, callback ) {
 		var length, i = 0;
 
 		if ( isArrayLike( obj ) ) {
 			length = obj.length;
 			for ( ; i < length; i++ ) {
 				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
 					break;
 				}
 			}
 		} else {
 			for ( i in obj ) {
 				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
 					break;
 				}
 			}
 		}
 
 		return obj;
 	},
 
 	// Support: Android<4.1, IE<9
 	trim: function( text ) {
 		return text == null ?
 			"" :
 			( text + "" ).replace( rtrim, "" );
 	},
 
 	// results is for internal usage only
 	makeArray: function( arr, results ) {
 		var ret = results || [];
 
 		if ( arr != null ) {
 			if ( isArrayLike( Object( arr ) ) ) {
 				jQuery.merge( ret,
 					typeof arr === "string" ?
 					[ arr ] : arr
 				);
 			} else {
 				push.call( ret, arr );
 			}
 		}
 
 		return ret;
 	},
 
 	inArray: function( elem, arr, i ) {
 		var len;
 
 		if ( arr ) {
 			if ( indexOf ) {
 				return indexOf.call( arr, elem, i );
 			}
 
 			len = arr.length;
 			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
 
 			for ( ; i < len; i++ ) {
 
 				// Skip accessing in sparse arrays
 				if ( i in arr && arr[ i ] === elem ) {
 					return i;
 				}
 			}
 		}
 
 		return -1;
 	},
 
 	merge: function( first, second ) {
 		var len = +second.length,
 			j = 0,
 			i = first.length;
 
 		while ( j < len ) {
 			first[ i++ ] = second[ j++ ];
 		}
 
 		// Support: IE<9
 		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
 		if ( len !== len ) {
 			while ( second[ j ] !== undefined ) {
 				first[ i++ ] = second[ j++ ];
 			}
 		}
 
 		first.length = i;
 
 		return first;
 	},
 
 	grep: function( elems, callback, invert ) {
 		var callbackInverse,
 			matches = [],
 			i = 0,
 			length = elems.length,
 			callbackExpect = !invert;
 
 		// Go through the array, only saving the items
 		// that pass the validator function
 		for ( ; i < length; i++ ) {
 			callbackInverse = !callback( elems[ i ], i );
 			if ( callbackInverse !== callbackExpect ) {
 				matches.push( elems[ i ] );
 			}
 		}
 
 		return matches;
 	},
 
 	// arg is for internal usage only
 	map: function( elems, callback, arg ) {
 		var length, value,
 			i = 0,
 			ret = [];
 
 		// Go through the array, translating each of the items to their new values
 		if ( isArrayLike( elems ) ) {
 			length = elems.length;
 			for ( ; i < length; i++ ) {
 				value = callback( elems[ i ], i, arg );
 
 				if ( value != null ) {
 					ret.push( value );
 				}
 			}
 
 		// Go through every key on the object,
 		} else {
 			for ( i in elems ) {
 				value = callback( elems[ i ], i, arg );
 
 				if ( value != null ) {
 					ret.push( value );
 				}
 			}
 		}
 
 		// Flatten any nested arrays
 		return concat.apply( [], ret );
 	},
 
 	// A global GUID counter for objects
 	guid: 1,
 
 	// Bind a function to a context, optionally partially applying any
 	// arguments.
 	proxy: function( fn, context ) {
 		var args, proxy, tmp;
 
 		if ( typeof context === "string" ) {
 			tmp = fn[ context ];
 			context = fn;
 			fn = tmp;
 		}
 
 		// Quick check to determine if target is callable, in the spec
 		// this throws a TypeError, but we will just return undefined.
 		if ( !jQuery.isFunction( fn ) ) {
 			return undefined;
 		}
 
 		// Simulated bind
 		args = slice.call( arguments, 2 );
 		proxy = function() {
 			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
 		};
 
 		// Set the guid of unique handler to the same of original handler, so it can be removed
 		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
 
 		return proxy;
 	},
 
 	now: function() {
 		return +( new Date() );
 	},
 
 	// jQuery.support is not used in Core but other projects attach their
 	// properties to it so it needs to exist.
 	support: support
 } );
 
 // JSHint would error on this code due to the Symbol not being defined in ES5.
 // Defining this global in .jshintrc would create a danger of using the global
 // unguarded in another place, it seems safer to just disable JSHint for these
 // three lines.
 /* jshint ignore: start */
 if ( typeof Symbol === "function" ) {
 	jQuery.fn[ Symbol.iterator ] = deletedIds[ Symbol.iterator ];
 }
 /* jshint ignore: end */
 
 // Populate the class2type map
 jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
 function( i, name ) {
 	class2type[ "[object " + name + "]" ] = name.toLowerCase();
 } );
 
 function isArrayLike( obj ) {
 
 	// Support: iOS 8.2 (not reproducible in simulator)
 	// `in` check used to prevent JIT error (gh-2145)
 	// hasOwn isn't used here due to false negatives
 	// regarding Nodelist length in IE
 	var length = !!obj && "length" in obj && obj.length,
 		type = jQuery.type( obj );
 
 	if ( type === "function" || jQuery.isWindow( obj ) ) {
 		return false;
 	}
 
 	return type === "array" || length === 0 ||
 		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
 }
 var Sizzle =
 /*!
  * Sizzle CSS Selector Engine v2.2.1
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2015-10-17
  */
 (function( window ) {
 
 var i,
 	support,
 	Expr,
 	getText,
 	isXML,
 	tokenize,
 	compile,
 	select,
 	outermostContext,
 	sortInput,
 	hasDuplicate,
 
 	// Local document vars
 	setDocument,
 	document,
 	docElem,
 	documentIsHTML,
 	rbuggyQSA,
 	rbuggyMatches,
 	matches,
 	contains,
 
 	// Instance-specific data
 	expando = "sizzle" + 1 * new Date(),
 	preferredDoc = window.document,
 	dirruns = 0,
 	done = 0,
 	classCache = createCache(),
 	tokenCache = createCache(),
 	compilerCache = createCache(),
 	sortOrder = function( a, b ) {
 		if ( a === b ) {
 			hasDuplicate = true;
 		}
 		return 0;
 	},
 
 	// General-purpose constants
 	MAX_NEGATIVE = 1 << 31,
 
 	// Instance methods
 	hasOwn = ({}).hasOwnProperty,
 	arr = [],
 	pop = arr.pop,
 	push_native = arr.push,
 	push = arr.push,
 	slice = arr.slice,
 	// Use a stripped-down indexOf as it's faster than native
 	// http://jsperf.com/thor-indexof-vs-for/5
 	indexOf = function( list, elem ) {
 		var i = 0,
 			len = list.length;
 		for ( ; i < len; i++ ) {
 			if ( list[i] === elem ) {
 				return i;
 			}
 		}
 		return -1;
 	},
 
 	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
 
 	// Regular expressions
 
 	// http://www.w3.org/TR/css3-selectors/#whitespace
 	whitespace = "[\\x20\\t\\r\\n\\f]",
 
 	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
 	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
 
 	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
 	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
 		// Operator (capture 2)
 		"*([*^$|!~]?=)" + whitespace +
 		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
 		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
 		"*\\]",
 
 	pseudos = ":(" + identifier + ")(?:\\((" +
 		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
 		// 1. quoted (capture 3; capture 4 or capture 5)
 		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
 		// 2. simple (capture 6)
 		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
 		// 3. anything else (capture 2)
 		".*" +
 		")\\)|)",
 
 	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
 	rwhitespace = new RegExp( whitespace + "+", "g" ),
 	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
 
 	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
 	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
 
 	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
 
 	rpseudo = new RegExp( pseudos ),
 	ridentifier = new RegExp( "^" + identifier + "$" ),
 
 	matchExpr = {
 		"ID": new RegExp( "^#(" + identifier + ")" ),
 		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
 		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
 		"ATTR": new RegExp( "^" + attributes ),
 		"PSEUDO": new RegExp( "^" + pseudos ),
 		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
 			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
 			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
 		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
 		// For use in libraries implementing .is()
 		// We use this for POS matching in `select`
 		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
 			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
 	},
 
 	rinputs = /^(?:input|select|textarea|button)$/i,
 	rheader = /^h\d$/i,
 
 	rnative = /^[^{]+\{\s*\[native \w/,
 
 	// Easily-parseable/retrievable ID or TAG or CLASS selectors
 	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
 
 	rsibling = /[+~]/,
 	rescape = /'|\\/g,
 
 	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
 	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
 	funescape = function( _, escaped, escapedWhitespace ) {
 		var high = "0x" + escaped - 0x10000;
 		// NaN means non-codepoint
 		// Support: Firefox<24
 		// Workaround erroneous numeric interpretation of +"0x"
 		return high !== high || escapedWhitespace ?
 			escaped :
 			high < 0 ?
 				// BMP codepoint
 				String.fromCharCode( high + 0x10000 ) :
 				// Supplemental Plane codepoint (surrogate pair)
 				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
 	},
 
 	// Used for iframes
 	// See setDocument()
 	// Removing the function wrapper causes a "Permission Denied"
 	// error in IE
 	unloadHandler = function() {
 		setDocument();
 	};
 
 // Optimize for push.apply( _, NodeList )
 try {
 	push.apply(
 		(arr = slice.call( preferredDoc.childNodes )),
 		preferredDoc.childNodes
 	);
 	// Support: Android<4.0
 	// Detect silently failing push.apply
 	arr[ preferredDoc.childNodes.length ].nodeType;
 } catch ( e ) {
 	push = { apply: arr.length ?
 
 		// Leverage slice if possible
 		function( target, els ) {
 			push_native.apply( target, slice.call(els) );
 		} :
 
 		// Support: IE<9
 		// Otherwise append directly
 		function( target, els ) {
 			var j = target.length,
 				i = 0;
 			// Can't trust NodeList.length
 			while ( (target[j++] = els[i++]) ) {}
 			target.length = j - 1;
 		}
 	};
 }
 
 function Sizzle( selector, context, results, seed ) {
 	var m, i, elem, nid, nidselect, match, groups, newSelector,
 		newContext = context && context.ownerDocument,
 
 		// nodeType defaults to 9, since context defaults to document
 		nodeType = context ? context.nodeType : 9;
 
 	results = results || [];
 
 	// Return early from calls with invalid selector or context
 	if ( typeof selector !== "string" || !selector ||
 		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
 
 		return results;
 	}
 
 	// Try to shortcut find operations (as opposed to filters) in HTML documents
 	if ( !seed ) {
 
 		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
 			setDocument( context );
 		}
 		context = context || document;
 
 		if ( documentIsHTML ) {
 
 			// If the selector is sufficiently simple, try using a "get*By*" DOM method
 			// (excepting DocumentFragment context, where the methods don't exist)
 			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
 
 				// ID selector
 				if ( (m = match[1]) ) {
 
 					// Document context
 					if ( nodeType === 9 ) {
 						if ( (elem = context.getElementById( m )) ) {
 
 							// Support: IE, Opera, Webkit
 							// TODO: identify versions
 							// getElementById can match elements by name instead of ID
 							if ( elem.id === m ) {
 								results.push( elem );
 								return results;
 							}
 						} else {
 							return results;
 						}
 
 					// Element context
 					} else {
 
 						// Support: IE, Opera, Webkit
 						// TODO: identify versions
 						// getElementById can match elements by name instead of ID
 						if ( newContext && (elem = newContext.getElementById( m )) &&
 							contains( context, elem ) &&
 							elem.id === m ) {
 
 							results.push( elem );
 							return results;
 						}
 					}
 
 				// Type selector
 				} else if ( match[2] ) {
 					push.apply( results, context.getElementsByTagName( selector ) );
 					return results;
 
 				// Class selector
 				} else if ( (m = match[3]) && support.getElementsByClassName &&
 					context.getElementsByClassName ) {
 
 					push.apply( results, context.getElementsByClassName( m ) );
 					return results;
 				}
 			}
 
 			// Take advantage of querySelectorAll
 			if ( support.qsa &&
 				!compilerCache[ selector + " " ] &&
 				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
 
 				if ( nodeType !== 1 ) {
 					newContext = context;
 					newSelector = selector;
 
 				// qSA looks outside Element context, which is not what we want
 				// Thanks to Andrew Dupont for this workaround technique
 				// Support: IE <=8
 				// Exclude object elements
 				} else if ( context.nodeName.toLowerCase() !== "object" ) {
 
 					// Capture the context ID, setting it first if necessary
 					if ( (nid = context.getAttribute( "id" )) ) {
 						nid = nid.replace( rescape, "\\$&" );
 					} else {
 						context.setAttribute( "id", (nid = expando) );
 					}
 
 					// Prefix every selector in the list
 					groups = tokenize( selector );
 					i = groups.length;
 					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
 					while ( i-- ) {
 						groups[i] = nidselect + " " + toSelector( groups[i] );
 					}
 					newSelector = groups.join( "," );
 
 					// Expand context for sibling selectors
 					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
 						context;
 				}
 
 				if ( newSelector ) {
 					try {
 						push.apply( results,
 							newContext.querySelectorAll( newSelector )
 						);
 						return results;
 					} catch ( qsaError ) {
 					} finally {
 						if ( nid === expando ) {
 							context.removeAttribute( "id" );
 						}
 					}
 				}
 			}
 		}
 	}
 
 	// All others
 	return select( selector.replace( rtrim, "$1" ), context, results, seed );
 }
 
 /**
  * Create key-value caches of limited size
  * @returns {function(string, object)} Returns the Object data after storing it on itself with
  *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
  *	deleting the oldest entry
  */
 function createCache() {
 	var keys = [];
 
 	function cache( key, value ) {
 		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
 		if ( keys.push( key + " " ) > Expr.cacheLength ) {
 			// Only keep the most recent entries
 			delete cache[ keys.shift() ];
 		}
 		return (cache[ key + " " ] = value);
 	}
 	return cache;
 }
 
 /**
  * Mark a function for special use by Sizzle
  * @param {Function} fn The function to mark
  */
 function markFunction( fn ) {
 	fn[ expando ] = true;
 	return fn;
 }
 
 /**
  * Support testing using an element
  * @param {Function} fn Passed the created div and expects a boolean result
  */
 function assert( fn ) {
 	var div = document.createElement("div");
 
 	try {
 		return !!fn( div );
 	} catch (e) {
 		return false;
 	} finally {
 		// Remove from its parent by default
 		if ( div.parentNode ) {
 			div.parentNode.removeChild( div );
 		}
 		// release memory in IE
 		div = null;
 	}
 }
 
 /**
  * Adds the same handler for all of the specified attrs
  * @param {String} attrs Pipe-separated list of attributes
  * @param {Function} handler The method that will be applied
  */
 function addHandle( attrs, handler ) {
 	var arr = attrs.split("|"),
 		i = arr.length;
 
 	while ( i-- ) {
 		Expr.attrHandle[ arr[i] ] = handler;
 	}
 }
 
 /**
  * Checks document order of two siblings
  * @param {Element} a
  * @param {Element} b
  * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
  */
 function siblingCheck( a, b ) {
 	var cur = b && a,
 		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
 			( ~b.sourceIndex || MAX_NEGATIVE ) -
 			( ~a.sourceIndex || MAX_NEGATIVE );
 
 	// Use IE sourceIndex if available on both nodes
 	if ( diff ) {
 		return diff;
 	}
 
 	// Check if b follows a
 	if ( cur ) {
 		while ( (cur = cur.nextSibling) ) {
 			if ( cur === b ) {
 				return -1;
 			}
 		}
 	}
 
 	return a ? 1 : -1;
 }
 
 /**
  * Returns a function to use in pseudos for input types
  * @param {String} type
  */
 function createInputPseudo( type ) {
 	return function( elem ) {
 		var name = elem.nodeName.toLowerCase();
 		return name === "input" && elem.type === type;
 	};
 }
 
 /**
  * Returns a function to use in pseudos for buttons
  * @param {String} type
  */
 function createButtonPseudo( type ) {
 	return function( elem ) {
 		var name = elem.nodeName.toLowerCase();
 		return (name === "input" || name === "button") && elem.type === type;
 	};
 }
 
 /**
  * Returns a function to use in pseudos for positionals
  * @param {Function} fn
  */
 function createPositionalPseudo( fn ) {
 	return markFunction(function( argument ) {
 		argument = +argument;
 		return markFunction(function( seed, matches ) {
 			var j,
 				matchIndexes = fn( [], seed.length, argument ),
 				i = matchIndexes.length;
 
 			// Match elements found at the specified indexes
 			while ( i-- ) {
 				if ( seed[ (j = matchIndexes[i]) ] ) {
 					seed[j] = !(matches[j] = seed[j]);
 				}
 			}
 		});
 	});
 }
 
 /**
  * Checks a node for validity as a Sizzle context
  * @param {Element|Object=} context
  * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
  */
 function testContext( context ) {
 	return context && typeof context.getElementsByTagName !== "undefined" && context;
 }
 
 // Expose support vars for convenience
 support = Sizzle.support = {};
 
 /**
  * Detects XML nodes
  * @param {Element|Object} elem An element or a document
  * @returns {Boolean} True iff elem is a non-HTML XML node
  */
 isXML = Sizzle.isXML = function( elem ) {
 	// documentElement is verified for cases where it doesn't yet exist
 	// (such as loading iframes in IE - #4833)
 	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
 	return documentElement ? documentElement.nodeName !== "HTML" : false;
 };
 
 /**
  * Sets document-related variables once based on the current document
  * @param {Element|Object} [doc] An element or document object to use to set the document
  * @returns {Object} Returns the current document
  */
 setDocument = Sizzle.setDocument = function( node ) {
 	var hasCompare, parent,
 		doc = node ? node.ownerDocument || node : preferredDoc;
 
 	// Return early if doc is invalid or already selected
 	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
 		return document;
 	}
 
 	// Update global variables
 	document = doc;
 	docElem = document.documentElement;
 	documentIsHTML = !isXML( document );
 
 	// Support: IE 9-11, Edge
 	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
 	if ( (parent = document.defaultView) && parent.top !== parent ) {
 		// Support: IE 11
 		if ( parent.addEventListener ) {
 			parent.addEventListener( "unload", unloadHandler, false );
 
 		// Support: IE 9 - 10 only
 		} else if ( parent.attachEvent ) {
 			parent.attachEvent( "onunload", unloadHandler );
 		}
 	}
 
 	/* Attributes
 	---------------------------------------------------------------------- */
 
 	// Support: IE<8
 	// Verify that getAttribute really returns attributes and not properties
 	// (excepting IE8 booleans)
 	support.attributes = assert(function( div ) {
 		div.className = "i";
 		return !div.getAttribute("className");
 	});
 
 	/* getElement(s)By*
 	---------------------------------------------------------------------- */
 
 	// Check if getElementsByTagName("*") returns only elements
 	support.getElementsByTagName = assert(function( div ) {
 		div.appendChild( document.createComment("") );
 		return !div.getElementsByTagName("*").length;
 	});
 
 	// Support: IE<9
 	support.getElementsByClassName = rnative.test( document.getElementsByClassName );
 
 	// Support: IE<10
 	// Check if getElementById returns elements by name
 	// The broken getElementById methods don't pick up programatically-set names,
 	// so use a roundabout getElementsByName test
 	support.getById = assert(function( div ) {
 		docElem.appendChild( div ).id = expando;
 		return !document.getElementsByName || !document.getElementsByName( expando ).length;
 	});
 
 	// ID find and filter
 	if ( support.getById ) {
 		Expr.find["ID"] = function( id, context ) {
 			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
 				var m = context.getElementById( id );
 				return m ? [ m ] : [];
 			}
 		};
 		Expr.filter["ID"] = function( id ) {
 			var attrId = id.replace( runescape, funescape );
 			return function( elem ) {
 				return elem.getAttribute("id") === attrId;
 			};
 		};
 	} else {
 		// Support: IE6/7
 		// getElementById is not reliable as a find shortcut
 		delete Expr.find["ID"];
 
 		Expr.filter["ID"] =  function( id ) {
 			var attrId = id.replace( runescape, funescape );
 			return function( elem ) {
 				var node = typeof elem.getAttributeNode !== "undefined" &&
 					elem.getAttributeNode("id");
 				return node && node.value === attrId;
 			};
 		};
 	}
 
 	// Tag
 	Expr.find["TAG"] = support.getElementsByTagName ?
 		function( tag, context ) {
 			if ( typeof context.getElementsByTagName !== "undefined" ) {
 				return context.getElementsByTagName( tag );
 
 			// DocumentFragment nodes don't have gEBTN
 			} else if ( support.qsa ) {
 				return context.querySelectorAll( tag );
 			}
 		} :
 
 		function( tag, context ) {
 			var elem,
 				tmp = [],
 				i = 0,
 				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
 				results = context.getElementsByTagName( tag );
 
 			// Filter out possible comments
 			if ( tag === "*" ) {
 				while ( (elem = results[i++]) ) {
 					if ( elem.nodeType === 1 ) {
 						tmp.push( elem );
 					}
 				}
 
 				return tmp;
 			}
 			return results;
 		};
 
 	// Class
 	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
 		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
 			return context.getElementsByClassName( className );
 		}
 	};
 
 	/* QSA/matchesSelector
 	---------------------------------------------------------------------- */
 
 	// QSA and matchesSelector support
 
 	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
 	rbuggyMatches = [];
 
 	// qSa(:focus) reports false when true (Chrome 21)
 	// We allow this because of a bug in IE8/9 that throws an error
 	// whenever `document.activeElement` is accessed on an iframe
 	// So, we allow :focus to pass through QSA all the time to avoid the IE error
 	// See http://bugs.jquery.com/ticket/13378
 	rbuggyQSA = [];
 
 	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
 		// Build QSA regex
 		// Regex strategy adopted from Diego Perini
 		assert(function( div ) {
 			// Select is set to empty string on purpose
 			// This is to test IE's treatment of not explicitly
 			// setting a boolean content attribute,
 			// since its presence should be enough
 			// http://bugs.jquery.com/ticket/12359
 			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
 				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
 				"<option selected=''></option></select>";
 
 			// Support: IE8, Opera 11-12.16
 			// Nothing should be selected when empty strings follow ^= or $= or *=
 			// The test attribute must be unknown in Opera but "safe" for WinRT
 			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
 			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
 				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
 			}
 
 			// Support: IE8
 			// Boolean attributes and "value" are not treated correctly
 			if ( !div.querySelectorAll("[selected]").length ) {
 				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
 			}
 
 			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
 			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
 				rbuggyQSA.push("~=");
 			}
 
 			// Webkit/Opera - :checked should return selected option elements
 			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
 			// IE8 throws error here and will not see later tests
 			if ( !div.querySelectorAll(":checked").length ) {
 				rbuggyQSA.push(":checked");
 			}
 
 			// Support: Safari 8+, iOS 8+
 			// https://bugs.webkit.org/show_bug.cgi?id=136851
 			// In-page `selector#id sibing-combinator selector` fails
 			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
 				rbuggyQSA.push(".#.+[+~]");
 			}
 		});
 
 		assert(function( div ) {
 			// Support: Windows 8 Native Apps
 			// The type and name attributes are restricted during .innerHTML assignment
 			var input = document.createElement("input");
 			input.setAttribute( "type", "hidden" );
 			div.appendChild( input ).setAttribute( "name", "D" );
 
 			// Support: IE8
 			// Enforce case-sensitivity of name attribute
 			if ( div.querySelectorAll("[name=d]").length ) {
 				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
 			}
 
 			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
 			// IE8 throws error here and will not see later tests
 			if ( !div.querySelectorAll(":enabled").length ) {
 				rbuggyQSA.push( ":enabled", ":disabled" );
 			}
 
 			// Opera 10-11 does not throw on post-comma invalid pseudos
 			div.querySelectorAll("*,:x");
 			rbuggyQSA.push(",.*:");
 		});
 	}
 
 	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
 		docElem.webkitMatchesSelector ||
 		docElem.mozMatchesSelector ||
 		docElem.oMatchesSelector ||
 		docElem.msMatchesSelector) )) ) {
 
 		assert(function( div ) {
 			// Check to see if it's possible to do matchesSelector
 			// on a disconnected node (IE 9)
 			support.disconnectedMatch = matches.call( div, "div" );
 
 			// This should fail with an exception
 			// Gecko does not error, returns false instead
 			matches.call( div, "[s!='']:x" );
 			rbuggyMatches.push( "!=", pseudos );
 		});
 	}
 
 	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
 	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
 
 	/* Contains
 	---------------------------------------------------------------------- */
 	hasCompare = rnative.test( docElem.compareDocumentPosition );
 
 	// Element contains another
 	// Purposefully self-exclusive
 	// As in, an element does not contain itself
 	contains = hasCompare || rnative.test( docElem.contains ) ?
 		function( a, b ) {
 			var adown = a.nodeType === 9 ? a.documentElement : a,
 				bup = b && b.parentNode;
 			return a === bup || !!( bup && bup.nodeType === 1 && (
 				adown.contains ?
 					adown.contains( bup ) :
 					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
 			));
 		} :
 		function( a, b ) {
 			if ( b ) {
 				while ( (b = b.parentNode) ) {
 					if ( b === a ) {
 						return true;
 					}
 				}
 			}
 			return false;
 		};
 
 	/* Sorting
 	---------------------------------------------------------------------- */
 
 	// Document order sorting
 	sortOrder = hasCompare ?
 	function( a, b ) {
 
 		// Flag for duplicate removal
 		if ( a === b ) {
 			hasDuplicate = true;
 			return 0;
 		}
 
 		// Sort on method existence if only one input has compareDocumentPosition
 		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
 		if ( compare ) {
 			return compare;
 		}
 
 		// Calculate position if both inputs belong to the same document
 		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
 			a.compareDocumentPosition( b ) :
 
 			// Otherwise we know they are disconnected
 			1;
 
 		// Disconnected nodes
 		if ( compare & 1 ||
 			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
 
 			// Choose the first element that is related to our preferred document
 			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
 				return -1;
 			}
 			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
 				return 1;
 			}
 
 			// Maintain original order
 			return sortInput ?
 				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
 				0;
 		}
 
 		return compare & 4 ? -1 : 1;
 	} :
 	function( a, b ) {
 		// Exit early if the nodes are identical
 		if ( a === b ) {
 			hasDuplicate = true;
 			return 0;
 		}
 
 		var cur,
 			i = 0,
 			aup = a.parentNode,
 			bup = b.parentNode,
 			ap = [ a ],
 			bp = [ b ];
 
 		// Parentless nodes are either documents or disconnected
 		if ( !aup || !bup ) {
 			return a === document ? -1 :
 				b === document ? 1 :
 				aup ? -1 :
 				bup ? 1 :
 				sortInput ?
 				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
 				0;
 
 		// If the nodes are siblings, we can do a quick check
 		} else if ( aup === bup ) {
 			return siblingCheck( a, b );
 		}
 
 		// Otherwise we need full lists of their ancestors for comparison
 		cur = a;
 		while ( (cur = cur.parentNode) ) {
 			ap.unshift( cur );
 		}
 		cur = b;
 		while ( (cur = cur.parentNode) ) {
 			bp.unshift( cur );
 		}
 
 		// Walk down the tree looking for a discrepancy
 		while ( ap[i] === bp[i] ) {
 			i++;
 		}
 
 		return i ?
 			// Do a sibling check if the nodes have a common ancestor
 			siblingCheck( ap[i], bp[i] ) :
 
 			// Otherwise nodes in our document sort first
 			ap[i] === preferredDoc ? -1 :
 			bp[i] === preferredDoc ? 1 :
 			0;
 	};
 
 	return document;
 };
 
 Sizzle.matches = function( expr, elements ) {
 	return Sizzle( expr, null, null, elements );
 };
 
 Sizzle.matchesSelector = function( elem, expr ) {
 	// Set document vars if needed
 	if ( ( elem.ownerDocument || elem ) !== document ) {
 		setDocument( elem );
 	}
 
 	// Make sure that attribute selectors are quoted
 	expr = expr.replace( rattributeQuotes, "='$1']" );
 
 	if ( support.matchesSelector && documentIsHTML &&
 		!compilerCache[ expr + " " ] &&
 		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
 		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
 
 		try {
 			var ret = matches.call( elem, expr );
 
 			// IE 9's matchesSelector returns false on disconnected nodes
 			if ( ret || support.disconnectedMatch ||
 					// As well, disconnected nodes are said to be in a document
 					// fragment in IE 9
 					elem.document && elem.document.nodeType !== 11 ) {
 				return ret;
 			}
 		} catch (e) {}
 	}
 
 	return Sizzle( expr, document, null, [ elem ] ).length > 0;
 };
 
 Sizzle.contains = function( context, elem ) {
 	// Set document vars if needed
 	if ( ( context.ownerDocument || context ) !== document ) {
 		setDocument( context );
 	}
 	return contains( context, elem );
 };
 
 Sizzle.attr = function( elem, name ) {
 	// Set document vars if needed
 	if ( ( elem.ownerDocument || elem ) !== document ) {
 		setDocument( elem );
 	}
 
 	var fn = Expr.attrHandle[ name.toLowerCase() ],
 		// Don't get fooled by Object.prototype properties (jQuery #13807)
 		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
 			fn( elem, name, !documentIsHTML ) :
 			undefined;
 
 	return val !== undefined ?
 		val :
 		support.attributes || !documentIsHTML ?
 			elem.getAttribute( name ) :
 			(val = elem.getAttributeNode(name)) && val.specified ?
 				val.value :
 				null;
 };
 
 Sizzle.error = function( msg ) {
 	throw new Error( "Syntax error, unrecognized expression: " + msg );
 };
 
 /**
  * Document sorting and removing duplicates
  * @param {ArrayLike} results
  */
 Sizzle.uniqueSort = function( results ) {
 	var elem,
 		duplicates = [],
 		j = 0,
 		i = 0;
 
 	// Unless we *know* we can detect duplicates, assume their presence
 	hasDuplicate = !support.detectDuplicates;
 	sortInput = !support.sortStable && results.slice( 0 );
 	results.sort( sortOrder );
 
 	if ( hasDuplicate ) {
 		while ( (elem = results[i++]) ) {
 			if ( elem === results[ i ] ) {
 				j = duplicates.push( i );
 			}
 		}
 		while ( j-- ) {
 			results.splice( duplicates[ j ], 1 );
 		}
 	}
 
 	// Clear input after sorting to release objects
 	// See https://github.com/jquery/sizzle/pull/225
 	sortInput = null;
 
 	return results;
 };
 
 /**
  * Utility function for retrieving the text value of an array of DOM nodes
  * @param {Array|Element} elem
  */
 getText = Sizzle.getText = function( elem ) {
 	var node,
 		ret = "",
 		i = 0,
 		nodeType = elem.nodeType;
 
 	if ( !nodeType ) {
 		// If no nodeType, this is expected to be an array
 		while ( (node = elem[i++]) ) {
 			// Do not traverse comment nodes
 			ret += getText( node );
 		}
 	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
 		// Use textContent for elements
 		// innerText usage removed for consistency of new lines (jQuery #11153)
 		if ( typeof elem.textContent === "string" ) {
 			return elem.textContent;
 		} else {
 			// Traverse its children
 			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
 				ret += getText( elem );
 			}
 		}
 	} else if ( nodeType === 3 || nodeType === 4 ) {
 		return elem.nodeValue;
 	}
 	// Do not include comment or processing instruction nodes
 
 	return ret;
 };
 
 Expr = Sizzle.selectors = {
 
 	// Can be adjusted by the user
 	cacheLength: 50,
 
 	createPseudo: markFunction,
 
 	match: matchExpr,
 
 	attrHandle: {},
 
 	find: {},
 
 	relative: {
 		">": { dir: "parentNode", first: true },
 		" ": { dir: "parentNode" },
 		"+": { dir: "previousSibling", first: true },
 		"~": { dir: "previousSibling" }
 	},
 
 	preFilter: {
 		"ATTR": function( match ) {
 			match[1] = match[1].replace( runescape, funescape );
 
 			// Move the given value to match[3] whether quoted or unquoted
 			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
 
 			if ( match[2] === "~=" ) {
 				match[3] = " " + match[3] + " ";
 			}
 
 			return match.slice( 0, 4 );
 		},
 
 		"CHILD": function( match ) {
 			/* matches from matchExpr["CHILD"]
 				1 type (only|nth|...)
 				2 what (child|of-type)
 				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
 				4 xn-component of xn+y argument ([+-]?\d*n|)
 				5 sign of xn-component
 				6 x of xn-component
 				7 sign of y-component
 				8 y of y-component
 			*/
 			match[1] = match[1].toLowerCase();
 
 			if ( match[1].slice( 0, 3 ) === "nth" ) {
 				// nth-* requires argument
 				if ( !match[3] ) {
 					Sizzle.error( match[0] );
 				}
 
 				// numeric x and y parameters for Expr.filter.CHILD
 				// remember that false/true cast respectively to 0/1
 				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
 				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
 
 			// other types prohibit arguments
 			} else if ( match[3] ) {
 				Sizzle.error( match[0] );
 			}
 
 			return match;
 		},
 
 		"PSEUDO": function( match ) {
 			var excess,
 				unquoted = !match[6] && match[2];
 
 			if ( matchExpr["CHILD"].test( match[0] ) ) {
 				return null;
 			}
 
 			// Accept quoted arguments as-is
 			if ( match[3] ) {
 				match[2] = match[4] || match[5] || "";
 
 			// Strip excess characters from unquoted arguments
 			} else if ( unquoted && rpseudo.test( unquoted ) &&
 				// Get excess from tokenize (recursively)
 				(excess = tokenize( unquoted, true )) &&
 				// advance to the next closing parenthesis
 				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
 
 				// excess is a negative index
 				match[0] = match[0].slice( 0, excess );
 				match[2] = unquoted.slice( 0, excess );
 			}
 
 			// Return only captures needed by the pseudo filter method (type and argument)
 			return match.slice( 0, 3 );
 		}
 	},
 
 	filter: {
 
 		"TAG": function( nodeNameSelector ) {
 			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
 			return nodeNameSelector === "*" ?
 				function() { return true; } :
 				function( elem ) {
 					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
 				};
 		},
 
 		"CLASS": function( className ) {
 			var pattern = classCache[ className + " " ];
 
 			return pattern ||
 				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
 				classCache( className, function( elem ) {
 					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
 				});
 		},
 
 		"ATTR": function( name, operator, check ) {
 			return function( elem ) {
 				var result = Sizzle.attr( elem, name );
 
 				if ( result == null ) {
 					return operator === "!=";
 				}
 				if ( !operator ) {
 					return true;
 				}
 
 				result += "";
 
 				return operator === "=" ? result === check :
 					operator === "!=" ? result !== check :
 					operator === "^=" ? check && result.indexOf( check ) === 0 :
 					operator === "*=" ? check && result.indexOf( check ) > -1 :
 					operator === "$=" ? check && result.slice( -check.length ) === check :
 					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
 					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
 					false;
 			};
 		},
 
 		"CHILD": function( type, what, argument, first, last ) {
 			var simple = type.slice( 0, 3 ) !== "nth",
 				forward = type.slice( -4 ) !== "last",
 				ofType = what === "of-type";
 
 			return first === 1 && last === 0 ?
 
 				// Shortcut for :nth-*(n)
 				function( elem ) {
 					return !!elem.parentNode;
 				} :
 
 				function( elem, context, xml ) {
 					var cache, uniqueCache, outerCache, node, nodeIndex, start,
 						dir = simple !== forward ? "nextSibling" : "previousSibling",
 						parent = elem.parentNode,
 						name = ofType && elem.nodeName.toLowerCase(),
 						useCache = !xml && !ofType,
 						diff = false;
 
 					if ( parent ) {
 
 						// :(first|last|only)-(child|of-type)
 						if ( simple ) {
 							while ( dir ) {
 								node = elem;
 								while ( (node = node[ dir ]) ) {
 									if ( ofType ?
 										node.nodeName.toLowerCase() === name :
 										node.nodeType === 1 ) {
 
 										return false;
 									}
 								}
 								// Reverse direction for :only-* (if we haven't yet done so)
 								start = dir = type === "only" && !start && "nextSibling";
 							}
 							return true;
 						}
 
 						start = [ forward ? parent.firstChild : parent.lastChild ];
 
 						// non-xml :nth-child(...) stores cache data on `parent`
 						if ( forward && useCache ) {
 
 							// Seek `elem` from a previously-cached index
 
 							// ...in a gzip-friendly way
 							node = parent;
 							outerCache = node[ expando ] || (node[ expando ] = {});
 
 							// Support: IE <9 only
 							// Defend against cloned attroperties (jQuery gh-1709)
 							uniqueCache = outerCache[ node.uniqueID ] ||
 								(outerCache[ node.uniqueID ] = {});
 
 							cache = uniqueCache[ type ] || [];
 							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
 							diff = nodeIndex && cache[ 2 ];
 							node = nodeIndex && parent.childNodes[ nodeIndex ];
 
 							while ( (node = ++nodeIndex && node && node[ dir ] ||
 
 								// Fallback to seeking `elem` from the start
 								(diff = nodeIndex = 0) || start.pop()) ) {
 
 								// When found, cache indexes on `parent` and break
 								if ( node.nodeType === 1 && ++diff && node === elem ) {
 									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
 									break;
 								}
 							}
 
 						} else {
 							// Use previously-cached element index if available
 							if ( useCache ) {
 								// ...in a gzip-friendly way
 								node = elem;
 								outerCache = node[ expando ] || (node[ expando ] = {});
 
 								// Support: IE <9 only
 								// Defend against cloned attroperties (jQuery gh-1709)
 								uniqueCache = outerCache[ node.uniqueID ] ||
 									(outerCache[ node.uniqueID ] = {});
 
 								cache = uniqueCache[ type ] || [];
 								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
 								diff = nodeIndex;
 							}
 
 							// xml :nth-child(...)
 							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
 							if ( diff === false ) {
 								// Use the same loop as above to seek `elem` from the start
 								while ( (node = ++nodeIndex && node && node[ dir ] ||
 									(diff = nodeIndex = 0) || start.pop()) ) {
 
 									if ( ( ofType ?
 										node.nodeName.toLowerCase() === name :
 										node.nodeType === 1 ) &&
 										++diff ) {
 
 										// Cache the index of each encountered element
 										if ( useCache ) {
 											outerCache = node[ expando ] || (node[ expando ] = {});
 
 											// Support: IE <9 only
 											// Defend against cloned attroperties (jQuery gh-1709)
 											uniqueCache = outerCache[ node.uniqueID ] ||
 												(outerCache[ node.uniqueID ] = {});
 
 											uniqueCache[ type ] = [ dirruns, diff ];
 										}
 
 										if ( node === elem ) {
 											break;
 										}
 									}
 								}
 							}
 						}
 
 						// Incorporate the offset, then check against cycle size
 						diff -= last;
 						return diff === first || ( diff % first === 0 && diff / first >= 0 );
 					}
 				};
 		},
 
 		"PSEUDO": function( pseudo, argument ) {
 			// pseudo-class names are case-insensitive
 			// http://www.w3.org/TR/selectors/#pseudo-classes
 			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
 			// Remember that setFilters inherits from pseudos
 			var args,
 				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
 					Sizzle.error( "unsupported pseudo: " + pseudo );
 
 			// The user may use createPseudo to indicate that
 			// arguments are needed to create the filter function
 			// just as Sizzle does
 			if ( fn[ expando ] ) {
 				return fn( argument );
 			}
 
 			// But maintain support for old signatures
 			if ( fn.length > 1 ) {
 				args = [ pseudo, pseudo, "", argument ];
 				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
 					markFunction(function( seed, matches ) {
 						var idx,
 							matched = fn( seed, argument ),
 							i = matched.length;
 						while ( i-- ) {
 							idx = indexOf( seed, matched[i] );
 							seed[ idx ] = !( matches[ idx ] = matched[i] );
 						}
 					}) :
 					function( elem ) {
 						return fn( elem, 0, args );
 					};
 			}
 
 			return fn;
 		}
 	},
 
 	pseudos: {
 		// Potentially complex pseudos
 		"not": markFunction(function( selector ) {
 			// Trim the selector passed to compile
 			// to avoid treating leading and trailing
 			// spaces as combinators
 			var input = [],
 				results = [],
 				matcher = compile( selector.replace( rtrim, "$1" ) );
 
 			return matcher[ expando ] ?
 				markFunction(function( seed, matches, context, xml ) {
 					var elem,
 						unmatched = matcher( seed, null, xml, [] ),
 						i = seed.length;
 
 					// Match elements unmatched by `matcher`
 					while ( i-- ) {
 						if ( (elem = unmatched[i]) ) {
 							seed[i] = !(matches[i] = elem);
 						}
 					}
 				}) :
 				function( elem, context, xml ) {
 					input[0] = elem;
 					matcher( input, null, xml, results );
 					// Don't keep the element (issue #299)
 					input[0] = null;
 					return !results.pop();
 				};
 		}),
 
 		"has": markFunction(function( selector ) {
 			return function( elem ) {
 				return Sizzle( selector, elem ).length > 0;
 			};
 		}),
 
 		"contains": markFunction(function( text ) {
 			text = text.replace( runescape, funescape );
 			return function( elem ) {
 				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
 			};
 		}),
 
 		// "Whether an element is represented by a :lang() selector
 		// is based solely on the element's language value
 		// being equal to the identifier C,
 		// or beginning with the identifier C immediately followed by "-".
 		// The matching of C against the element's language value is performed case-insensitively.
 		// The identifier C does not have to be a valid language name."
 		// http://www.w3.org/TR/selectors/#lang-pseudo
 		"lang": markFunction( function( lang ) {
 			// lang value must be a valid identifier
 			if ( !ridentifier.test(lang || "") ) {
 				Sizzle.error( "unsupported lang: " + lang );
 			}
 			lang = lang.replace( runescape, funescape ).toLowerCase();
 			return function( elem ) {
 				var elemLang;
 				do {
 					if ( (elemLang = documentIsHTML ?
 						elem.lang :
 						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
 
 						elemLang = elemLang.toLowerCase();
 						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
 					}
 				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
 				return false;
 			};
 		}),
 
 		// Miscellaneous
 		"target": function( elem ) {
 			var hash = window.location && window.location.hash;
 			return hash && hash.slice( 1 ) === elem.id;
 		},
 
 		"root": function( elem ) {
 			return elem === docElem;
 		},
 
 		"focus": function( elem ) {
 			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
 		},
 
 		// Boolean properties
 		"enabled": function( elem ) {
 			return elem.disabled === false;
 		},
 
 		"disabled": function( elem ) {
 			return elem.disabled === true;
 		},
 
 		"checked": function( elem ) {
 			// In CSS3, :checked should return both checked and selected elements
 			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
 			var nodeName = elem.nodeName.toLowerCase();
 			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
 		},
 
 		"selected": function( elem ) {
 			// Accessing this property makes selected-by-default
 			// options in Safari work properly
 			if ( elem.parentNode ) {
 				elem.parentNode.selectedIndex;
 			}
 
 			return elem.selected === true;
 		},
 
 		// Contents
 		"empty": function( elem ) {
 			// http://www.w3.org/TR/selectors/#empty-pseudo
 			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
 			//   but not by others (comment: 8; processing instruction: 7; etc.)
 			// nodeType < 6 works because attributes (2) do not appear as children
 			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
 				if ( elem.nodeType < 6 ) {
 					return false;
 				}
 			}
 			return true;
 		},
 
 		"parent": function( elem ) {
 			return !Expr.pseudos["empty"]( elem );
 		},
 
 		// Element/input types
 		"header": function( elem ) {
 			return rheader.test( elem.nodeName );
 		},
 
 		"input": function( elem ) {
 			return rinputs.test( elem.nodeName );
 		},
 
 		"button": function( elem ) {
 			var name = elem.nodeName.toLowerCase();
 			return name === "input" && elem.type === "button" || name === "button";
 		},
 
 		"text": function( elem ) {
 			var attr;
 			return elem.nodeName.toLowerCase() === "input" &&
 				elem.type === "text" &&
 
 				// Support: IE<8
 				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
 				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
 		},
 
 		// Position-in-collection
 		"first": createPositionalPseudo(function() {
 			return [ 0 ];
 		}),
 
 		"last": createPositionalPseudo(function( matchIndexes, length ) {
 			return [ length - 1 ];
 		}),
 
 		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
 			return [ argument < 0 ? argument + length : argument ];
 		}),
 
 		"even": createPositionalPseudo(function( matchIndexes, length ) {
 			var i = 0;
 			for ( ; i < length; i += 2 ) {
 				matchIndexes.push( i );
 			}
 			return matchIndexes;
 		}),
 
 		"odd": createPositionalPseudo(function( matchIndexes, length ) {
 			var i = 1;
 			for ( ; i < length; i += 2 ) {
 				matchIndexes.push( i );
 			}
 			return matchIndexes;
 		}),
 
 		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
 			var i = argument < 0 ? argument + length : argument;
 			for ( ; --i >= 0; ) {
 				matchIndexes.push( i );
 			}
 			return matchIndexes;
 		}),
 
 		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
 			var i = argument < 0 ? argument + length : argument;
 			for ( ; ++i < length; ) {
 				matchIndexes.push( i );
 			}
 			return matchIndexes;
 		})
 	}
 };
 
 Expr.pseudos["nth"] = Expr.pseudos["eq"];
 
 // Add button/input type pseudos
 for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
 	Expr.pseudos[ i ] = createInputPseudo( i );
 }
 for ( i in { submit: true, reset: true } ) {
 	Expr.pseudos[ i ] = createButtonPseudo( i );
 }
 
 // Easy API for creating new setFilters
 function setFilters() {}
 setFilters.prototype = Expr.filters = Expr.pseudos;
 Expr.setFilters = new setFilters();
 
 tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
 	var matched, match, tokens, type,
 		soFar, groups, preFilters,
 		cached = tokenCache[ selector + " " ];
 
 	if ( cached ) {
 		return parseOnly ? 0 : cached.slice( 0 );
 	}
 
 	soFar = selector;
 	groups = [];
 	preFilters = Expr.preFilter;
 
 	while ( soFar ) {
 
 		// Comma and first run
 		if ( !matched || (match = rcomma.exec( soFar )) ) {
 			if ( match ) {
 				// Don't consume trailing commas as valid
 				soFar = soFar.slice( match[0].length ) || soFar;
 			}
 			groups.push( (tokens = []) );
 		}
 
 		matched = false;
 
 		// Combinators
 		if ( (match = rcombinators.exec( soFar )) ) {
 			matched = match.shift();
 			tokens.push({
 				value: matched,
 				// Cast descendant combinators to space
 				type: match[0].replace( rtrim, " " )
 			});
 			soFar = soFar.slice( matched.length );
 		}
 
 		// Filters
 		for ( type in Expr.filter ) {
 			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
 				(match = preFilters[ type ]( match ))) ) {
 				matched = match.shift();
 				tokens.push({
 					value: matched,
 					type: type,
 					matches: match
 				});
 				soFar = soFar.slice( matched.length );
 			}
 		}
 
 		if ( !matched ) {
 			break;
 		}
 	}
 
 	// Return the length of the invalid excess
 	// if we're just parsing
 	// Otherwise, throw an error or return tokens
 	return parseOnly ?
 		soFar.length :
 		soFar ?
 			Sizzle.error( selector ) :
 			// Cache the tokens
 			tokenCache( selector, groups ).slice( 0 );
 };
 
 function toSelector( tokens ) {
 	var i = 0,
 		len = tokens.length,
 		selector = "";
 	for ( ; i < len; i++ ) {
 		selector += tokens[i].value;
 	}
 	return selector;
 }
 
 function addCombinator( matcher, combinator, base ) {
 	var dir = combinator.dir,
 		checkNonElements = base && dir === "parentNode",
 		doneName = done++;
 
 	return combinator.first ?
 		// Check against closest ancestor/preceding element
 		function( elem, context, xml ) {
 			while ( (elem = elem[ dir ]) ) {
 				if ( elem.nodeType === 1 || checkNonElements ) {
 					return matcher( elem, context, xml );
 				}
 			}
 		} :
 
 		// Check against all ancestor/preceding elements
 		function( elem, context, xml ) {
 			var oldCache, uniqueCache, outerCache,
 				newCache = [ dirruns, doneName ];
 
 			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
 			if ( xml ) {
 				while ( (elem = elem[ dir ]) ) {
 					if ( elem.nodeType === 1 || checkNonElements ) {
 						if ( matcher( elem, context, xml ) ) {
 							return true;
 						}
 					}
 				}
 			} else {
 				while ( (elem = elem[ dir ]) ) {
 					if ( elem.nodeType === 1 || checkNonElements ) {
 						outerCache = elem[ expando ] || (elem[ expando ] = {});
 
 						// Support: IE <9 only
 						// Defend against cloned attroperties (jQuery gh-1709)
 						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
 
 						if ( (oldCache = uniqueCache[ dir ]) &&
 							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
 
 							// Assign to newCache so results back-propagate to previous elements
 							return (newCache[ 2 ] = oldCache[ 2 ]);
 						} else {
 							// Reuse newcache so results back-propagate to previous elements
 							uniqueCache[ dir ] = newCache;
 
 							// A match means we're done; a fail means we have to keep checking
 							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
 								return true;
 							}
 						}
 					}
 				}
 			}
 		};
 }
 
 function elementMatcher( matchers ) {
 	return matchers.length > 1 ?
 		function( elem, context, xml ) {
 			var i = matchers.length;
 			while ( i-- ) {
 				if ( !matchers[i]( elem, context, xml ) ) {
 					return false;
 				}
 			}
 			return true;
 		} :
 		matchers[0];
 }
 
 function multipleContexts( selector, contexts, results ) {
 	var i = 0,
 		len = contexts.length;
 	for ( ; i < len; i++ ) {
 		Sizzle( selector, contexts[i], results );
 	}
 	return results;
 }
 
 function condense( unmatched, map, filter, context, xml ) {
 	var elem,
 		newUnmatched = [],
 		i = 0,
 		len = unmatched.length,
 		mapped = map != null;
 
 	for ( ; i < len; i++ ) {
 		if ( (elem = unmatched[i]) ) {
 			if ( !filter || filter( elem, context, xml ) ) {
 				newUnmatched.push( elem );
 				if ( mapped ) {
 					map.push( i );
 				}
 			}
 		}
 	}
 
 	return newUnmatched;
 }
 
 function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
 	if ( postFilter && !postFilter[ expando ] ) {
 		postFilter = setMatcher( postFilter );
 	}
 	if ( postFinder && !postFinder[ expando ] ) {
 		postFinder = setMatcher( postFinder, postSelector );
 	}
 	return markFunction(function( seed, results, context, xml ) {
 		var temp, i, elem,
 			preMap = [],
 			postMap = [],
 			preexisting = results.length,
 
 			// Get initial elements from seed or context
 			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
 
 			// Prefilter to get matcher input, preserving a map for seed-results synchronization
 			matcherIn = preFilter && ( seed || !selector ) ?
 				condense( elems, preMap, preFilter, context, xml ) :
 				elems,
 
 			matcherOut = matcher ?
 				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
 				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
 
 					// ...intermediate processing is necessary
 					[] :
 
 					// ...otherwise use results directly
 					results :
 				matcherIn;
 
 		// Find primary matches
 		if ( matcher ) {
 			matcher( matcherIn, matcherOut, context, xml );
 		}
 
 		// Apply postFilter
 		if ( postFilter ) {
 			temp = condense( matcherOut, postMap );
 			postFilter( temp, [], context, xml );
 
 			// Un-match failing elements by moving them back to matcherIn
 			i = temp.length;
 			while ( i-- ) {
 				if ( (elem = temp[i]) ) {
 					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
 				}
 			}
 		}
 
 		if ( seed ) {
 			if ( postFinder || preFilter ) {
 				if ( postFinder ) {
 					// Get the final matcherOut by condensing this intermediate into postFinder contexts
 					temp = [];
 					i = matcherOut.length;
 					while ( i-- ) {
 						if ( (elem = matcherOut[i]) ) {
 							// Restore matcherIn since elem is not yet a final match
 							temp.push( (matcherIn[i] = elem) );
 						}
 					}
 					postFinder( null, (matcherOut = []), temp, xml );
 				}
 
 				// Move matched elements from seed to results to keep them synchronized
 				i = matcherOut.length;
 				while ( i-- ) {
 					if ( (elem = matcherOut[i]) &&
 						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
 
 						seed[temp] = !(results[temp] = elem);
 					}
 				}
 			}
 
 		// Add elements to results, through postFinder if defined
 		} else {
 			matcherOut = condense(
 				matcherOut === results ?
 					matcherOut.splice( preexisting, matcherOut.length ) :
 					matcherOut
 			);
 			if ( postFinder ) {
 				postFinder( null, results, matcherOut, xml );
 			} else {
 				push.apply( results, matcherOut );
 			}
 		}
 	});
 }
 
 function matcherFromTokens( tokens ) {
 	var checkContext, matcher, j,
 		len = tokens.length,
 		leadingRelative = Expr.relative[ tokens[0].type ],
 		implicitRelative = leadingRelative || Expr.relative[" "],
 		i = leadingRelative ? 1 : 0,
 
 		// The foundational matcher ensures that elements are reachable from top-level context(s)
 		matchContext = addCombinator( function( elem ) {
 			return elem === checkContext;
 		}, implicitRelative, true ),
 		matchAnyContext = addCombinator( function( elem ) {
 			return indexOf( checkContext, elem ) > -1;
 		}, implicitRelative, true ),
 		matchers = [ function( elem, context, xml ) {
 			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
 				(checkContext = context).nodeType ?
 					matchContext( elem, context, xml ) :
 					matchAnyContext( elem, context, xml ) );
 			// Avoid hanging onto element (issue #299)
 			checkContext = null;
 			return ret;
 		} ];
 
 	for ( ; i < len; i++ ) {
 		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
 			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
 		} else {
 			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
 
 			// Return special upon seeing a positional matcher
 			if ( matcher[ expando ] ) {
 				// Find the next relative operator (if any) for proper handling
 				j = ++i;
 				for ( ; j < len; j++ ) {
 					if ( Expr.relative[ tokens[j].type ] ) {
 						break;
 					}
 				}
 				return setMatcher(
 					i > 1 && elementMatcher( matchers ),
 					i > 1 && toSelector(
 						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
 						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
 					).replace( rtrim, "$1" ),
 					matcher,
 					i < j && matcherFromTokens( tokens.slice( i, j ) ),
 					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
 					j < len && toSelector( tokens )
 				);
 			}
 			matchers.push( matcher );
 		}
 	}
 
 	return elementMatcher( matchers );
 }
 
 function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
 	var bySet = setMatchers.length > 0,
 		byElement = elementMatchers.length > 0,
 		superMatcher = function( seed, context, xml, results, outermost ) {
 			var elem, j, matcher,
 				matchedCount = 0,
 				i = "0",
 				unmatched = seed && [],
 				setMatched = [],
 				contextBackup = outermostContext,
 				// We must always have either seed elements or outermost context
 				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
 				// Use integer dirruns iff this is the outermost matcher
 				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
 				len = elems.length;
 
 			if ( outermost ) {
 				outermostContext = context === document || context || outermost;
 			}
 
 			// Add elements passing elementMatchers directly to results
 			// Support: IE<9, Safari
 			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
 			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
 				if ( byElement && elem ) {
 					j = 0;
 					if ( !context && elem.ownerDocument !== document ) {
 						setDocument( elem );
 						xml = !documentIsHTML;
 					}
 					while ( (matcher = elementMatchers[j++]) ) {
 						if ( matcher( elem, context || document, xml) ) {
 							results.push( elem );
 							break;
 						}
 					}
 					if ( outermost ) {
 						dirruns = dirrunsUnique;
 					}
 				}
 
 				// Track unmatched elements for set filters
 				if ( bySet ) {
 					// They will have gone through all possible matchers
 					if ( (elem = !matcher && elem) ) {
 						matchedCount--;
 					}
 
 					// Lengthen the array for every element, matched or not
 					if ( seed ) {
 						unmatched.push( elem );
 					}
 				}
 			}
 
 			// `i` is now the count of elements visited above, and adding it to `matchedCount`
 			// makes the latter nonnegative.
 			matchedCount += i;
 
 			// Apply set filters to unmatched elements
 			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
 			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
 			// no element matchers and no seed.
 			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
 			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
 			// numerically zero.
 			if ( bySet && i !== matchedCount ) {
 				j = 0;
 				while ( (matcher = setMatchers[j++]) ) {
 					matcher( unmatched, setMatched, context, xml );
 				}
 
 				if ( seed ) {
 					// Reintegrate element matches to eliminate the need for sorting
 					if ( matchedCount > 0 ) {
 						while ( i-- ) {
 							if ( !(unmatched[i] || setMatched[i]) ) {
 								setMatched[i] = pop.call( results );
 							}
 						}
 					}
 
 					// Discard index placeholder values to get only actual matches
 					setMatched = condense( setMatched );
 				}
 
 				// Add matches to results
 				push.apply( results, setMatched );
 
 				// Seedless set matches succeeding multiple successful matchers stipulate sorting
 				if ( outermost && !seed && setMatched.length > 0 &&
 					( matchedCount + setMatchers.length ) > 1 ) {
 
 					Sizzle.uniqueSort( results );
 				}
 			}
 
 			// Override manipulation of globals by nested matchers
 			if ( outermost ) {
 				dirruns = dirrunsUnique;
 				outermostContext = contextBackup;
 			}
 
 			return unmatched;
 		};
 
 	return bySet ?
 		markFunction( superMatcher ) :
 		superMatcher;
 }
 
 compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
 	var i,
 		setMatchers = [],
 		elementMatchers = [],
 		cached = compilerCache[ selector + " " ];
 
 	if ( !cached ) {
 		// Generate a function of recursive functions that can be used to check each element
 		if ( !match ) {
 			match = tokenize( selector );
 		}
 		i = match.length;
 		while ( i-- ) {
 			cached = matcherFromTokens( match[i] );
 			if ( cached[ expando ] ) {
 				setMatchers.push( cached );
 			} else {
 				elementMatchers.push( cached );
 			}
 		}
 
 		// Cache the compiled function
 		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
 
 		// Save selector and tokenization
 		cached.selector = selector;
 	}
 	return cached;
 };
 
 /**
  * A low-level selection function that works with Sizzle's compiled
  *  selector functions
  * @param {String|Function} selector A selector or a pre-compiled
  *  selector function built with Sizzle.compile
  * @param {Element} context
  * @param {Array} [results]
  * @param {Array} [seed] A set of elements to match against
  */
 select = Sizzle.select = function( selector, context, results, seed ) {
 	var i, tokens, token, type, find,
 		compiled = typeof selector === "function" && selector,
 		match = !seed && tokenize( (selector = compiled.selector || selector) );
 
 	results = results || [];
 
 	// Try to minimize operations if there is only one selector in the list and no seed
 	// (the latter of which guarantees us context)
 	if ( match.length === 1 ) {
 
 		// Reduce context if the leading compound selector is an ID
 		tokens = match[0] = match[0].slice( 0 );
 		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
 				support.getById && context.nodeType === 9 && documentIsHTML &&
 				Expr.relative[ tokens[1].type ] ) {
 
 			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
 			if ( !context ) {
 				return results;
 
 			// Precompiled matchers will still verify ancestry, so step up a level
 			} else if ( compiled ) {
 				context = context.parentNode;
 			}
 
 			selector = selector.slice( tokens.shift().value.length );
 		}
 
 		// Fetch a seed set for right-to-left matching
 		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
 		while ( i-- ) {
 			token = tokens[i];
 
 			// Abort if we hit a combinator
 			if ( Expr.relative[ (type = token.type) ] ) {
 				break;
 			}
 			if ( (find = Expr.find[ type ]) ) {
 				// Search, expanding context for leading sibling combinators
 				if ( (seed = find(
 					token.matches[0].replace( runescape, funescape ),
 					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
 				)) ) {
 
 					// If seed is empty or no tokens remain, we can return early
 					tokens.splice( i, 1 );
 					selector = seed.length && toSelector( tokens );
 					if ( !selector ) {
 						push.apply( results, seed );
 						return results;
 					}
 
 					break;
 				}
 			}
 		}
 	}
 
 	// Compile and execute a filtering function if one is not provided
 	// Provide `match` to avoid retokenization if we modified the selector above
 	( compiled || compile( selector, match ) )(
 		seed,
 		context,
 		!documentIsHTML,
 		results,
 		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
 	);
 	return results;
 };
 
 // One-time assignments
 
 // Sort stability
 support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
 
 // Support: Chrome 14-35+
 // Always assume duplicates if they aren't passed to the comparison function
 support.detectDuplicates = !!hasDuplicate;
 
 // Initialize against the default document
 setDocument();
 
 // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
 // Detached nodes confoundingly follow *each other*
 support.sortDetached = assert(function( div1 ) {
 	// Should return 1, but returns 4 (following)
 	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
 });
 
 // Support: IE<8
 // Prevent attribute/property "interpolation"
 // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
 if ( !assert(function( div ) {
 	div.innerHTML = "<a href='#'></a>";
 	return div.firstChild.getAttribute("href") === "#" ;
 }) ) {
 	addHandle( "type|href|height|width", function( elem, name, isXML ) {
 		if ( !isXML ) {
 			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
 		}
 	});
 }
 
 // Support: IE<9
 // Use defaultValue in place of getAttribute("value")
 if ( !support.attributes || !assert(function( div ) {
 	div.innerHTML = "<input/>";
 	div.firstChild.setAttribute( "value", "" );
 	return div.firstChild.getAttribute( "value" ) === "";
 }) ) {
 	addHandle( "value", function( elem, name, isXML ) {
 		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
 			return elem.defaultValue;
 		}
 	});
 }
 
 // Support: IE<9
 // Use getAttributeNode to fetch booleans when getAttribute lies
 if ( !assert(function( div ) {
 	return div.getAttribute("disabled") == null;
 }) ) {
 	addHandle( booleans, function( elem, name, isXML ) {
 		var val;
 		if ( !isXML ) {
 			return elem[ name ] === true ? name.toLowerCase() :
 					(val = elem.getAttributeNode( name )) && val.specified ?
 					val.value :
 				null;
 		}
 	});
 }
 
 return Sizzle;
 
 })( window );
 
 
 
 jQuery.find = Sizzle;
 jQuery.expr = Sizzle.selectors;
 jQuery.expr[ ":" ] = jQuery.expr.pseudos;
 jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
 jQuery.text = Sizzle.getText;
 jQuery.isXMLDoc = Sizzle.isXML;
 jQuery.contains = Sizzle.contains;
 
 
 
 var dir = function( elem, dir, until ) {
 	var matched = [],
 		truncate = until !== undefined;
 
 	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
 		if ( elem.nodeType === 1 ) {
 			if ( truncate && jQuery( elem ).is( until ) ) {
 				break;
 			}
 			matched.push( elem );
 		}
 	}
 	return matched;
 };
 
 
 var siblings = function( n, elem ) {
 	var matched = [];
 
 	for ( ; n; n = n.nextSibling ) {
 		if ( n.nodeType === 1 && n !== elem ) {
 			matched.push( n );
 		}
 	}
 
 	return matched;
 };
 
 
 var rneedsContext = jQuery.expr.match.needsContext;
 
 var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );
 
 
 
 var risSimple = /^.[^:#\[\.,]*$/;
 
 // Implement the identical functionality for filter and not
 function winnow( elements, qualifier, not ) {
 	if ( jQuery.isFunction( qualifier ) ) {
 		return jQuery.grep( elements, function( elem, i ) {
 			/* jshint -W018 */
 			return !!qualifier.call( elem, i, elem ) !== not;
 		} );
 
 	}
 
 	if ( qualifier.nodeType ) {
 		return jQuery.grep( elements, function( elem ) {
 			return ( elem === qualifier ) !== not;
 		} );
 
 	}
 
 	if ( typeof qualifier === "string" ) {
 		if ( risSimple.test( qualifier ) ) {
 			return jQuery.filter( qualifier, elements, not );
 		}
 
 		qualifier = jQuery.filter( qualifier, elements );
 	}
 
 	return jQuery.grep( elements, function( elem ) {
 		return ( jQuery.inArray( elem, qualifier ) > -1 ) !== not;
 	} );
 }
 
 jQuery.filter = function( expr, elems, not ) {
 	var elem = elems[ 0 ];
 
 	if ( not ) {
 		expr = ":not(" + expr + ")";
 	}
 
 	return elems.length === 1 && elem.nodeType === 1 ?
 		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
 		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
 			return elem.nodeType === 1;
 		} ) );
 };
 
 jQuery.fn.extend( {
 	find: function( selector ) {
 		var i,
 			ret = [],
 			self = this,
 			len = self.length;
 
 		if ( typeof selector !== "string" ) {
 			return this.pushStack( jQuery( selector ).filter( function() {
 				for ( i = 0; i < len; i++ ) {
 					if ( jQuery.contains( self[ i ], this ) ) {
 						return true;
 					}
 				}
 			} ) );
 		}
 
 		for ( i = 0; i < len; i++ ) {
 			jQuery.find( selector, self[ i ], ret );
 		}
 
 		// Needed because $( selector, context ) becomes $( context ).find( selector )
 		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
 		ret.selector = this.selector ? this.selector + " " + selector : selector;
 		return ret;
 	},
 	filter: function( selector ) {
 		return this.pushStack( winnow( this, selector || [], false ) );
 	},
 	not: function( selector ) {
 		return this.pushStack( winnow( this, selector || [], true ) );
 	},
 	is: function( selector ) {
 		return !!winnow(
 			this,
 
 			// If this is a positional/relative selector, check membership in the returned set
 			// so $("p:first").is("p:last") won't return true for a doc with two "p".
 			typeof selector === "string" && rneedsContext.test( selector ) ?
 				jQuery( selector ) :
 				selector || [],
 			false
 		).length;
 	}
 } );
 
 
 // Initialize a jQuery object
 
 
 // A central reference to the root jQuery(document)
 var rootjQuery,
 
 	// A simple way to check for HTML strings
 	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
 	// Strict HTML recognition (#11290: must start with <)
 	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
 
 	init = jQuery.fn.init = function( selector, context, root ) {
 		var match, elem;
 
 		// HANDLE: $(""), $(null), $(undefined), $(false)
 		if ( !selector ) {
 			return this;
 		}
 
 		// init accepts an alternate rootjQuery
 		// so migrate can support jQuery.sub (gh-2101)
 		root = root || rootjQuery;
 
 		// Handle HTML strings
 		if ( typeof selector === "string" ) {
 			if ( selector.charAt( 0 ) === "<" &&
 				selector.charAt( selector.length - 1 ) === ">" &&
 				selector.length >= 3 ) {
 
 				// Assume that strings that start and end with <> are HTML and skip the regex check
 				match = [ null, selector, null ];
 
 			} else {
 				match = rquickExpr.exec( selector );
 			}
 
 			// Match html or make sure no context is specified for #id
 			if ( match && ( match[ 1 ] || !context ) ) {
 
 				// HANDLE: $(html) -> $(array)
 				if ( match[ 1 ] ) {
 					context = context instanceof jQuery ? context[ 0 ] : context;
 
 					// scripts is true for back-compat
 					// Intentionally let the error be thrown if parseHTML is not present
 					jQuery.merge( this, jQuery.parseHTML(
 						match[ 1 ],
 						context && context.nodeType ? context.ownerDocument || context : document,
 						true
 					) );
 
 					// HANDLE: $(html, props)
 					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
 						for ( match in context ) {
 
 							// Properties of context are called as methods if possible
 							if ( jQuery.isFunction( this[ match ] ) ) {
 								this[ match ]( context[ match ] );
 
 							// ...and otherwise set as attributes
 							} else {
 								this.attr( match, context[ match ] );
 							}
 						}
 					}
 
 					return this;
 
 				// HANDLE: $(#id)
 				} else {
 					elem = document.getElementById( match[ 2 ] );
 
 					// Check parentNode to catch when Blackberry 4.6 returns
 					// nodes that are no longer in the document #6963
 					if ( elem && elem.parentNode ) {
 
 						// Handle the case where IE and Opera return items
 						// by name instead of ID
 						if ( elem.id !== match[ 2 ] ) {
 							return rootjQuery.find( selector );
 						}
 
 						// Otherwise, we inject the element directly into the jQuery object
 						this.length = 1;
 						this[ 0 ] = elem;
 					}
 
 					this.context = document;
 					this.selector = selector;
 					return this;
 				}
 
 			// HANDLE: $(expr, $(...))
 			} else if ( !context || context.jquery ) {
 				return ( context || root ).find( selector );
 
 			// HANDLE: $(expr, context)
 			// (which is just equivalent to: $(context).find(expr)
 			} else {
 				return this.constructor( context ).find( selector );
 			}
 
 		// HANDLE: $(DOMElement)
 		} else if ( selector.nodeType ) {
 			this.context = this[ 0 ] = selector;
 			this.length = 1;
 			return this;
 
 		// HANDLE: $(function)
 		// Shortcut for document ready
 		} else if ( jQuery.isFunction( selector ) ) {
 			return typeof root.ready !== "undefined" ?
 				root.ready( selector ) :
 
 				// Execute immediately if ready is not present
 				selector( jQuery );
 		}
 
 		if ( selector.selector !== undefined ) {
 			this.selector = selector.selector;
 			this.context = selector.context;
 		}
 
 		return jQuery.makeArray( selector, this );
 	};
 
 // Give the init function the jQuery prototype for later instantiation
 init.prototype = jQuery.fn;
 
 // Initialize central reference
 rootjQuery = jQuery( document );
 
 
 var rparentsprev = /^(?:parents|prev(?:Until|All))/,
 
 	// methods guaranteed to produce a unique set when starting from a unique set
 	guaranteedUnique = {
 		children: true,
 		contents: true,
 		next: true,
 		prev: true
 	};
 
 jQuery.fn.extend( {
 	has: function( target ) {
 		var i,
 			targets = jQuery( target, this ),
 			len = targets.length;
 
 		return this.filter( function() {
 			for ( i = 0; i < len; i++ ) {
 				if ( jQuery.contains( this, targets[ i ] ) ) {
 					return true;
 				}
 			}
 		} );
 	},
 
 	closest: function( selectors, context ) {
 		var cur,
 			i = 0,
 			l = this.length,
 			matched = [],
 			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
 				jQuery( selectors, context || this.context ) :
 				0;
 
 		for ( ; i < l; i++ ) {
 			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
 
 				// Always skip document fragments
 				if ( cur.nodeType < 11 && ( pos ?
 					pos.index( cur ) > -1 :
 
 					// Don't pass non-elements to Sizzle
 					cur.nodeType === 1 &&
 						jQuery.find.matchesSelector( cur, selectors ) ) ) {
 
 					matched.push( cur );
 					break;
 				}
 			}
 		}
 
 		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
 	},
 
 	// Determine the position of an element within
 	// the matched set of elements
 	index: function( elem ) {
 
 		// No argument, return index in parent
 		if ( !elem ) {
 			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
 		}
 
 		// index in selector
 		if ( typeof elem === "string" ) {
 			return jQuery.inArray( this[ 0 ], jQuery( elem ) );
 		}
 
 		// Locate the position of the desired element
 		return jQuery.inArray(
 
 			// If it receives a jQuery object, the first element is used
 			elem.jquery ? elem[ 0 ] : elem, this );
 	},
 
 	add: function( selector, context ) {
 		return this.pushStack(
 			jQuery.uniqueSort(
 				jQuery.merge( this.get(), jQuery( selector, context ) )
 			)
 		);
 	},
 
 	addBack: function( selector ) {
 		return this.add( selector == null ?
 			this.prevObject : this.prevObject.filter( selector )
 		);
 	}
 } );
 
 function sibling( cur, dir ) {
 	do {
 		cur = cur[ dir ];
 	} while ( cur && cur.nodeType !== 1 );
 
 	return cur;
 }
 
 jQuery.each( {
 	parent: function( elem ) {
 		var parent = elem.parentNode;
 		return parent && parent.nodeType !== 11 ? parent : null;
 	},
 	parents: function( elem ) {
 		return dir( elem, "parentNode" );
 	},
 	parentsUntil: function( elem, i, until ) {
 		return dir( elem, "parentNode", until );
 	},
 	next: function( elem ) {
 		return sibling( elem, "nextSibling" );
 	},
 	prev: function( elem ) {
 		return sibling( elem, "previousSibling" );
 	},
 	nextAll: function( elem ) {
 		return dir( elem, "nextSibling" );
 	},
 	prevAll: function( elem ) {
 		return dir( elem, "previousSibling" );
 	},
 	nextUntil: function( elem, i, until ) {
 		return dir( elem, "nextSibling", until );
 	},
 	prevUntil: function( elem, i, until ) {
 		return dir( elem, "previousSibling", until );
 	},
 	siblings: function( elem ) {
 		return siblings( ( elem.parentNode || {} ).firstChild, elem );
 	},
 	children: function( elem ) {
 		return siblings( elem.firstChild );
 	},
 	contents: function( elem ) {
 		return jQuery.nodeName( elem, "iframe" ) ?
 			elem.contentDocument || elem.contentWindow.document :
 			jQuery.merge( [], elem.childNodes );
 	}
 }, function( name, fn ) {
 	jQuery.fn[ name ] = function( until, selector ) {
 		var ret = jQuery.map( this, fn, until );
 
 		if ( name.slice( -5 ) !== "Until" ) {
 			selector = until;
 		}
 
 		if ( selector && typeof selector === "string" ) {
 			ret = jQuery.filter( selector, ret );
 		}
 
 		if ( this.length > 1 ) {
 
 			// Remove duplicates
 			if ( !guaranteedUnique[ name ] ) {
 				ret = jQuery.uniqueSort( ret );
 			}
 
 			// Reverse order for parents* and prev-derivatives
 			if ( rparentsprev.test( name ) ) {
 				ret = ret.reverse();
 			}
 		}
 
 		return this.pushStack( ret );
 	};
 } );
 var rnotwhite = ( /\S+/g );
 
 
 
 // Convert String-formatted options into Object-formatted ones
 function createOptions( options ) {
 	var object = {};
 	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
 		object[ flag ] = true;
 	} );
 	return object;
 }
 
 /*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
 jQuery.Callbacks = function( options ) {
 
 	// Convert options from String-formatted to Object-formatted if needed
 	// (we check in cache first)
 	options = typeof options === "string" ?
 		createOptions( options ) :
 		jQuery.extend( {}, options );
 
 	var // Flag to know if list is currently firing
 		firing,
 
 		// Last fire value for non-forgettable lists
 		memory,
 
 		// Flag to know if list was already fired
 		fired,
 
 		// Flag to prevent firing
 		locked,
 
 		// Actual callback list
 		list = [],
 
 		// Queue of execution data for repeatable lists
 		queue = [],
 
 		// Index of currently firing callback (modified by add/remove as needed)
 		firingIndex = -1,
 
 		// Fire callbacks
 		fire = function() {
 
 			// Enforce single-firing
 			locked = options.once;
 
 			// Execute callbacks for all pending executions,
 			// respecting firingIndex overrides and runtime changes
 			fired = firing = true;
 			for ( ; queue.length; firingIndex = -1 ) {
 				memory = queue.shift();
 				while ( ++firingIndex < list.length ) {
 
 					// Run callback and check for early termination
 					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
 						options.stopOnFalse ) {
 
 						// Jump to end and forget the data so .add doesn't re-fire
 						firingIndex = list.length;
 						memory = false;
 					}
 				}
 			}
 
 			// Forget the data if we're done with it
 			if ( !options.memory ) {
 				memory = false;
 			}
 
 			firing = false;
 
 			// Clean up if we're done firing for good
 			if ( locked ) {
 
 				// Keep an empty list if we have data for future add calls
 				if ( memory ) {
 					list = [];
 
 				// Otherwise, this object is spent
 				} else {
 					list = "";
 				}
 			}
 		},
 
 		// Actual Callbacks object
 		self = {
 
 			// Add a callback or a collection of callbacks to the list
 			add: function() {
 				if ( list ) {
 
 					// If we have memory from a past run, we should fire after adding
 					if ( memory && !firing ) {
 						firingIndex = list.length - 1;
 						queue.push( memory );
 					}
 
 					( function add( args ) {
 						jQuery.each( args, function( _, arg ) {
 							if ( jQuery.isFunction( arg ) ) {
 								if ( !options.unique || !self.has( arg ) ) {
 									list.push( arg );
 								}
 							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
 
 								// Inspect recursively
 								add( arg );
 							}
 						} );
 					} )( arguments );
 
 					if ( memory && !firing ) {
 						fire();
 					}
 				}
 				return this;
 			},
 
 			// Remove a callback from the list
 			remove: function() {
 				jQuery.each( arguments, function( _, arg ) {
 					var index;
 					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
 						list.splice( index, 1 );
 
 						// Handle firing indexes
 						if ( index <= firingIndex ) {
 							firingIndex--;
 						}
 					}
 				} );
 				return this;
 			},
 
 			// Check if a given callback is in the list.
 			// If no argument is given, return whether or not list has callbacks attached.
 			has: function( fn ) {
 				return fn ?
 					jQuery.inArray( fn, list ) > -1 :
 					list.length > 0;
 			},
 
 			// Remove all callbacks from the list
 			empty: function() {
 				if ( list ) {
 					list = [];
 				}
 				return this;
 			},
 
 			// Disable .fire and .add
 			// Abort any current/pending executions
 			// Clear all callbacks and values
 			disable: function() {
 				locked = queue = [];
 				list = memory = "";
 				return this;
 			},
 			disabled: function() {
 				return !list;
 			},
 
 			// Disable .fire
 			// Also disable .add unless we have memory (since it would have no effect)
 			// Abort any pending executions
 			lock: function() {
 				locked = true;
 				if ( !memory ) {
 					self.disable();
 				}
 				return this;
 			},
 			locked: function() {
 				return !!locked;
 			},
 
 			// Call all callbacks with the given context and arguments
 			fireWith: function( context, args ) {
 				if ( !locked ) {
 					args = args || [];
 					args = [ context, args.slice ? args.slice() : args ];
 					queue.push( args );
 					if ( !firing ) {
 						fire();
 					}
 				}
 				return this;
 			},
 
 			// Call all the callbacks with the given arguments
 			fire: function() {
 				self.fireWith( this, arguments );
 				return this;
 			},
 
 			// To know if the callbacks have already been called at least once
 			fired: function() {
 				return !!fired;
 			}
 		};
 
 	return self;
 };
 
 
 jQuery.extend( {
 
 	Deferred: function( func ) {
 		var tuples = [
 
 				// action, add listener, listener list, final state
 				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
 				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
 				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
 			],
 			state = "pending",
 			promise = {
 				state: function() {
 					return state;
 				},
 				always: function() {
 					deferred.done( arguments ).fail( arguments );
 					return this;
 				},
 				then: function( /* fnDone, fnFail, fnProgress */ ) {
 					var fns = arguments;
 					return jQuery.Deferred( function( newDefer ) {
 						jQuery.each( tuples, function( i, tuple ) {
 							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
 
 							// deferred[ done | fail | progress ] for forwarding actions to newDefer
 							deferred[ tuple[ 1 ] ]( function() {
 								var returned = fn && fn.apply( this, arguments );
 								if ( returned && jQuery.isFunction( returned.promise ) ) {
 									returned.promise()
 										.progress( newDefer.notify )
 										.done( newDefer.resolve )
 										.fail( newDefer.reject );
 								} else {
 									newDefer[ tuple[ 0 ] + "With" ](
 										this === promise ? newDefer.promise() : this,
 										fn ? [ returned ] : arguments
 									);
 								}
 							} );
 						} );
 						fns = null;
 					} ).promise();
 				},
 
 				// Get a promise for this deferred
 				// If obj is provided, the promise aspect is added to the object
 				promise: function( obj ) {
 					return obj != null ? jQuery.extend( obj, promise ) : promise;
 				}
 			},
 			deferred = {};
 
 		// Keep pipe for back-compat
 		promise.pipe = promise.then;
 
 		// Add list-specific methods
 		jQuery.each( tuples, function( i, tuple ) {
 			var list = tuple[ 2 ],
 				stateString = tuple[ 3 ];
 
 			// promise[ done | fail | progress ] = list.add
 			promise[ tuple[ 1 ] ] = list.add;
 
 			// Handle state
 			if ( stateString ) {
 				list.add( function() {
 
 					// state = [ resolved | rejected ]
 					state = stateString;
 
 				// [ reject_list | resolve_list ].disable; progress_list.lock
 				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
 			}
 
 			// deferred[ resolve | reject | notify ]
 			deferred[ tuple[ 0 ] ] = function() {
 				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
 				return this;
 			};
 			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
 		} );
 
 		// Make the deferred a promise
 		promise.promise( deferred );
 
 		// Call given func if any
 		if ( func ) {
 			func.call( deferred, deferred );
 		}
 
 		// All done!
 		return deferred;
 	},
 
 	// Deferred helper
 	when: function( subordinate /* , ..., subordinateN */ ) {
 		var i = 0,
 			resolveValues = slice.call( arguments ),
 			length = resolveValues.length,
 
 			// the count of uncompleted subordinates
 			remaining = length !== 1 ||
 				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
 
 			// the master Deferred.
 			// If resolveValues consist of only a single Deferred, just use that.
 			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
 
 			// Update function for both resolve and progress values
 			updateFunc = function( i, contexts, values ) {
 				return function( value ) {
 					contexts[ i ] = this;
 					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
 					if ( values === progressValues ) {
 						deferred.notifyWith( contexts, values );
 
 					} else if ( !( --remaining ) ) {
 						deferred.resolveWith( contexts, values );
 					}
 				};
 			},
 
 			progressValues, progressContexts, resolveContexts;
 
 		// add listeners to Deferred subordinates; treat others as resolved
 		if ( length > 1 ) {
 			progressValues = new Array( length );
 			progressContexts = new Array( length );
 			resolveContexts = new Array( length );
 			for ( ; i < length; i++ ) {
 				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
 					resolveValues[ i ].promise()
 						.progress( updateFunc( i, progressContexts, progressValues ) )
 						.done( updateFunc( i, resolveContexts, resolveValues ) )
 						.fail( deferred.reject );
 				} else {
 					--remaining;
 				}
 			}
 		}
 
 		// if we're not waiting on anything, resolve the master
 		if ( !remaining ) {
 			deferred.resolveWith( resolveContexts, resolveValues );
 		}
 
 		return deferred.promise();
 	}
 } );
 
 
 // The deferred used on DOM ready
 var readyList;
 
 jQuery.fn.ready = function( fn ) {
 
 	// Add the callback
 	jQuery.ready.promise().done( fn );
 
 	return this;
 };
 
 jQuery.extend( {
 
 	// Is the DOM ready to be used? Set to true once it occurs.
 	isReady: false,
 
 	// A counter to track how many items to wait for before
 	// the ready event fires. See #6781
 	readyWait: 1,
 
 	// Hold (or release) the ready event
 	holdReady: function( hold ) {
 		if ( hold ) {
 			jQuery.readyWait++;
 		} else {
 			jQuery.ready( true );
 		}
 	},
 
 	// Handle when the DOM is ready
 	ready: function( wait ) {
 
 		// Abort if there are pending holds or we're already ready
 		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
 			return;
 		}
 
 		// Remember that the DOM is ready
 		jQuery.isReady = true;
 
 		// If a normal DOM Ready event fired, decrement, and wait if need be
 		if ( wait !== true && --jQuery.readyWait > 0 ) {
 			return;
 		}
 
 		// If there are functions bound, to execute
 		readyList.resolveWith( document, [ jQuery ] );
 
 		// Trigger any bound ready events
 		if ( jQuery.fn.triggerHandler ) {
 			jQuery( document ).triggerHandler( "ready" );
 			jQuery( document ).off( "ready" );
 		}
 	}
 } );
 
 /**
  * Clean-up method for dom ready events
  */
 function detach() {
 	if ( document.addEventListener ) {
 		document.removeEventListener( "DOMContentLoaded", completed );
 		window.removeEventListener( "load", completed );
 
 	} else {
 		document.detachEvent( "onreadystatechange", completed );
 		window.detachEvent( "onload", completed );
 	}
 }
 
 /**
  * The ready event handler and self cleanup method
  */
 function completed() {
 
 	// readyState === "complete" is good enough for us to call the dom ready in oldIE
 	if ( document.addEventListener ||
 		window.event.type === "load" ||
 		document.readyState === "complete" ) {
 
 		detach();
 		jQuery.ready();
 	}
 }
 
 jQuery.ready.promise = function( obj ) {
 	if ( !readyList ) {
 
 		readyList = jQuery.Deferred();
 
 		// Catch cases where $(document).ready() is called
 		// after the browser event has already occurred.
 		// Support: IE6-10
 		// Older IE sometimes signals "interactive" too soon
 		if ( document.readyState === "complete" ||
 			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
 
 			// Handle it asynchronously to allow scripts the opportunity to delay ready
 			window.setTimeout( jQuery.ready );
 
 		// Standards-based browsers support DOMContentLoaded
 		} else if ( document.addEventListener ) {
 
 			// Use the handy event callback
 			document.addEventListener( "DOMContentLoaded", completed );
 
 			// A fallback to window.onload, that will always work
 			window.addEventListener( "load", completed );
 
 		// If IE event model is used
 		} else {
 
 			// Ensure firing before onload, maybe late but safe also for iframes
 			document.attachEvent( "onreadystatechange", completed );
 
 			// A fallback to window.onload, that will always work
 			window.attachEvent( "onload", completed );
 
 			// If IE and not a frame
 			// continually check to see if the document is ready
 			var top = false;
 
 			try {
 				top = window.frameElement == null && document.documentElement;
 			} catch ( e ) {}
 
 			if ( top && top.doScroll ) {
 				( function doScrollCheck() {
 					if ( !jQuery.isReady ) {
 
 						try {
 
 							// Use the trick by Diego Perini
 							// http://javascript.nwbox.com/IEContentLoaded/
 							top.doScroll( "left" );
 						} catch ( e ) {
 							return window.setTimeout( doScrollCheck, 50 );
 						}
 
 						// detach all dom ready events
 						detach();
 
 						// and execute any waiting functions
 						jQuery.ready();
 					}
 				} )();
 			}
 		}
 	}
 	return readyList.promise( obj );
 };
 
 // Kick off the DOM ready check even if the user does not
 jQuery.ready.promise();
 
 
 
 
 // Support: IE<9
 // Iteration over object's inherited properties before its own
 var i;
 for ( i in jQuery( support ) ) {
 	break;
 }
 support.ownFirst = i === "0";
 
 // Note: most support tests are defined in their respective modules.
 // false until the test is run
 support.inlineBlockNeedsLayout = false;
 
 // Execute ASAP in case we need to set body.style.zoom
 jQuery( function() {
 
 	// Minified: var a,b,c,d
 	var val, div, body, container;
 
 	body = document.getElementsByTagName( "body" )[ 0 ];
 	if ( !body || !body.style ) {
 
 		// Return for frameset docs that don't have a body
 		return;
 	}
 
 	// Setup
 	div = document.createElement( "div" );
 	container = document.createElement( "div" );
 	container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
 	body.appendChild( container ).appendChild( div );
 
 	if ( typeof div.style.zoom !== "undefined" ) {
 
 		// Support: IE<8
 		// Check if natively block-level elements act like inline-block
 		// elements when setting their display to 'inline' and giving
 		// them layout
 		div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";
 
 		support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
 		if ( val ) {
 
 			// Prevent IE 6 from affecting layout for positioned elements #11048
 			// Prevent IE from shrinking the body in IE 7 mode #12869
 			// Support: IE<8
 			body.style.zoom = 1;
 		}
 	}
 
 	body.removeChild( container );
 } );
 
 
 ( function() {
 	var div = document.createElement( "div" );
 
 	// Support: IE<9
 	support.deleteExpando = true;
 	try {
 		delete div.test;
 	} catch ( e ) {
 		support.deleteExpando = false;
 	}
 
 	// Null elements to avoid leaks in IE.
 	div = null;
 } )();
 var acceptData = function( elem ) {
 	var noData = jQuery.noData[ ( elem.nodeName + " " ).toLowerCase() ],
 		nodeType = +elem.nodeType || 1;
 
 	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
 	return nodeType !== 1 && nodeType !== 9 ?
 		false :
 
 		// Nodes accept data unless otherwise specified; rejection can be conditional
 		!noData || noData !== true && elem.getAttribute( "classid" ) === noData;
 };
 
 
 
 
 var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
 	rmultiDash = /([A-Z])/g;
 
 function dataAttr( elem, key, data ) {
 
 	// If nothing was found internally, try to fetch any
 	// data from the HTML5 data-* attribute
 	if ( data === undefined && elem.nodeType === 1 ) {
 
 		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
 
 		data = elem.getAttribute( name );
 
 		if ( typeof data === "string" ) {
 			try {
 				data = data === "true" ? true :
 					data === "false" ? false :
 					data === "null" ? null :
 
 					// Only convert to a number if it doesn't change the string
 					+data + "" === data ? +data :
 					rbrace.test( data ) ? jQuery.parseJSON( data ) :
 					data;
 			} catch ( e ) {}
 
 			// Make sure we set the data so it isn't changed later
 			jQuery.data( elem, key, data );
 
 		} else {
 			data = undefined;
 		}
 	}
 
 	return data;
 }
 
 // checks a cache object for emptiness
 function isEmptyDataObject( obj ) {
 	var name;
 	for ( name in obj ) {
 
 		// if the public data object is empty, the private is still empty
 		if ( name === "data" && jQuery.isEmptyObject( obj[ name ] ) ) {
 			continue;
 		}
 		if ( name !== "toJSON" ) {
 			return false;
 		}
 	}
 
 	return true;
 }
 
 function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
 	if ( !acceptData( elem ) ) {
 		return;
 	}
 
 	var ret, thisCache,
 		internalKey = jQuery.expando,
 
 		// We have to handle DOM nodes and JS objects differently because IE6-7
 		// can't GC object references properly across the DOM-JS boundary
 		isNode = elem.nodeType,
 
 		// Only DOM nodes need the global jQuery cache; JS object data is
 		// attached directly to the object so GC can occur automatically
 		cache = isNode ? jQuery.cache : elem,
 
 		// Only defining an ID for JS objects if its cache already exists allows
 		// the code to shortcut on the same path as a DOM node with no cache
 		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;
 
 	// Avoid doing any more work than we need to when trying to get data on an
 	// object that has no data at all
 	if ( ( !id || !cache[ id ] || ( !pvt && !cache[ id ].data ) ) &&
 		data === undefined && typeof name === "string" ) {
 		return;
 	}
 
 	if ( !id ) {
 
 		// Only DOM nodes need a new unique ID for each element since their data
 		// ends up in the global cache
 		if ( isNode ) {
 			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
 		} else {
 			id = internalKey;
 		}
 	}
 
 	if ( !cache[ id ] ) {
 
 		// Avoid exposing jQuery metadata on plain JS objects when the object
 		// is serialized using JSON.stringify
 		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
 	}
 
 	// An object can be passed to jQuery.data instead of a key/value pair; this gets
 	// shallow copied over onto the existing cache
 	if ( typeof name === "object" || typeof name === "function" ) {
 		if ( pvt ) {
 			cache[ id ] = jQuery.extend( cache[ id ], name );
 		} else {
 			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
 		}
 	}
 
 	thisCache = cache[ id ];
 
 	// jQuery data() is stored in a separate object inside the object's internal data
 	// cache in order to avoid key collisions between internal data and user-defined
 	// data.
 	if ( !pvt ) {
 		if ( !thisCache.data ) {
 			thisCache.data = {};
 		}
 
 		thisCache = thisCache.data;
 	}
 
 	if ( data !== undefined ) {
 		thisCache[ jQuery.camelCase( name ) ] = data;
 	}
 
 	// Check for both converted-to-camel and non-converted data property names
 	// If a data property was specified
 	if ( typeof name === "string" ) {
 
 		// First Try to find as-is property data
 		ret = thisCache[ name ];
 
 		// Test for null|undefined property data
 		if ( ret == null ) {
 
 			// Try to find the camelCased property
 			ret = thisCache[ jQuery.camelCase( name ) ];
 		}
 	} else {
 		ret = thisCache;
 	}
 
 	return ret;
 }
 
 function internalRemoveData( elem, name, pvt ) {
 	if ( !acceptData( elem ) ) {
 		return;
 	}
 
 	var thisCache, i,
 		isNode = elem.nodeType,
 
 		// See jQuery.data for more information
 		cache = isNode ? jQuery.cache : elem,
 		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
 
 	// If there is already no cache entry for this object, there is no
 	// purpose in continuing
 	if ( !cache[ id ] ) {
 		return;
 	}
 
 	if ( name ) {
 
 		thisCache = pvt ? cache[ id ] : cache[ id ].data;
 
 		if ( thisCache ) {
 
 			// Support array or space separated string names for data keys
 			if ( !jQuery.isArray( name ) ) {
 
 				// try the string as a key before any manipulation
 				if ( name in thisCache ) {
 					name = [ name ];
 				} else {
 
 					// split the camel cased version by spaces unless a key with the spaces exists
 					name = jQuery.camelCase( name );
 					if ( name in thisCache ) {
 						name = [ name ];
 					} else {
 						name = name.split( " " );
 					}
 				}
 			} else {
 
 				// If "name" is an array of keys...
 				// When data is initially created, via ("key", "val") signature,
 				// keys will be converted to camelCase.
 				// Since there is no way to tell _how_ a key was added, remove
 				// both plain key and camelCase key. #12786
 				// This will only penalize the array argument path.
 				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
 			}
 
 			i = name.length;
 			while ( i-- ) {
 				delete thisCache[ name[ i ] ];
 			}
 
 			// If there is no data left in the cache, we want to continue
 			// and let the cache object itself get destroyed
 			if ( pvt ? !isEmptyDataObject( thisCache ) : !jQuery.isEmptyObject( thisCache ) ) {
 				return;
 			}
 		}
 	}
 
 	// See jQuery.data for more information
 	if ( !pvt ) {
 		delete cache[ id ].data;
 
 		// Don't destroy the parent cache unless the internal data object
 		// had been the only thing left in it
 		if ( !isEmptyDataObject( cache[ id ] ) ) {
 			return;
 		}
 	}
 
 	// Destroy the cache
 	if ( isNode ) {
 		jQuery.cleanData( [ elem ], true );
 
 	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
 	/* jshint eqeqeq: false */
 	} else if ( support.deleteExpando || cache != cache.window ) {
 		/* jshint eqeqeq: true */
 		delete cache[ id ];
 
 	// When all else fails, undefined
 	} else {
 		cache[ id ] = undefined;
 	}
 }
 
 jQuery.extend( {
 	cache: {},
 
 	// The following elements (space-suffixed to avoid Object.prototype collisions)
 	// throw uncatchable exceptions if you attempt to set expando properties
 	noData: {
 		"applet ": true,
 		"embed ": true,
 
 		// ...but Flash objects (which have this classid) *can* handle expandos
 		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
 	},
 
 	hasData: function( elem ) {
 		elem = elem.nodeType ? jQuery.cache[ elem[ jQuery.expando ] ] : elem[ jQuery.expando ];
 		return !!elem && !isEmptyDataObject( elem );
 	},
 
 	data: function( elem, name, data ) {
 		return internalData( elem, name, data );
 	},
 
 	removeData: function( elem, name ) {
 		return internalRemoveData( elem, name );
 	},
 
 	// For internal use only.
 	_data: function( elem, name, data ) {
 		return internalData( elem, name, data, true );
 	},
 
 	_removeData: function( elem, name ) {
 		return internalRemoveData( elem, name, true );
 	}
 } );
 
 jQuery.fn.extend( {
 	data: function( key, value ) {
 		var i, name, data,
 			elem = this[ 0 ],
 			attrs = elem && elem.attributes;
 
 		// Special expections of .data basically thwart jQuery.access,
 		// so implement the relevant behavior ourselves
 
 		// Gets all values
 		if ( key === undefined ) {
 			if ( this.length ) {
 				data = jQuery.data( elem );
 
 				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
 					i = attrs.length;
 					while ( i-- ) {
 
 						// Support: IE11+
 						// The attrs elements can be null (#14894)
 						if ( attrs[ i ] ) {
 							name = attrs[ i ].name;
 							if ( name.indexOf( "data-" ) === 0 ) {
 								name = jQuery.camelCase( name.slice( 5 ) );
 								dataAttr( elem, name, data[ name ] );
 							}
 						}
 					}
 					jQuery._data( elem, "parsedAttrs", true );
 				}
 			}
 
 			return data;
 		}
 
 		// Sets multiple values
 		if ( typeof key === "object" ) {
 			return this.each( function() {
 				jQuery.data( this, key );
 			} );
 		}
 
 		return arguments.length > 1 ?
 
 			// Sets one value
 			this.each( function() {
 				jQuery.data( this, key, value );
 			} ) :
 
 			// Gets one value
 			// Try to fetch any internally stored data first
 			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
 	},
 
 	removeData: function( key ) {
 		return this.each( function() {
 			jQuery.removeData( this, key );
 		} );
 	}
 } );
 
 
 jQuery.extend( {
 	queue: function( elem, type, data ) {
 		var queue;
 
 		if ( elem ) {
 			type = ( type || "fx" ) + "queue";
 			queue = jQuery._data( elem, type );
 
 			// Speed up dequeue by getting out quickly if this is just a lookup
 			if ( data ) {
 				if ( !queue || jQuery.isArray( data ) ) {
 					queue = jQuery._data( elem, type, jQuery.makeArray( data ) );
 				} else {
 					queue.push( data );
 				}
 			}
 			return queue || [];
 		}
 	},
 
 	dequeue: function( elem, type ) {
 		type = type || "fx";
 
 		var queue = jQuery.queue( elem, type ),
 			startLength = queue.length,
 			fn = queue.shift(),
 			hooks = jQuery._queueHooks( elem, type ),
 			next = function() {
 				jQuery.dequeue( elem, type );
 			};
 
 		// If the fx queue is dequeued, always remove the progress sentinel
 		if ( fn === "inprogress" ) {
 			fn = queue.shift();
 			startLength--;
 		}
 
 		if ( fn ) {
 
 			// Add a progress sentinel to prevent the fx queue from being
 			// automatically dequeued
 			if ( type === "fx" ) {
 				queue.unshift( "inprogress" );
 			}
 
 			// clear up the last queue stop function
 			delete hooks.stop;
 			fn.call( elem, next, hooks );
 		}
 
 		if ( !startLength && hooks ) {
 			hooks.empty.fire();
 		}
 	},
 
 	// not intended for public consumption - generates a queueHooks object,
 	// or returns the current one
 	_queueHooks: function( elem, type ) {
 		var key = type + "queueHooks";
 		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
 			empty: jQuery.Callbacks( "once memory" ).add( function() {
 				jQuery._removeData( elem, type + "queue" );
 				jQuery._removeData( elem, key );
 			} )
 		} );
 	}
 } );
 
 jQuery.fn.extend( {
 	queue: function( type, data ) {
 		var setter = 2;
 
 		if ( typeof type !== "string" ) {
 			data = type;
 			type = "fx";
 			setter--;
 		}
 
 		if ( arguments.length < setter ) {
 			return jQuery.queue( this[ 0 ], type );
 		}
 
 		return data === undefined ?
 			this :
 			this.each( function() {
 				var queue = jQuery.queue( this, type, data );
 
 				// ensure a hooks for this queue
 				jQuery._queueHooks( this, type );
 
 				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
 					jQuery.dequeue( this, type );
 				}
 			} );
 	},
 	dequeue: function( type ) {
 		return this.each( function() {
 			jQuery.dequeue( this, type );
 		} );
 	},
 	clearQueue: function( type ) {
 		return this.queue( type || "fx", [] );
 	},
 
 	// Get a promise resolved when queues of a certain type
 	// are emptied (fx is the type by default)
 	promise: function( type, obj ) {
 		var tmp,
 			count = 1,
 			defer = jQuery.Deferred(),
 			elements = this,
 			i = this.length,
 			resolve = function() {
 				if ( !( --count ) ) {
 					defer.resolveWith( elements, [ elements ] );
 				}
 			};
 
 		if ( typeof type !== "string" ) {
 			obj = type;
 			type = undefined;
 		}
 		type = type || "fx";
 
 		while ( i-- ) {
 			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
 			if ( tmp && tmp.empty ) {
 				count++;
 				tmp.empty.add( resolve );
 			}
 		}
 		resolve();
 		return defer.promise( obj );
 	}
 } );
 
 
 ( function() {
 	var shrinkWrapBlocksVal;
 
 	support.shrinkWrapBlocks = function() {
 		if ( shrinkWrapBlocksVal != null ) {
 			return shrinkWrapBlocksVal;
 		}
 
 		// Will be changed later if needed.
 		shrinkWrapBlocksVal = false;
 
 		// Minified: var b,c,d
 		var div, body, container;
 
 		body = document.getElementsByTagName( "body" )[ 0 ];
 		if ( !body || !body.style ) {
 
 			// Test fired too early or in an unsupported environment, exit.
 			return;
 		}
 
 		// Setup
 		div = document.createElement( "div" );
 		container = document.createElement( "div" );
 		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
 		body.appendChild( container ).appendChild( div );
 
 		// Support: IE6
 		// Check if elements with layout shrink-wrap their children
 		if ( typeof div.style.zoom !== "undefined" ) {
 
 			// Reset CSS: box-sizing; display; margin; border
 			div.style.cssText =
 
 				// Support: Firefox<29, Android 2.3
 				// Vendor-prefix box-sizing
 				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
 				"box-sizing:content-box;display:block;margin:0;border:0;" +
 				"padding:1px;width:1px;zoom:1";
 			div.appendChild( document.createElement( "div" ) ).style.width = "5px";
 			shrinkWrapBlocksVal = div.offsetWidth !== 3;
 		}
 
 		body.removeChild( container );
 
 		return shrinkWrapBlocksVal;
 	};
 
 } )();
 var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
 
 var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
 
 
 var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
 
 var isHidden = function( elem, el ) {
 
 		// isHidden might be called from jQuery#filter function;
 		// in that case, element will be second argument
 		elem = el || elem;
 		return jQuery.css( elem, "display" ) === "none" ||
 			!jQuery.contains( elem.ownerDocument, elem );
 	};
 
 
 
 function adjustCSS( elem, prop, valueParts, tween ) {
 	var adjusted,
 		scale = 1,
 		maxIterations = 20,
 		currentValue = tween ?
 			function() { return tween.cur(); } :
 			function() { return jQuery.css( elem, prop, "" ); },
 		initial = currentValue(),
 		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
 
 		// Starting value computation is required for potential unit mismatches
 		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
 			rcssNum.exec( jQuery.css( elem, prop ) );
 
 	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
 
 		// Trust units reported by jQuery.css
 		unit = unit || initialInUnit[ 3 ];
 
 		// Make sure we update the tween properties later on
 		valueParts = valueParts || [];
 
 		// Iteratively approximate from a nonzero starting point
 		initialInUnit = +initial || 1;
 
 		do {
 
 			// If previous iteration zeroed out, double until we get *something*.
 			// Use string for doubling so we don't accidentally see scale as unchanged below
 			scale = scale || ".5";
 
 			// Adjust and apply
 			initialInUnit = initialInUnit / scale;
 			jQuery.style( elem, prop, initialInUnit + unit );
 
 		// Update scale, tolerating zero or NaN from tween.cur()
 		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
 		} while (
 			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
 		);
 	}
 
 	if ( valueParts ) {
 		initialInUnit = +initialInUnit || +initial || 0;
 
 		// Apply relative offset (+=/-=) if specified
 		adjusted = valueParts[ 1 ] ?
 			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
 			+valueParts[ 2 ];
 		if ( tween ) {
 			tween.unit = unit;
 			tween.start = initialInUnit;
 			tween.end = adjusted;
 		}
 	}
 	return adjusted;
 }
 
 
 // Multifunctional method to get and set values of a collection
 // The value/s can optionally be executed if it's a function
 var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
 	var i = 0,
 		length = elems.length,
 		bulk = key == null;
 
 	// Sets many values
 	if ( jQuery.type( key ) === "object" ) {
 		chainable = true;
 		for ( i in key ) {
 			access( elems, fn, i, key[ i ], true, emptyGet, raw );
 		}
 
 	// Sets one value
 	} else if ( value !== undefined ) {
 		chainable = true;
 
 		if ( !jQuery.isFunction( value ) ) {
 			raw = true;
 		}
 
 		if ( bulk ) {
 
 			// Bulk operations run against the entire set
 			if ( raw ) {
 				fn.call( elems, value );
 				fn = null;
 
 			// ...except when executing function values
 			} else {
 				bulk = fn;
 				fn = function( elem, key, value ) {
 					return bulk.call( jQuery( elem ), value );
 				};
 			}
 		}
 
 		if ( fn ) {
 			for ( ; i < length; i++ ) {
 				fn(
 					elems[ i ],
 					key,
 					raw ? value : value.call( elems[ i ], i, fn( elems[ i ], key ) )
 				);
 			}
 		}
 	}
 
 	return chainable ?
 		elems :
 
 		// Gets
 		bulk ?
 			fn.call( elems ) :
 			length ? fn( elems[ 0 ], key ) : emptyGet;
 };
 var rcheckableType = ( /^(?:checkbox|radio)$/i );
 
 var rtagName = ( /<([\w:-]+)/ );
 
 var rscriptType = ( /^$|\/(?:java|ecma)script/i );
 
 var rleadingWhitespace = ( /^\s+/ );
 
 var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|" +
 		"details|dialog|figcaption|figure|footer|header|hgroup|main|" +
 		"mark|meter|nav|output|picture|progress|section|summary|template|time|video";
 
 
 
 function createSafeFragment( document ) {
 	var list = nodeNames.split( "|" ),
 		safeFrag = document.createDocumentFragment();
 
 	if ( safeFrag.createElement ) {
 		while ( list.length ) {
 			safeFrag.createElement(
 				list.pop()
 			);
 		}
 	}
 	return safeFrag;
 }
 
 
 ( function() {
 	var div = document.createElement( "div" ),
 		fragment = document.createDocumentFragment(),
 		input = document.createElement( "input" );
 
 	// Setup
 	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
 
 	// IE strips leading whitespace when .innerHTML is used
 	support.leadingWhitespace = div.firstChild.nodeType === 3;
 
 	// Make sure that tbody elements aren't automatically inserted
 	// IE will insert them into empty tables
 	support.tbody = !div.getElementsByTagName( "tbody" ).length;
 
 	// Make sure that link elements get serialized correctly by innerHTML
 	// This requires a wrapper element in IE
 	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;
 
 	// Makes sure cloning an html5 element does not cause problems
 	// Where outerHTML is undefined, this still works
 	support.html5Clone =
 		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";
 
 	// Check if a disconnected checkbox will retain its checked
 	// value of true after appended to the DOM (IE6/7)
 	input.type = "checkbox";
 	input.checked = true;
 	fragment.appendChild( input );
 	support.appendChecked = input.checked;
 
 	// Make sure textarea (and checkbox) defaultValue is properly cloned
 	// Support: IE6-IE11+
 	div.innerHTML = "<textarea>x</textarea>";
 	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
 
 	// #11217 - WebKit loses check when the name is after the checked attribute
 	fragment.appendChild( div );
 
 	// Support: Windows Web Apps (WWA)
 	// `name` and `type` must use .setAttribute for WWA (#14901)
 	input = document.createElement( "input" );
 	input.setAttribute( "type", "radio" );
 	input.setAttribute( "checked", "checked" );
 	input.setAttribute( "name", "t" );
 
 	div.appendChild( input );
 
 	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
 	// old WebKit doesn't clone checked state correctly in fragments
 	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
 
 	// Support: IE<9
 	// Cloned elements keep attachEvent handlers, we use addEventListener on IE9+
 	support.noCloneEvent = !!div.addEventListener;
 
 	// Support: IE<9
 	// Since attributes and properties are the same in IE,
 	// cleanData must set properties to undefined rather than use removeAttribute
 	div[ jQuery.expando ] = 1;
 	support.attributes = !div.getAttribute( jQuery.expando );
 } )();
 
 
 // We have to close these tags to support XHTML (#13200)
 var wrapMap = {
 	option: [ 1, "<select multiple='multiple'>", "</select>" ],
 	legend: [ 1, "<fieldset>", "</fieldset>" ],
 	area: [ 1, "<map>", "</map>" ],
 
 	// Support: IE8
 	param: [ 1, "<object>", "</object>" ],
 	thead: [ 1, "<table>", "</table>" ],
 	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
 	col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
 	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
 
 	// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
 	// unless wrapped in a div with non-breaking characters in front of it.
 	_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
 };
 
 // Support: IE8-IE9
 wrapMap.optgroup = wrapMap.option;
 
 wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
 wrapMap.th = wrapMap.td;
 
 
 function getAll( context, tag ) {
 	var elems, elem,
 		i = 0,
 		found = typeof context.getElementsByTagName !== "undefined" ?
 			context.getElementsByTagName( tag || "*" ) :
 			typeof context.querySelectorAll !== "undefined" ?
 				context.querySelectorAll( tag || "*" ) :
 				undefined;
 
 	if ( !found ) {
 		for ( found = [], elems = context.childNodes || context;
 			( elem = elems[ i ] ) != null;
 			i++
 		) {
 			if ( !tag || jQuery.nodeName( elem, tag ) ) {
 				found.push( elem );
 			} else {
 				jQuery.merge( found, getAll( elem, tag ) );
 			}
 		}
 	}
 
 	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
 		jQuery.merge( [ context ], found ) :
 		found;
 }
 
 
 // Mark scripts as having already been evaluated
 function setGlobalEval( elems, refElements ) {
 	var elem,
 		i = 0;
 	for ( ; ( elem = elems[ i ] ) != null; i++ ) {
 		jQuery._data(
 			elem,
 			"globalEval",
 			!refElements || jQuery._data( refElements[ i ], "globalEval" )
 		);
 	}
 }
 
 
 var rhtml = /<|&#?\w+;/,
 	rtbody = /<tbody/i;
 
 function fixDefaultChecked( elem ) {
 	if ( rcheckableType.test( elem.type ) ) {
 		elem.defaultChecked = elem.checked;
 	}
 }
 
 function buildFragment( elems, context, scripts, selection, ignored ) {
 	var j, elem, contains,
 		tmp, tag, tbody, wrap,
 		l = elems.length,
 
 		// Ensure a safe fragment
 		safe = createSafeFragment( context ),
 
 		nodes = [],
 		i = 0;
 
 	for ( ; i < l; i++ ) {
 		elem = elems[ i ];
 
 		if ( elem || elem === 0 ) {
 
 			// Add nodes directly
 			if ( jQuery.type( elem ) === "object" ) {
 				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
 
 			// Convert non-html into a text node
 			} else if ( !rhtml.test( elem ) ) {
 				nodes.push( context.createTextNode( elem ) );
 
 			// Convert html into DOM nodes
 			} else {
 				tmp = tmp || safe.appendChild( context.createElement( "div" ) );
 
 				// Deserialize a standard representation
 				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
 				wrap = wrapMap[ tag ] || wrapMap._default;
 
 				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
 
 				// Descend through wrappers to the right content
 				j = wrap[ 0 ];
 				while ( j-- ) {
 					tmp = tmp.lastChild;
 				}
 
 				// Manually add leading whitespace removed by IE
 				if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
 					nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[ 0 ] ) );
 				}
 
 				// Remove IE's autoinserted <tbody> from table fragments
 				if ( !support.tbody ) {
 
 					// String was a <table>, *may* have spurious <tbody>
 					elem = tag === "table" && !rtbody.test( elem ) ?
 						tmp.firstChild :
 
 						// String was a bare <thead> or <tfoot>
 						wrap[ 1 ] === "<table>" && !rtbody.test( elem ) ?
 							tmp :
 							0;
 
 					j = elem && elem.childNodes.length;
 					while ( j-- ) {
 						if ( jQuery.nodeName( ( tbody = elem.childNodes[ j ] ), "tbody" ) &&
 							!tbody.childNodes.length ) {
 
 							elem.removeChild( tbody );
 						}
 					}
 				}
 
 				jQuery.merge( nodes, tmp.childNodes );
 
 				// Fix #12392 for WebKit and IE > 9
 				tmp.textContent = "";
 
 				// Fix #12392 for oldIE
 				while ( tmp.firstChild ) {
 					tmp.removeChild( tmp.firstChild );
 				}
 
 				// Remember the top-level container for proper cleanup
 				tmp = safe.lastChild;
 			}
 		}
 	}
 
 	// Fix #11356: Clear elements from fragment
 	if ( tmp ) {
 		safe.removeChild( tmp );
 	}
 
 	// Reset defaultChecked for any radios and checkboxes
 	// about to be appended to the DOM in IE 6/7 (#8060)
 	if ( !support.appendChecked ) {
 		jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
 	}
 
 	i = 0;
 	while ( ( elem = nodes[ i++ ] ) ) {
 
 		// Skip elements already in the context collection (trac-4087)
 		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
 			if ( ignored ) {
 				ignored.push( elem );
 			}
 
 			continue;
 		}
 
 		contains = jQuery.contains( elem.ownerDocument, elem );
 
 		// Append to fragment
 		tmp = getAll( safe.appendChild( elem ), "script" );
 
 		// Preserve script evaluation history
 		if ( contains ) {
 			setGlobalEval( tmp );
 		}
 
 		// Capture executables
 		if ( scripts ) {
 			j = 0;
 			while ( ( elem = tmp[ j++ ] ) ) {
 				if ( rscriptType.test( elem.type || "" ) ) {
 					scripts.push( elem );
 				}
 			}
 		}
 	}
 
 	tmp = null;
 
 	return safe;
 }
 
 
 ( function() {
 	var i, eventName,
 		div = document.createElement( "div" );
 
 	// Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)
 	for ( i in { submit: true, change: true, focusin: true } ) {
 		eventName = "on" + i;
 
 		if ( !( support[ i ] = eventName in window ) ) {
 
 			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
 			div.setAttribute( eventName, "t" );
 			support[ i ] = div.attributes[ eventName ].expando === false;
 		}
 	}
 
 	// Null elements to avoid leaks in IE.
 	div = null;
 } )();
 
 
 var rformElems = /^(?:input|select|textarea)$/i,
 	rkeyEvent = /^key/,
 	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
 	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
 	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
 
 function returnTrue() {
 	return true;
 }
 
 function returnFalse() {
 	return false;
 }
 
 // Support: IE9
 // See #13393 for more info
 function safeActiveElement() {
 	try {
 		return document.activeElement;
 	} catch ( err ) { }
 }
 
 function on( elem, types, selector, data, fn, one ) {
 	var origFn, type;
 
 	// Types can be a map of types/handlers
 	if ( typeof types === "object" ) {
 
 		// ( types-Object, selector, data )
 		if ( typeof selector !== "string" ) {
 
 			// ( types-Object, data )
 			data = data || selector;
 			selector = undefined;
 		}
 		for ( type in types ) {
 			on( elem, type, selector, data, types[ type ], one );
 		}
 		return elem;
 	}
 
 	if ( data == null && fn == null ) {
 
 		// ( types, fn )
 		fn = selector;
 		data = selector = undefined;
 	} else if ( fn == null ) {
 		if ( typeof selector === "string" ) {
 
 			// ( types, selector, fn )
 			fn = data;
 			data = undefined;
 		} else {
 
 			// ( types, data, fn )
 			fn = data;
 			data = selector;
 			selector = undefined;
 		}
 	}
 	if ( fn === false ) {
 		fn = returnFalse;
 	} else if ( !fn ) {
 		return elem;
 	}
 
 	if ( one === 1 ) {
 		origFn = fn;
 		fn = function( event ) {
 
 			// Can use an empty set, since event contains the info
 			jQuery().off( event );
 			return origFn.apply( this, arguments );
 		};
 
 		// Use same guid so caller can remove using origFn
 		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
 	}
 	return elem.each( function() {
 		jQuery.event.add( this, types, fn, data, selector );
 	} );
 }
 
 /*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
 jQuery.event = {
 
 	global: {},
 
 	add: function( elem, types, handler, data, selector ) {
 		var tmp, events, t, handleObjIn,
 			special, eventHandle, handleObj,
 			handlers, type, namespaces, origType,
 			elemData = jQuery._data( elem );
 
 		// Don't attach events to noData or text/comment nodes (but allow plain objects)
 		if ( !elemData ) {
 			return;
 		}
 
 		// Caller can pass in an object of custom data in lieu of the handler
 		if ( handler.handler ) {
 			handleObjIn = handler;
 			handler = handleObjIn.handler;
 			selector = handleObjIn.selector;
 		}
 
 		// Make sure that the handler has a unique ID, used to find/remove it later
 		if ( !handler.guid ) {
 			handler.guid = jQuery.guid++;
 		}
 
 		// Init the element's event structure and main handler, if this is the first
 		if ( !( events = elemData.events ) ) {
 			events = elemData.events = {};
 		}
 		if ( !( eventHandle = elemData.handle ) ) {
 			eventHandle = elemData.handle = function( e ) {
 
 				// Discard the second event of a jQuery.event.trigger() and
 				// when an event is called after a page has unloaded
 				return typeof jQuery !== "undefined" &&
 					( !e || jQuery.event.triggered !== e.type ) ?
 					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
 					undefined;
 			};
 
 			// Add elem as a property of the handle fn to prevent a memory leak
 			// with IE non-native events
 			eventHandle.elem = elem;
 		}
 
 		// Handle multiple events separated by a space
 		types = ( types || "" ).match( rnotwhite ) || [ "" ];
 		t = types.length;
 		while ( t-- ) {
 			tmp = rtypenamespace.exec( types[ t ] ) || [];
 			type = origType = tmp[ 1 ];
 			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
 
 			// There *must* be a type, no attaching namespace-only handlers
 			if ( !type ) {
 				continue;
 			}
 
 			// If event changes its type, use the special event handlers for the changed type
 			special = jQuery.event.special[ type ] || {};
 
 			// If selector defined, determine special event api type, otherwise given type
 			type = ( selector ? special.delegateType : special.bindType ) || type;
 
 			// Update special based on newly reset type
 			special = jQuery.event.special[ type ] || {};
 
 			// handleObj is passed to all event handlers
 			handleObj = jQuery.extend( {
 				type: type,
 				origType: origType,
 				data: data,
 				handler: handler,
 				guid: handler.guid,
 				selector: selector,
 				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
 				namespace: namespaces.join( "." )
 			}, handleObjIn );
 
 			// Init the event handler queue if we're the first
 			if ( !( handlers = events[ type ] ) ) {
 				handlers = events[ type ] = [];
 				handlers.delegateCount = 0;
 
 				// Only use addEventListener/attachEvent if the special events handler returns false
 				if ( !special.setup ||
 					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
 
 					// Bind the global event handler to the element
 					if ( elem.addEventListener ) {
 						elem.addEventListener( type, eventHandle, false );
 
 					} else if ( elem.attachEvent ) {
 						elem.attachEvent( "on" + type, eventHandle );
 					}
 				}
 			}
 
 			if ( special.add ) {
 				special.add.call( elem, handleObj );
 
 				if ( !handleObj.handler.guid ) {
 					handleObj.handler.guid = handler.guid;
 				}
 			}
 
 			// Add to the element's handler list, delegates in front
 			if ( selector ) {
 				handlers.splice( handlers.delegateCount++, 0, handleObj );
 			} else {
 				handlers.push( handleObj );
 			}
 
 			// Keep track of which events have ever been used, for event optimization
 			jQuery.event.global[ type ] = true;
 		}
 
 		// Nullify elem to prevent memory leaks in IE
 		elem = null;
 	},
 
 	// Detach an event or set of events from an element
 	remove: function( elem, types, handler, selector, mappedTypes ) {
 		var j, handleObj, tmp,
 			origCount, t, events,
 			special, handlers, type,
 			namespaces, origType,
 			elemData = jQuery.hasData( elem ) && jQuery._data( elem );
 
 		if ( !elemData || !( events = elemData.events ) ) {
 			return;
 		}
 
 		// Once for each type.namespace in types; type may be omitted
 		types = ( types || "" ).match( rnotwhite ) || [ "" ];
 		t = types.length;
 		while ( t-- ) {
 			tmp = rtypenamespace.exec( types[ t ] ) || [];
 			type = origType = tmp[ 1 ];
 			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
 
 			// Unbind all events (on this namespace, if provided) for the element
 			if ( !type ) {
 				for ( type in events ) {
 					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
 				}
 				continue;
 			}
 
 			special = jQuery.event.special[ type ] || {};
 			type = ( selector ? special.delegateType : special.bindType ) || type;
 			handlers = events[ type ] || [];
 			tmp = tmp[ 2 ] &&
 				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
 
 			// Remove matching events
 			origCount = j = handlers.length;
 			while ( j-- ) {
 				handleObj = handlers[ j ];
 
 				if ( ( mappedTypes || origType === handleObj.origType ) &&
 					( !handler || handler.guid === handleObj.guid ) &&
 					( !tmp || tmp.test( handleObj.namespace ) ) &&
 					( !selector || selector === handleObj.selector ||
 						selector === "**" && handleObj.selector ) ) {
 					handlers.splice( j, 1 );
 
 					if ( handleObj.selector ) {
 						handlers.delegateCount--;
 					}
 					if ( special.remove ) {
 						special.remove.call( elem, handleObj );
 					}
 				}
 			}
 
 			// Remove generic event handler if we removed something and no more handlers exist
 			// (avoids potential for endless recursion during removal of special event handlers)
 			if ( origCount && !handlers.length ) {
 				if ( !special.teardown ||
 					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
 
 					jQuery.removeEvent( elem, type, elemData.handle );
 				}
 
 				delete events[ type ];
 			}
 		}
 
 		// Remove the expando if it's no longer used
 		if ( jQuery.isEmptyObject( events ) ) {
 			delete elemData.handle;
 
 			// removeData also checks for emptiness and clears the expando if empty
 			// so use it instead of delete
 			jQuery._removeData( elem, "events" );
 		}
 	},
 
 	trigger: function( event, data, elem, onlyHandlers ) {
 		var handle, ontype, cur,
 			bubbleType, special, tmp, i,
 			eventPath = [ elem || document ],
 			type = hasOwn.call( event, "type" ) ? event.type : event,
 			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
 
 		cur = tmp = elem = elem || document;
 
 		// Don't do events on text and comment nodes
 		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
 			return;
 		}
 
 		// focus/blur morphs to focusin/out; ensure we're not firing them right now
 		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
 			return;
 		}
 
 		if ( type.indexOf( "." ) > -1 ) {
 
 			// Namespaced trigger; create a regexp to match event type in handle()
 			namespaces = type.split( "." );
 			type = namespaces.shift();
 			namespaces.sort();
 		}
 		ontype = type.indexOf( ":" ) < 0 && "on" + type;
 
 		// Caller can pass in a jQuery.Event object, Object, or just an event type string
 		event = event[ jQuery.expando ] ?
 			event :
 			new jQuery.Event( type, typeof event === "object" && event );
 
 		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
 		event.isTrigger = onlyHandlers ? 2 : 3;
 		event.namespace = namespaces.join( "." );
 		event.rnamespace = event.namespace ?
 			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
 			null;
 
 		// Clean up the event in case it is being reused
 		event.result = undefined;
 		if ( !event.target ) {
 			event.target = elem;
 		}
 
 		// Clone any incoming data and prepend the event, creating the handler arg list
 		data = data == null ?
 			[ event ] :
 			jQuery.makeArray( data, [ event ] );
 
 		// Allow special events to draw outside the lines
 		special = jQuery.event.special[ type ] || {};
 		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
 			return;
 		}
 
 		// Determine event propagation path in advance, per W3C events spec (#9951)
 		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
 		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
 
 			bubbleType = special.delegateType || type;
 			if ( !rfocusMorph.test( bubbleType + type ) ) {
 				cur = cur.parentNode;
 			}
 			for ( ; cur; cur = cur.parentNode ) {
 				eventPath.push( cur );
 				tmp = cur;
 			}
 
 			// Only add window if we got to document (e.g., not plain obj or detached DOM)
 			if ( tmp === ( elem.ownerDocument || document ) ) {
 				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
 			}
 		}
 
 		// Fire handlers on the event path
 		i = 0;
 		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
 
 			event.type = i > 1 ?
 				bubbleType :
 				special.bindType || type;
 
 			// jQuery handler
 			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] &&
 				jQuery._data( cur, "handle" );
 
 			if ( handle ) {
 				handle.apply( cur, data );
 			}
 
 			// Native handler
 			handle = ontype && cur[ ontype ];
 			if ( handle && handle.apply && acceptData( cur ) ) {
 				event.result = handle.apply( cur, data );
 				if ( event.result === false ) {
 					event.preventDefault();
 				}
 			}
 		}
 		event.type = type;
 
 		// If nobody prevented the default action, do it now
 		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
 
 			if (
 				( !special._default ||
 				 special._default.apply( eventPath.pop(), data ) === false
 				) && acceptData( elem )
 			) {
 
 				// Call a native DOM method on the target with the same name name as the event.
 				// Can't use an .isFunction() check here because IE6/7 fails that test.
 				// Don't do default actions on window, that's where global variables be (#6170)
 				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {
 
 					// Don't re-trigger an onFOO event when we call its FOO() method
 					tmp = elem[ ontype ];
 
 					if ( tmp ) {
 						elem[ ontype ] = null;
 					}
 
 					// Prevent re-triggering of the same event, since we already bubbled it above
 					jQuery.event.triggered = type;
 					try {
 						elem[ type ]();
 					} catch ( e ) {
 
 						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
 						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
 					}
 					jQuery.event.triggered = undefined;
 
 					if ( tmp ) {
 						elem[ ontype ] = tmp;
 					}
 				}
 			}
 		}
 
 		return event.result;
 	},
 
 	dispatch: function( event ) {
 
 		// Make a writable jQuery.Event from the native event object
 		event = jQuery.event.fix( event );
 
 		var i, j, ret, matched, handleObj,
 			handlerQueue = [],
 			args = slice.call( arguments ),
 			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
 			special = jQuery.event.special[ event.type ] || {};
 
 		// Use the fix-ed jQuery.Event rather than the (read-only) native event
 		args[ 0 ] = event;
 		event.delegateTarget = this;
 
 		// Call the preDispatch hook for the mapped type, and let it bail if desired
 		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
 			return;
 		}
 
 		// Determine handlers
 		handlerQueue = jQuery.event.handlers.call( this, event, handlers );
 
 		// Run delegates first; they may want to stop propagation beneath us
 		i = 0;
 		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
 			event.currentTarget = matched.elem;
 
 			j = 0;
 			while ( ( handleObj = matched.handlers[ j++ ] ) &&
 				!event.isImmediatePropagationStopped() ) {
 
 				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
 				// a subset or equal to those in the bound event (both can have no namespace).
 				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
 
 					event.handleObj = handleObj;
 					event.data = handleObj.data;
 
 					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
 						handleObj.handler ).apply( matched.elem, args );
 
 					if ( ret !== undefined ) {
 						if ( ( event.result = ret ) === false ) {
 							event.preventDefault();
 							event.stopPropagation();
 						}
 					}
 				}
 			}
 		}
 
 		// Call the postDispatch hook for the mapped type
 		if ( special.postDispatch ) {
 			special.postDispatch.call( this, event );
 		}
 
 		return event.result;
 	},
 
 	handlers: function( event, handlers ) {
 		var i, matches, sel, handleObj,
 			handlerQueue = [],
 			delegateCount = handlers.delegateCount,
 			cur = event.target;
 
 		// Support (at least): Chrome, IE9
 		// Find delegate handlers
 		// Black-hole SVG <use> instance trees (#13180)
 		//
 		// Support: Firefox<=42+
 		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
 		if ( delegateCount && cur.nodeType &&
 			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
 
 			/* jshint eqeqeq: false */
 			for ( ; cur != this; cur = cur.parentNode || this ) {
 				/* jshint eqeqeq: true */
 
 				// Don't check non-elements (#13208)
 				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
 				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
 					matches = [];
 					for ( i = 0; i < delegateCount; i++ ) {
 						handleObj = handlers[ i ];
 
 						// Don't conflict with Object.prototype properties (#13203)
 						sel = handleObj.selector + " ";
 
 						if ( matches[ sel ] === undefined ) {
 							matches[ sel ] = handleObj.needsContext ?
 								jQuery( sel, this ).index( cur ) > -1 :
 								jQuery.find( sel, this, null, [ cur ] ).length;
 						}
 						if ( matches[ sel ] ) {
 							matches.push( handleObj );
 						}
 					}
 					if ( matches.length ) {
 						handlerQueue.push( { elem: cur, handlers: matches } );
 					}
 				}
 			}
 		}
 
 		// Add the remaining (directly-bound) handlers
 		if ( delegateCount < handlers.length ) {
 			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
 		}
 
 		return handlerQueue;
 	},
 
 	fix: function( event ) {
 		if ( event[ jQuery.expando ] ) {
 			return event;
 		}
 
 		// Create a writable copy of the event object and normalize some properties
 		var i, prop, copy,
 			type = event.type,
 			originalEvent = event,
 			fixHook = this.fixHooks[ type ];
 
 		if ( !fixHook ) {
 			this.fixHooks[ type ] = fixHook =
 				rmouseEvent.test( type ) ? this.mouseHooks :
 				rkeyEvent.test( type ) ? this.keyHooks :
 				{};
 		}
 		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
 
 		event = new jQuery.Event( originalEvent );
 
 		i = copy.length;
 		while ( i-- ) {
 			prop = copy[ i ];
 			event[ prop ] = originalEvent[ prop ];
 		}
 
 		// Support: IE<9
 		// Fix target property (#1925)
 		if ( !event.target ) {
 			event.target = originalEvent.srcElement || document;
 		}
 
 		// Support: Safari 6-8+
 		// Target should not be a text node (#504, #13143)
 		if ( event.target.nodeType === 3 ) {
 			event.target = event.target.parentNode;
 		}
 
 		// Support: IE<9
 		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
 		event.metaKey = !!event.metaKey;
 
 		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
 	},
 
 	// Includes some event props shared by KeyEvent and MouseEvent
 	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
 		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),
 
 	fixHooks: {},
 
 	keyHooks: {
 		props: "char charCode key keyCode".split( " " ),
 		filter: function( event, original ) {
 
 			// Add which for key events
 			if ( event.which == null ) {
 				event.which = original.charCode != null ? original.charCode : original.keyCode;
 			}
 
 			return event;
 		}
 	},
 
 	mouseHooks: {
 		props: ( "button buttons clientX clientY fromElement offsetX offsetY " +
 			"pageX pageY screenX screenY toElement" ).split( " " ),
 		filter: function( event, original ) {
 			var body, eventDoc, doc,
 				button = original.button,
 				fromElement = original.fromElement;
 
 			// Calculate pageX/Y if missing and clientX/Y available
 			if ( event.pageX == null && original.clientX != null ) {
 				eventDoc = event.target.ownerDocument || document;
 				doc = eventDoc.documentElement;
 				body = eventDoc.body;
 
 				event.pageX = original.clientX +
 					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
 					( doc && doc.clientLeft || body && body.clientLeft || 0 );
 				event.pageY = original.clientY +
 					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
 					( doc && doc.clientTop  || body && body.clientTop  || 0 );
 			}
 
 			// Add relatedTarget, if necessary
 			if ( !event.relatedTarget && fromElement ) {
 				event.relatedTarget = fromElement === event.target ?
 					original.toElement :
 					fromElement;
 			}
 
 			// Add which for click: 1 === left; 2 === middle; 3 === right
 			// Note: button is not normalized, so don't use it
 			if ( !event.which && button !== undefined ) {
 				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
 			}
 
 			return event;
 		}
 	},
 
 	special: {
 		load: {
 
 			// Prevent triggered image.load events from bubbling to window.load
 			noBubble: true
 		},
 		focus: {
 
 			// Fire native event if possible so blur/focus sequence is correct
 			trigger: function() {
 				if ( this !== safeActiveElement() && this.focus ) {
 					try {
 						this.focus();
 						return false;
 					} catch ( e ) {
 
 						// Support: IE<9
 						// If we error on focus to hidden element (#1486, #12518),
 						// let .trigger() run the handlers
 					}
 				}
 			},
 			delegateType: "focusin"
 		},
 		blur: {
 			trigger: function() {
 				if ( this === safeActiveElement() && this.blur ) {
 					this.blur();
 					return false;
 				}
 			},
 			delegateType: "focusout"
 		},
 		click: {
 
 			// For checkbox, fire native event so checked state will be right
 			trigger: function() {
 				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
 					this.click();
 					return false;
 				}
 			},
 
 			// For cross-browser consistency, don't fire native .click() on links
 			_default: function( event ) {
 				return jQuery.nodeName( event.target, "a" );
 			}
 		},
 
 		beforeunload: {
 			postDispatch: function( event ) {
 
 				// Support: Firefox 20+
 				// Firefox doesn't alert if the returnValue field is not set.
 				if ( event.result !== undefined && event.originalEvent ) {
 					event.originalEvent.returnValue = event.result;
 				}
 			}
 		}
 	},
 
 	// Piggyback on a donor event to simulate a different one
 	simulate: function( type, elem, event ) {
 		var e = jQuery.extend(
 			new jQuery.Event(),
 			event,
 			{
 				type: type,
 				isSimulated: true
 
 				// Previously, `originalEvent: {}` was set here, so stopPropagation call
 				// would not be triggered on donor event, since in our own
 				// jQuery.event.stopPropagation function we had a check for existence of
 				// originalEvent.stopPropagation method, so, consequently it would be a noop.
 				//
 				// Guard for simulated events was moved to jQuery.event.stopPropagation function
 				// since `originalEvent` should point to the original event for the
 				// constancy with other events and for more focused logic
 			}
 		);
 
 		jQuery.event.trigger( e, null, elem );
 
 		if ( e.isDefaultPrevented() ) {
 			event.preventDefault();
 		}
 	}
 };
 
 jQuery.removeEvent = document.removeEventListener ?
 	function( elem, type, handle ) {
 
 		// This "if" is needed for plain objects
 		if ( elem.removeEventListener ) {
 			elem.removeEventListener( type, handle );
 		}
 	} :
 	function( elem, type, handle ) {
 		var name = "on" + type;
 
 		if ( elem.detachEvent ) {
 
 			// #8545, #7054, preventing memory leaks for custom events in IE6-8
 			// detachEvent needed property on element, by name of that event,
 			// to properly expose it to GC
 			if ( typeof elem[ name ] === "undefined" ) {
 				elem[ name ] = null;
 			}
 
 			elem.detachEvent( name, handle );
 		}
 	};
 
 jQuery.Event = function( src, props ) {
 
 	// Allow instantiation without the 'new' keyword
 	if ( !( this instanceof jQuery.Event ) ) {
 		return new jQuery.Event( src, props );
 	}
 
 	// Event object
 	if ( src && src.type ) {
 		this.originalEvent = src;
 		this.type = src.type;
 
 		// Events bubbling up the document may have been marked as prevented
 		// by a handler lower down the tree; reflect the correct value.
 		this.isDefaultPrevented = src.defaultPrevented ||
 				src.defaultPrevented === undefined &&
 
 				// Support: IE < 9, Android < 4.0
 				src.returnValue === false ?
 			returnTrue :
 			returnFalse;
 
 	// Event type
 	} else {
 		this.type = src;
 	}
 
 	// Put explicitly provided properties onto the event object
 	if ( props ) {
 		jQuery.extend( this, props );
 	}
 
 	// Create a timestamp if incoming event doesn't have one
 	this.timeStamp = src && src.timeStamp || jQuery.now();
 
 	// Mark it as fixed
 	this[ jQuery.expando ] = true;
 };
 
 // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
 // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
 jQuery.Event.prototype = {
 	constructor: jQuery.Event,
 	isDefaultPrevented: returnFalse,
 	isPropagationStopped: returnFalse,
 	isImmediatePropagationStopped: returnFalse,
 
 	preventDefault: function() {
 		var e = this.originalEvent;
 
 		this.isDefaultPrevented = returnTrue;
 		if ( !e ) {
 			return;
 		}
 
 		// If preventDefault exists, run it on the original event
 		if ( e.preventDefault ) {
 			e.preventDefault();
 
 		// Support: IE
 		// Otherwise set the returnValue property of the original event to false
 		} else {
 			e.returnValue = false;
 		}
 	},
 	stopPropagation: function() {
 		var e = this.originalEvent;
 
 		this.isPropagationStopped = returnTrue;
 
 		if ( !e || this.isSimulated ) {
 			return;
 		}
 
 		// If stopPropagation exists, run it on the original event
 		if ( e.stopPropagation ) {
 			e.stopPropagation();
 		}
 
 		// Support: IE
 		// Set the cancelBubble property of the original event to true
 		e.cancelBubble = true;
 	},
 	stopImmediatePropagation: function() {
 		var e = this.originalEvent;
 
 		this.isImmediatePropagationStopped = returnTrue;
 
 		if ( e && e.stopImmediatePropagation ) {
 			e.stopImmediatePropagation();
 		}
 
 		this.stopPropagation();
 	}
 };
 
 // Create mouseenter/leave events using mouseover/out and event-time checks
 // so that event delegation works in jQuery.
 // Do the same for pointerenter/pointerleave and pointerover/pointerout
 //
 // Support: Safari 7 only
 // Safari sends mouseenter too often; see:
 // https://code.google.com/p/chromium/issues/detail?id=470258
 // for the description of the bug (it existed in older Chrome versions as well).
 jQuery.each( {
 	mouseenter: "mouseover",
 	mouseleave: "mouseout",
 	pointerenter: "pointerover",
 	pointerleave: "pointerout"
 }, function( orig, fix ) {
 	jQuery.event.special[ orig ] = {
 		delegateType: fix,
 		bindType: fix,
 
 		handle: function( event ) {
 			var ret,
 				target = this,
 				related = event.relatedTarget,
 				handleObj = event.handleObj;
 
 			// For mouseenter/leave call the handler if related is outside the target.
 			// NB: No relatedTarget if the mouse left/entered the browser window
 			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
 				event.type = handleObj.origType;
 				ret = handleObj.handler.apply( this, arguments );
 				event.type = fix;
 			}
 			return ret;
 		}
 	};
 } );
 
 // IE submit delegation
 if ( !support.submit ) {
 
 	jQuery.event.special.submit = {
 		setup: function() {
 
 			// Only need this for delegated form submit events
 			if ( jQuery.nodeName( this, "form" ) ) {
 				return false;
 			}
 
 			// Lazy-add a submit handler when a descendant form may potentially be submitted
 			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
 
 				// Node name check avoids a VML-related crash in IE (#9807)
 				var elem = e.target,
 					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ?
 
 						// Support: IE <=8
 						// We use jQuery.prop instead of elem.form
 						// to allow fixing the IE8 delegated submit issue (gh-2332)
 						// by 3rd party polyfills/workarounds.
 						jQuery.prop( elem, "form" ) :
 						undefined;
 
 				if ( form && !jQuery._data( form, "submit" ) ) {
 					jQuery.event.add( form, "submit._submit", function( event ) {
 						event._submitBubble = true;
 					} );
 					jQuery._data( form, "submit", true );
 				}
 			} );
 
 			// return undefined since we don't need an event listener
 		},
 
 		postDispatch: function( event ) {
 
 			// If form was submitted by the user, bubble the event up the tree
 			if ( event._submitBubble ) {
 				delete event._submitBubble;
 				if ( this.parentNode && !event.isTrigger ) {
 					jQuery.event.simulate( "submit", this.parentNode, event );
 				}
 			}
 		},
 
 		teardown: function() {
 
 			// Only need this for delegated form submit events
 			if ( jQuery.nodeName( this, "form" ) ) {
 				return false;
 			}
 
 			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
 			jQuery.event.remove( this, "._submit" );
 		}
 	};
 }
 
 // IE change delegation and checkbox/radio fix
 if ( !support.change ) {
 
 	jQuery.event.special.change = {
 
 		setup: function() {
 
 			if ( rformElems.test( this.nodeName ) ) {
 
 				// IE doesn't fire change on a check/radio until blur; trigger it on click
 				// after a propertychange. Eat the blur-change in special.change.handle.
 				// This still fires onchange a second time for check/radio after blur.
 				if ( this.type === "checkbox" || this.type === "radio" ) {
 					jQuery.event.add( this, "propertychange._change", function( event ) {
 						if ( event.originalEvent.propertyName === "checked" ) {
 							this._justChanged = true;
 						}
 					} );
 					jQuery.event.add( this, "click._change", function( event ) {
 						if ( this._justChanged && !event.isTrigger ) {
 							this._justChanged = false;
 						}
 
 						// Allow triggered, simulated change events (#11500)
 						jQuery.event.simulate( "change", this, event );
 					} );
 				}
 				return false;
 			}
 
 			// Delegated event; lazy-add a change handler on descendant inputs
 			jQuery.event.add( this, "beforeactivate._change", function( e ) {
 				var elem = e.target;
 
 				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "change" ) ) {
 					jQuery.event.add( elem, "change._change", function( event ) {
 						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
 							jQuery.event.simulate( "change", this.parentNode, event );
 						}
 					} );
 					jQuery._data( elem, "change", true );
 				}
 			} );
 		},
 
 		handle: function( event ) {
 			var elem = event.target;
 
 			// Swallow native change events from checkbox/radio, we already triggered them above
 			if ( this !== elem || event.isSimulated || event.isTrigger ||
 				( elem.type !== "radio" && elem.type !== "checkbox" ) ) {
 
 				return event.handleObj.handler.apply( this, arguments );
 			}
 		},
 
 		teardown: function() {
 			jQuery.event.remove( this, "._change" );
 
 			return !rformElems.test( this.nodeName );
 		}
 	};
 }
 
 // Support: Firefox
 // Firefox doesn't have focus(in | out) events
 // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
 //
 // Support: Chrome, Safari
 // focus(in | out) events fire after focus & blur events,
 // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
 // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
 if ( !support.focusin ) {
 	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
 
 		// Attach a single capturing handler on the document while someone wants focusin/focusout
 		var handler = function( event ) {
 			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
 		};
 
 		jQuery.event.special[ fix ] = {
 			setup: function() {
 				var doc = this.ownerDocument || this,
 					attaches = jQuery._data( doc, fix );
 
 				if ( !attaches ) {
 					doc.addEventListener( orig, handler, true );
 				}
 				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
 			},
 			teardown: function() {
 				var doc = this.ownerDocument || this,
 					attaches = jQuery._data( doc, fix ) - 1;
 
 				if ( !attaches ) {
 					doc.removeEventListener( orig, handler, true );
 					jQuery._removeData( doc, fix );
 				} else {
 					jQuery._data( doc, fix, attaches );
 				}
 			}
 		};
 	} );
 }
 
 jQuery.fn.extend( {
 
 	on: function( types, selector, data, fn ) {
 		return on( this, types, selector, data, fn );
 	},
 	one: function( types, selector, data, fn ) {
 		return on( this, types, selector, data, fn, 1 );
 	},
 	off: function( types, selector, fn ) {
 		var handleObj, type;
 		if ( types && types.preventDefault && types.handleObj ) {
 
 			// ( event )  dispatched jQuery.Event
 			handleObj = types.handleObj;
 			jQuery( types.delegateTarget ).off(
 				handleObj.namespace ?
 					handleObj.origType + "." + handleObj.namespace :
 					handleObj.origType,
 				handleObj.selector,
 				handleObj.handler
 			);
 			return this;
 		}
 		if ( typeof types === "object" ) {
 
 			// ( types-object [, selector] )
 			for ( type in types ) {
 				this.off( type, selector, types[ type ] );
 			}
 			return this;
 		}
 		if ( selector === false || typeof selector === "function" ) {
 
 			// ( types [, fn] )
 			fn = selector;
 			selector = undefined;
 		}
 		if ( fn === false ) {
 			fn = returnFalse;
 		}
 		return this.each( function() {
 			jQuery.event.remove( this, types, fn, selector );
 		} );
 	},
 
 	trigger: function( type, data ) {
 		return this.each( function() {
 			jQuery.event.trigger( type, data, this );
 		} );
 	},
 	triggerHandler: function( type, data ) {
 		var elem = this[ 0 ];
 		if ( elem ) {
 			return jQuery.event.trigger( type, data, elem, true );
 		}
 	}
 } );
 
 
 var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
 	rnoshimcache = new RegExp( "<(?:" + nodeNames + ")[\\s/>]", "i" ),
 	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
 
 	// Support: IE 10-11, Edge 10240+
 	// In IE/Edge using regex groups here causes severe slowdowns.
 	// See https://connect.microsoft.com/IE/feedback/details/1736512/
 	rnoInnerhtml = /<script|<style|<link/i,
 
 	// checked="checked" or checked
 	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
 	rscriptTypeMasked = /^true\/(.*)/,
 	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
 	safeFragment = createSafeFragment( document ),
 	fragmentDiv = safeFragment.appendChild( document.createElement( "div" ) );
 
 // Support: IE<8
 // Manipulating tables requires a tbody
 function manipulationTarget( elem, content ) {
 	return jQuery.nodeName( elem, "table" ) &&
 		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
 
 		elem.getElementsByTagName( "tbody" )[ 0 ] ||
 			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
 		elem;
 }
 
 // Replace/restore the type attribute of script elements for safe DOM manipulation
 function disableScript( elem ) {
 	elem.type = ( jQuery.find.attr( elem, "type" ) !== null ) + "/" + elem.type;
 	return elem;
 }
 function restoreScript( elem ) {
 	var match = rscriptTypeMasked.exec( elem.type );
 	if ( match ) {
 		elem.type = match[ 1 ];
 	} else {
 		elem.removeAttribute( "type" );
 	}
 	return elem;
 }
 
 function cloneCopyEvent( src, dest ) {
 	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
 		return;
 	}
 
 	var type, i, l,
 		oldData = jQuery._data( src ),
 		curData = jQuery._data( dest, oldData ),
 		events = oldData.events;
 
 	if ( events ) {
 		delete curData.handle;
 		curData.events = {};
 
 		for ( type in events ) {
 			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
 				jQuery.event.add( dest, type, events[ type ][ i ] );
 			}
 		}
 	}
 
 	// make the cloned public data object a copy from the original
 	if ( curData.data ) {
 		curData.data = jQuery.extend( {}, curData.data );
 	}
 }
 
 function fixCloneNodeIssues( src, dest ) {
 	var nodeName, e, data;
 
 	// We do not need to do anything for non-Elements
 	if ( dest.nodeType !== 1 ) {
 		return;
 	}
 
 	nodeName = dest.nodeName.toLowerCase();
 
 	// IE6-8 copies events bound via attachEvent when using cloneNode.
 	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
 		data = jQuery._data( dest );
 
 		for ( e in data.events ) {
 			jQuery.removeEvent( dest, e, data.handle );
 		}
 
 		// Event data gets referenced instead of copied if the expando gets copied too
 		dest.removeAttribute( jQuery.expando );
 	}
 
 	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
 	if ( nodeName === "script" && dest.text !== src.text ) {
 		disableScript( dest ).text = src.text;
 		restoreScript( dest );
 
 	// IE6-10 improperly clones children of object elements using classid.
 	// IE10 throws NoModificationAllowedError if parent is null, #12132.
 	} else if ( nodeName === "object" ) {
 		if ( dest.parentNode ) {
 			dest.outerHTML = src.outerHTML;
 		}
 
 		// This path appears unavoidable for IE9. When cloning an object
 		// element in IE9, the outerHTML strategy above is not sufficient.
 		// If the src has innerHTML and the destination does not,
 		// copy the src.innerHTML into the dest.innerHTML. #10324
 		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim( dest.innerHTML ) ) ) {
 			dest.innerHTML = src.innerHTML;
 		}
 
 	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
 
 		// IE6-8 fails to persist the checked state of a cloned checkbox
 		// or radio button. Worse, IE6-7 fail to give the cloned element
 		// a checked appearance if the defaultChecked value isn't also set
 
 		dest.defaultChecked = dest.checked = src.checked;
 
 		// IE6-7 get confused and end up setting the value of a cloned
 		// checkbox/radio button to an empty string instead of "on"
 		if ( dest.value !== src.value ) {
 			dest.value = src.value;
 		}
 
 	// IE6-8 fails to return the selected option to the default selected
 	// state when cloning options
 	} else if ( nodeName === "option" ) {
 		dest.defaultSelected = dest.selected = src.defaultSelected;
 
 	// IE6-8 fails to set the defaultValue to the correct value when
 	// cloning other types of input fields
 	} else if ( nodeName === "input" || nodeName === "textarea" ) {
 		dest.defaultValue = src.defaultValue;
 	}
 }
 
 function domManip( collection, args, callback, ignored ) {
 
 	// Flatten any nested arrays
 	args = concat.apply( [], args );
 
 	var first, node, hasScripts,
 		scripts, doc, fragment,
 		i = 0,
 		l = collection.length,
 		iNoClone = l - 1,
 		value = args[ 0 ],
 		isFunction = jQuery.isFunction( value );
 
 	// We can't cloneNode fragments that contain checked, in WebKit
 	if ( isFunction ||
 			( l > 1 && typeof value === "string" &&
 				!support.checkClone && rchecked.test( value ) ) ) {
 		return collection.each( function( index ) {
 			var self = collection.eq( index );
 			if ( isFunction ) {
 				args[ 0 ] = value.call( this, index, self.html() );
 			}
 			domManip( self, args, callback, ignored );
 		} );
 	}
 
 	if ( l ) {
 		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
 		first = fragment.firstChild;
 
 		if ( fragment.childNodes.length === 1 ) {
 			fragment = first;
 		}
 
 		// Require either new content or an interest in ignored elements to invoke the callback
 		if ( first || ignored ) {
 			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
 			hasScripts = scripts.length;
 
 			// Use the original fragment for the last item
 			// instead of the first because it can end up
 			// being emptied incorrectly in certain situations (#8070).
 			for ( ; i < l; i++ ) {
 				node = fragment;
 
 				if ( i !== iNoClone ) {
 					node = jQuery.clone( node, true, true );
 
 					// Keep references to cloned scripts for later restoration
 					if ( hasScripts ) {
 
 						// Support: Android<4.1, PhantomJS<2
 						// push.apply(_, arraylike) throws on ancient WebKit
 						jQuery.merge( scripts, getAll( node, "script" ) );
 					}
 				}
 
 				callback.call( collection[ i ], node, i );
 			}
 
 			if ( hasScripts ) {
 				doc = scripts[ scripts.length - 1 ].ownerDocument;
 
 				// Reenable scripts
 				jQuery.map( scripts, restoreScript );
 
 				// Evaluate executable scripts on first document insertion
 				for ( i = 0; i < hasScripts; i++ ) {
 					node = scripts[ i ];
 					if ( rscriptType.test( node.type || "" ) &&
 						!jQuery._data( node, "globalEval" ) &&
 						jQuery.contains( doc, node ) ) {
 
 						if ( node.src ) {
 
 							// Optional AJAX dependency, but won't run scripts if not present
 							if ( jQuery._evalUrl ) {
 								jQuery._evalUrl( node.src );
 							}
 						} else {
 							jQuery.globalEval(
 								( node.text || node.textContent || node.innerHTML || "" )
 									.replace( rcleanScript, "" )
 							);
 						}
 					}
 				}
 			}
 
 			// Fix #11809: Avoid leaking memory
 			fragment = first = null;
 		}
 	}
 
 	return collection;
 }
 
 function remove( elem, selector, keepData ) {
 	var node,
 		elems = selector ? jQuery.filter( selector, elem ) : elem,
 		i = 0;
 
 	for ( ; ( node = elems[ i ] ) != null; i++ ) {
 
 		if ( !keepData && node.nodeType === 1 ) {
 			jQuery.cleanData( getAll( node ) );
 		}
 
 		if ( node.parentNode ) {
 			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
 				setGlobalEval( getAll( node, "script" ) );
 			}
 			node.parentNode.removeChild( node );
 		}
 	}
 
 	return elem;
 }
 
 jQuery.extend( {
 	htmlPrefilter: function( html ) {
 		return html.replace( rxhtmlTag, "<$1></$2>" );
 	},
 
 	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
 		var destElements, node, clone, i, srcElements,
 			inPage = jQuery.contains( elem.ownerDocument, elem );
 
 		if ( support.html5Clone || jQuery.isXMLDoc( elem ) ||
 			!rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
 
 			clone = elem.cloneNode( true );
 
 		// IE<=8 does not properly clone detached, unknown element nodes
 		} else {
 			fragmentDiv.innerHTML = elem.outerHTML;
 			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
 		}
 
 		if ( ( !support.noCloneEvent || !support.noCloneChecked ) &&
 				( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {
 
 			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
 			destElements = getAll( clone );
 			srcElements = getAll( elem );
 
 			// Fix all IE cloning issues
 			for ( i = 0; ( node = srcElements[ i ] ) != null; ++i ) {
 
 				// Ensure that the destination node is not null; Fixes #9587
 				if ( destElements[ i ] ) {
 					fixCloneNodeIssues( node, destElements[ i ] );
 				}
 			}
 		}
 
 		// Copy the events from the original to the clone
 		if ( dataAndEvents ) {
 			if ( deepDataAndEvents ) {
 				srcElements = srcElements || getAll( elem );
 				destElements = destElements || getAll( clone );
 
 				for ( i = 0; ( node = srcElements[ i ] ) != null; i++ ) {
 					cloneCopyEvent( node, destElements[ i ] );
 				}
 			} else {
 				cloneCopyEvent( elem, clone );
 			}
 		}
 
 		// Preserve script evaluation history
 		destElements = getAll( clone, "script" );
 		if ( destElements.length > 0 ) {
 			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
 		}
 
 		destElements = srcElements = node = null;
 
 		// Return the cloned set
 		return clone;
 	},
 
 	cleanData: function( elems, /* internal */ forceAcceptData ) {
 		var elem, type, id, data,
 			i = 0,
 			internalKey = jQuery.expando,
 			cache = jQuery.cache,
 			attributes = support.attributes,
 			special = jQuery.event.special;
 
 		for ( ; ( elem = elems[ i ] ) != null; i++ ) {
 			if ( forceAcceptData || acceptData( elem ) ) {
 
 				id = elem[ internalKey ];
 				data = id && cache[ id ];
 
 				if ( data ) {
 					if ( data.events ) {
 						for ( type in data.events ) {
 							if ( special[ type ] ) {
 								jQuery.event.remove( elem, type );
 
 							// This is a shortcut to avoid jQuery.event.remove's overhead
 							} else {
 								jQuery.removeEvent( elem, type, data.handle );
 							}
 						}
 					}
 
 					// Remove cache only if it was not already removed by jQuery.event.remove
 					if ( cache[ id ] ) {
 
 						delete cache[ id ];
 
 						// Support: IE<9
 						// IE does not allow us to delete expando properties from nodes
 						// IE creates expando attributes along with the property
 						// IE does not have a removeAttribute function on Document nodes
 						if ( !attributes && typeof elem.removeAttribute !== "undefined" ) {
 							elem.removeAttribute( internalKey );
 
 						// Webkit & Blink performance suffers when deleting properties
 						// from DOM nodes, so set to undefined instead
 						// https://code.google.com/p/chromium/issues/detail?id=378607
 						} else {
 							elem[ internalKey ] = undefined;
 						}
 
 						deletedIds.push( id );
 					}
 				}
 			}
 		}
 	}
 } );
 
 jQuery.fn.extend( {
 
 	// Keep domManip exposed until 3.0 (gh-2225)
 	domManip: domManip,
 
 	detach: function( selector ) {
 		return remove( this, selector, true );
 	},
 
 	remove: function( selector ) {
 		return remove( this, selector );
 	},
 
 	text: function( value ) {
 		return access( this, function( value ) {
 			return value === undefined ?
 				jQuery.text( this ) :
 				this.empty().append(
 					( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value )
 				);
 		}, null, value, arguments.length );
 	},
 
 	append: function() {
 		return domManip( this, arguments, function( elem ) {
 			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
 				var target = manipulationTarget( this, elem );
 				target.appendChild( elem );
 			}
 		} );
 	},
 
 	prepend: function() {
 		return domManip( this, arguments, function( elem ) {
 			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
 				var target = manipulationTarget( this, elem );
 				target.insertBefore( elem, target.firstChild );
 			}
 		} );
 	},
 
 	before: function() {
 		return domManip( this, arguments, function( elem ) {
 			if ( this.parentNode ) {
 				this.parentNode.insertBefore( elem, this );
 			}
 		} );
 	},
 
 	after: function() {
 		return domManip( this, arguments, function( elem ) {
 			if ( this.parentNode ) {
 				this.parentNode.insertBefore( elem, this.nextSibling );
 			}
 		} );
 	},
 
 	empty: function() {
 		var elem,
 			i = 0;
 
 		for ( ; ( elem = this[ i ] ) != null; i++ ) {
 
 			// Remove element nodes and prevent memory leaks
 			if ( elem.nodeType === 1 ) {
 				jQuery.cleanData( getAll( elem, false ) );
 			}
 
 			// Remove any remaining nodes
 			while ( elem.firstChild ) {
 				elem.removeChild( elem.firstChild );
 			}
 
 			// If this is a select, ensure that it displays empty (#12336)
 			// Support: IE<9
 			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
 				elem.options.length = 0;
 			}
 		}
 
 		return this;
 	},
 
 	clone: function( dataAndEvents, deepDataAndEvents ) {
 		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
 		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
 
 		return this.map( function() {
 			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
 		} );
 	},
 
 	html: function( value ) {
 		return access( this, function( value ) {
 			var elem = this[ 0 ] || {},
 				i = 0,
 				l = this.length;
 
 			if ( value === undefined ) {
 				return elem.nodeType === 1 ?
 					elem.innerHTML.replace( rinlinejQuery, "" ) :
 					undefined;
 			}
 
 			// See if we can take a shortcut and just use innerHTML
 			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
 				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
 				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
 				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
 
 				value = jQuery.htmlPrefilter( value );
 
 				try {
 					for ( ; i < l; i++ ) {
 
 						// Remove element nodes and prevent memory leaks
 						elem = this[ i ] || {};
 						if ( elem.nodeType === 1 ) {
 							jQuery.cleanData( getAll( elem, false ) );
 							elem.innerHTML = value;
 						}
 					}
 
 					elem = 0;
 
 				// If using innerHTML throws an exception, use the fallback method
 				} catch ( e ) {}
 			}
 
 			if ( elem ) {
 				this.empty().append( value );
 			}
 		}, null, value, arguments.length );
 	},
 
 	replaceWith: function() {
 		var ignored = [];
 
 		// Make the changes, replacing each non-ignored context element with the new content
 		return domManip( this, arguments, function( elem ) {
 			var parent = this.parentNode;
 
 			if ( jQuery.inArray( this, ignored ) < 0 ) {
 				jQuery.cleanData( getAll( this ) );
 				if ( parent ) {
 					parent.replaceChild( elem, this );
 				}
 			}
 
 		// Force callback invocation
 		}, ignored );
 	}
 } );
 
 jQuery.each( {
 	appendTo: "append",
 	prependTo: "prepend",
 	insertBefore: "before",
 	insertAfter: "after",
 	replaceAll: "replaceWith"
 }, function( name, original ) {
 	jQuery.fn[ name ] = function( selector ) {
 		var elems,
 			i = 0,
 			ret = [],
 			insert = jQuery( selector ),
 			last = insert.length - 1;
 
 		for ( ; i <= last; i++ ) {
 			elems = i === last ? this : this.clone( true );
 			jQuery( insert[ i ] )[ original ]( elems );
 
 			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
 			push.apply( ret, elems.get() );
 		}
 
 		return this.pushStack( ret );
 	};
 } );
 
 
 var iframe,
 	elemdisplay = {
 
 		// Support: Firefox
 		// We have to pre-define these values for FF (#10227)
 		HTML: "block",
 		BODY: "block"
 	};
 
 /**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */
 
 // Called only from within defaultDisplay
 function actualDisplay( name, doc ) {
 	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
 
 		display = jQuery.css( elem[ 0 ], "display" );
 
 	// We don't have any data stored on the element,
 	// so use "detach" method as fast way to get rid of the element
 	elem.detach();
 
 	return display;
 }
 
 /**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
 function defaultDisplay( nodeName ) {
 	var doc = document,
 		display = elemdisplay[ nodeName ];
 
 	if ( !display ) {
 		display = actualDisplay( nodeName, doc );
 
 		// If the simple way fails, read from inside an iframe
 		if ( display === "none" || !display ) {
 
 			// Use the already-created iframe if possible
 			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
 				.appendTo( doc.documentElement );
 
 			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
 			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;
 
 			// Support: IE
 			doc.write();
 			doc.close();
 
 			display = actualDisplay( nodeName, doc );
 			iframe.detach();
 		}
 
 		// Store the correct default display
 		elemdisplay[ nodeName ] = display;
 	}
 
 	return display;
 }
 var rmargin = ( /^margin/ );
 
 var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
 
 var swap = function( elem, options, callback, args ) {
 	var ret, name,
 		old = {};
 
 	// Remember the old values, and insert the new ones
 	for ( name in options ) {
 		old[ name ] = elem.style[ name ];
 		elem.style[ name ] = options[ name ];
 	}
 
 	ret = callback.apply( elem, args || [] );
 
 	// Revert the old values
 	for ( name in options ) {
 		elem.style[ name ] = old[ name ];
 	}
 
 	return ret;
 };
 
 
 var documentElement = document.documentElement;
 
 
 
 ( function() {
 	var pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal,
 		reliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal,
 		container = document.createElement( "div" ),
 		div = document.createElement( "div" );
 
 	// Finish early in limited (non-browser) environments
 	if ( !div.style ) {
 		return;
 	}
 
 	div.style.cssText = "float:left;opacity:.5";
 
 	// Support: IE<9
 	// Make sure that element opacity exists (as opposed to filter)
 	support.opacity = div.style.opacity === "0.5";
 
 	// Verify style float existence
 	// (IE uses styleFloat instead of cssFloat)
 	support.cssFloat = !!div.style.cssFloat;
 
 	div.style.backgroundClip = "content-box";
 	div.cloneNode( true ).style.backgroundClip = "";
 	support.clearCloneStyle = div.style.backgroundClip === "content-box";
 
 	container = document.createElement( "div" );
 	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
 		"padding:0;margin-top:1px;position:absolute";
 	div.innerHTML = "";
 	container.appendChild( div );
 
 	// Support: Firefox<29, Android 2.3
 	// Vendor-prefix box-sizing
 	support.boxSizing = div.style.boxSizing === "" || div.style.MozBoxSizing === "" ||
 		div.style.WebkitBoxSizing === "";
 
 	jQuery.extend( support, {
 		reliableHiddenOffsets: function() {
 			if ( pixelPositionVal == null ) {
 				computeStyleTests();
 			}
 			return reliableHiddenOffsetsVal;
 		},
 
 		boxSizingReliable: function() {
 
 			// We're checking for pixelPositionVal here instead of boxSizingReliableVal
 			// since that compresses better and they're computed together anyway.
 			if ( pixelPositionVal == null ) {
 				computeStyleTests();
 			}
 			return boxSizingReliableVal;
 		},
 
 		pixelMarginRight: function() {
 
 			// Support: Android 4.0-4.3
 			if ( pixelPositionVal == null ) {
 				computeStyleTests();
 			}
 			return pixelMarginRightVal;
 		},
 
 		pixelPosition: function() {
 			if ( pixelPositionVal == null ) {
 				computeStyleTests();
 			}
 			return pixelPositionVal;
 		},
 
 		reliableMarginRight: function() {
 
 			// Support: Android 2.3
 			if ( pixelPositionVal == null ) {
 				computeStyleTests();
 			}
 			return reliableMarginRightVal;
 		},
 
 		reliableMarginLeft: function() {
 
 			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
 			if ( pixelPositionVal == null ) {
 				computeStyleTests();
 			}
 			return reliableMarginLeftVal;
 		}
 	} );
 
 	function computeStyleTests() {
 		var contents, divStyle,
 			documentElement = document.documentElement;
 
 		// Setup
 		documentElement.appendChild( container );
 
 		div.style.cssText =
 
 			// Support: Android 2.3
 			// Vendor-prefix box-sizing
 			"-webkit-box-sizing:border-box;box-sizing:border-box;" +
 			"position:relative;display:block;" +
 			"margin:auto;border:1px;padding:1px;" +
 			"top:1%;width:50%";
 
 		// Support: IE<9
 		// Assume reasonable values in the absence of getComputedStyle
 		pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;
 		pixelMarginRightVal = reliableMarginRightVal = true;
 
 		// Check for getComputedStyle so that this code is not run in IE<9.
 		if ( window.getComputedStyle ) {
 			divStyle = window.getComputedStyle( div );
 			pixelPositionVal = ( divStyle || {} ).top !== "1%";
 			reliableMarginLeftVal = ( divStyle || {} ).marginLeft === "2px";
 			boxSizingReliableVal = ( divStyle || { width: "4px" } ).width === "4px";
 
 			// Support: Android 4.0 - 4.3 only
 			// Some styles come back with percentage values, even though they shouldn't
 			div.style.marginRight = "50%";
 			pixelMarginRightVal = ( divStyle || { marginRight: "4px" } ).marginRight === "4px";
 
 			// Support: Android 2.3 only
 			// Div with explicit width and no margin-right incorrectly
 			// gets computed margin-right based on width of container (#3333)
 			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
 			contents = div.appendChild( document.createElement( "div" ) );
 
 			// Reset CSS: box-sizing; display; margin; border; padding
 			contents.style.cssText = div.style.cssText =
 
 				// Support: Android 2.3
 				// Vendor-prefix box-sizing
 				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
 				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
 			contents.style.marginRight = contents.style.width = "0";
 			div.style.width = "1px";
 
 			reliableMarginRightVal =
 				!parseFloat( ( window.getComputedStyle( contents ) || {} ).marginRight );
 
 			div.removeChild( contents );
 		}
 
 		// Support: IE6-8
 		// First check that getClientRects works as expected
 		// Check if table cells still have offsetWidth/Height when they are set
 		// to display:none and there are still other visible table cells in a
 		// table row; if so, offsetWidth/Height are not reliable for use when
 		// determining if an element has been hidden directly using
 		// display:none (it is still safe to use offsets if a parent element is
 		// hidden; don safety goggles and see bug #4512 for more information).
 		div.style.display = "none";
 		reliableHiddenOffsetsVal = div.getClientRects().length === 0;
 		if ( reliableHiddenOffsetsVal ) {
 			div.style.display = "";
 			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
 			div.childNodes[ 0 ].style.borderCollapse = "separate";
 			contents = div.getElementsByTagName( "td" );
 			contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
 			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
 			if ( reliableHiddenOffsetsVal ) {
 				contents[ 0 ].style.display = "";
 				contents[ 1 ].style.display = "none";
 				reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
 			}
 		}
 
 		// Teardown
 		documentElement.removeChild( container );
 	}
 
 } )();
 
 
 var getStyles, curCSS,
 	rposition = /^(top|right|bottom|left)$/;
 
 if ( window.getComputedStyle ) {
 	getStyles = function( elem ) {
 
 		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
 		// IE throws on elements created in popups
 		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
 		var view = elem.ownerDocument.defaultView;
 
 		if ( !view || !view.opener ) {
 			view = window;
 		}
 
 		return view.getComputedStyle( elem );
 	};
 
 	curCSS = function( elem, name, computed ) {
 		var width, minWidth, maxWidth, ret,
 			style = elem.style;
 
 		computed = computed || getStyles( elem );
 
 		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
 		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
 
 		// Support: Opera 12.1x only
 		// Fall back to style even without computed
 		// computed is undefined for elems on document fragments
 		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
 			ret = jQuery.style( elem, name );
 		}
 
 		if ( computed ) {
 
 			// A tribute to the "awesome hack by Dean Edwards"
 			// Chrome < 17 and Safari 5.0 uses "computed value"
 			// instead of "used value" for margin-right
 			// Safari 5.1.7 (at least) returns percentage for a larger set of values,
 			// but width seems to be reliably pixels
 			// this is against the CSSOM draft spec:
 			// http://dev.w3.org/csswg/cssom/#resolved-values
 			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
 
 				// Remember the original values
 				width = style.width;
 				minWidth = style.minWidth;
 				maxWidth = style.maxWidth;
 
 				// Put in the new values to get a computed value out
 				style.minWidth = style.maxWidth = style.width = ret;
 				ret = computed.width;
 
 				// Revert the changed values
 				style.width = width;
 				style.minWidth = minWidth;
 				style.maxWidth = maxWidth;
 			}
 		}
 
 		// Support: IE
 		// IE returns zIndex value as an integer.
 		return ret === undefined ?
 			ret :
 			ret + "";
 	};
 } else if ( documentElement.currentStyle ) {
 	getStyles = function( elem ) {
 		return elem.currentStyle;
 	};
 
 	curCSS = function( elem, name, computed ) {
 		var left, rs, rsLeft, ret,
 			style = elem.style;
 
 		computed = computed || getStyles( elem );
 		ret = computed ? computed[ name ] : undefined;
 
 		// Avoid setting ret to empty string here
 		// so we don't default to auto
 		if ( ret == null && style && style[ name ] ) {
 			ret = style[ name ];
 		}
 
 		// From the awesome hack by Dean Edwards
 		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
 
 		// If we're not dealing with a regular pixel number
 		// but a number that has a weird ending, we need to convert it to pixels
 		// but not position css attributes, as those are
 		// proportional to the parent element instead
 		// and we can't measure the parent instead because it
 		// might trigger a "stacking dolls" problem
 		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {
 
 			// Remember the original values
 			left = style.left;
 			rs = elem.runtimeStyle;
 			rsLeft = rs && rs.left;
 
 			// Put in the new values to get a computed value out
 			if ( rsLeft ) {
 				rs.left = elem.currentStyle.left;
 			}
 			style.left = name === "fontSize" ? "1em" : ret;
 			ret = style.pixelLeft + "px";
 
 			// Revert the changed values
 			style.left = left;
 			if ( rsLeft ) {
 				rs.left = rsLeft;
 			}
 		}
 
 		// Support: IE
 		// IE returns zIndex value as an integer.
 		return ret === undefined ?
 			ret :
 			ret + "" || "auto";
 	};
 }
 
 
 
 
 function addGetHookIf( conditionFn, hookFn ) {
 
 	// Define the hook, we'll check on the first run if it's really needed.
 	return {
 		get: function() {
 			if ( conditionFn() ) {
 
 				// Hook not needed (or it's not possible to use it due
 				// to missing dependency), remove it.
 				delete this.get;
 				return;
 			}
 
 			// Hook needed; redefine it so that the support test is not executed again.
 			return ( this.get = hookFn ).apply( this, arguments );
 		}
 	};
 }
 
 
 var
 
 		ralpha = /alpha\([^)]*\)/i,
 	ropacity = /opacity\s*=\s*([^)]*)/i,
 
 	// swappable if display is none or starts with table except
 	// "table", "table-cell", or "table-caption"
 	// see here for display values:
 	// https://developer.mozilla.org/en-US/docs/CSS/display
 	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
 	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
 
 	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
 	cssNormalTransform = {
 		letterSpacing: "0",
 		fontWeight: "400"
 	},
 
 	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
 	emptyStyle = document.createElement( "div" ).style;
 
 
 // return a css property mapped to a potentially vendor prefixed property
 function vendorPropName( name ) {
 
 	// shortcut for names that are not vendor prefixed
 	if ( name in emptyStyle ) {
 		return name;
 	}
 
 	// check for vendor prefixed names
 	var capName = name.charAt( 0 ).toUpperCase() + name.slice( 1 ),
 		i = cssPrefixes.length;
 
 	while ( i-- ) {
 		name = cssPrefixes[ i ] + capName;
 		if ( name in emptyStyle ) {
 			return name;
 		}
 	}
 }
 
 function showHide( elements, show ) {
 	var display, elem, hidden,
 		values = [],
 		index = 0,
 		length = elements.length;
 
 	for ( ; index < length; index++ ) {
 		elem = elements[ index ];
 		if ( !elem.style ) {
 			continue;
 		}
 
 		values[ index ] = jQuery._data( elem, "olddisplay" );
 		display = elem.style.display;
 		if ( show ) {
 
 			// Reset the inline display of this element to learn if it is
 			// being hidden by cascaded rules or not
 			if ( !values[ index ] && display === "none" ) {
 				elem.style.display = "";
 			}
 
 			// Set elements which have been overridden with display: none
 			// in a stylesheet to whatever the default browser style is
 			// for such an element
 			if ( elem.style.display === "" && isHidden( elem ) ) {
 				values[ index ] =
 					jQuery._data( elem, "olddisplay", defaultDisplay( elem.nodeName ) );
 			}
 		} else {
 			hidden = isHidden( elem );
 
 			if ( display && display !== "none" || !hidden ) {
 				jQuery._data(
 					elem,
 					"olddisplay",
 					hidden ? display : jQuery.css( elem, "display" )
 				);
 			}
 		}
 	}
 
 	// Set the display of most of the elements in a second loop
 	// to avoid the constant reflow
 	for ( index = 0; index < length; index++ ) {
 		elem = elements[ index ];
 		if ( !elem.style ) {
 			continue;
 		}
 		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
 			elem.style.display = show ? values[ index ] || "" : "none";
 		}
 	}
 
 	return elements;
 }
 
 function setPositiveNumber( elem, value, subtract ) {
 	var matches = rnumsplit.exec( value );
 	return matches ?
 
 		// Guard against undefined "subtract", e.g., when used as in cssHooks
 		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
 		value;
 }
 
 function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
 	var i = extra === ( isBorderBox ? "border" : "content" ) ?
 
 		// If we already have the right measurement, avoid augmentation
 		4 :
 
 		// Otherwise initialize for horizontal or vertical properties
 		name === "width" ? 1 : 0,
 
 		val = 0;
 
 	for ( ; i < 4; i += 2 ) {
 
 		// both box models exclude margin, so add it if we want it
 		if ( extra === "margin" ) {
 			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
 		}
 
 		if ( isBorderBox ) {
 
 			// border-box includes padding, so remove it if we want content
 			if ( extra === "content" ) {
 				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
 			}
 
 			// at this point, extra isn't border nor margin, so remove border
 			if ( extra !== "margin" ) {
 				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
 			}
 		} else {
 
 			// at this point, extra isn't content, so add padding
 			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
 
 			// at this point, extra isn't content nor padding, so add border
 			if ( extra !== "padding" ) {
 				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
 			}
 		}
 	}
 
 	return val;
 }
 
 function getWidthOrHeight( elem, name, extra ) {
 
 	// Start with offset property, which is equivalent to the border-box value
 	var valueIsBorderBox = true,
 		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
 		styles = getStyles( elem ),
 		isBorderBox = support.boxSizing &&
 			jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
 
 	// some non-html elements return undefined for offsetWidth, so check for null/undefined
 	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
 	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
 	if ( val <= 0 || val == null ) {
 
 		// Fall back to computed then uncomputed css if necessary
 		val = curCSS( elem, name, styles );
 		if ( val < 0 || val == null ) {
 			val = elem.style[ name ];
 		}
 
 		// Computed unit is not pixels. Stop here and return.
 		if ( rnumnonpx.test( val ) ) {
 			return val;
 		}
 
 		// we need the check for style in case a browser which returns unreliable values
 		// for getComputedStyle silently falls back to the reliable elem.style
 		valueIsBorderBox = isBorderBox &&
 			( support.boxSizingReliable() || val === elem.style[ name ] );
 
 		// Normalize "", auto, and prepare for extra
 		val = parseFloat( val ) || 0;
 	}
 
 	// use the active box-sizing model to add/subtract irrelevant styles
 	return ( val +
 		augmentWidthOrHeight(
 			elem,
 			name,
 			extra || ( isBorderBox ? "border" : "content" ),
 			valueIsBorderBox,
 			styles
 		)
 	) + "px";
 }
 
 jQuery.extend( {
 
 	// Add in style property hooks for overriding the default
 	// behavior of getting and setting a style property
 	cssHooks: {
 		opacity: {
 			get: function( elem, computed ) {
 				if ( computed ) {
 
 					// We should always get a number back from opacity
 					var ret = curCSS( elem, "opacity" );
 					return ret === "" ? "1" : ret;
 				}
 			}
 		}
 	},
 
 	// Don't automatically add "px" to these possibly-unitless properties
 	cssNumber: {
 		"animationIterationCount": true,
 		"columnCount": true,
 		"fillOpacity": true,
 		"flexGrow": true,
 		"flexShrink": true,
 		"fontWeight": true,
 		"lineHeight": true,
 		"opacity": true,
 		"order": true,
 		"orphans": true,
 		"widows": true,
 		"zIndex": true,
 		"zoom": true
 	},
 
 	// Add in properties whose names you wish to fix before
 	// setting or getting the value
 	cssProps: {
 
 		// normalize float css property
 		"float": support.cssFloat ? "cssFloat" : "styleFloat"
 	},
 
 	// Get and set the style property on a DOM Node
 	style: function( elem, name, value, extra ) {
 
 		// Don't set styles on text and comment nodes
 		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
 			return;
 		}
 
 		// Make sure that we're working with the right name
 		var ret, type, hooks,
 			origName = jQuery.camelCase( name ),
 			style = elem.style;
 
 		name = jQuery.cssProps[ origName ] ||
 			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
 
 		// gets hook for the prefixed version
 		// followed by the unprefixed version
 		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
 
 		// Check if we're setting a value
 		if ( value !== undefined ) {
 			type = typeof value;
 
 			// Convert "+=" or "-=" to relative numbers (#7345)
 			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
 				value = adjustCSS( elem, name, ret );
 
 				// Fixes bug #9237
 				type = "number";
 			}
 
 			// Make sure that null and NaN values aren't set. See: #7116
 			if ( value == null || value !== value ) {
 				return;
 			}
 
 			// If a number was passed in, add the unit (except for certain CSS properties)
 			if ( type === "number" ) {
 				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
 			}
 
 			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
 			// but it would mean to define eight
 			// (for every problematic property) identical functions
 			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
 				style[ name ] = "inherit";
 			}
 
 			// If a hook was provided, use that value, otherwise just set the specified value
 			if ( !hooks || !( "set" in hooks ) ||
 				( value = hooks.set( elem, value, extra ) ) !== undefined ) {
 
 				// Support: IE
 				// Swallow errors from 'invalid' CSS values (#5509)
 				try {
 					style[ name ] = value;
 				} catch ( e ) {}
 			}
 
 		} else {
 
 			// If a hook was provided get the non-computed value from there
 			if ( hooks && "get" in hooks &&
 				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
 
 				return ret;
 			}
 
 			// Otherwise just get the value from the style object
 			return style[ name ];
 		}
 	},
 
 	css: function( elem, name, extra, styles ) {
 		var num, val, hooks,
 			origName = jQuery.camelCase( name );
 
 		// Make sure that we're working with the right name
 		name = jQuery.cssProps[ origName ] ||
 			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
 
 		// gets hook for the prefixed version
 		// followed by the unprefixed version
 		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
 
 		// If a hook was provided get the computed value from there
 		if ( hooks && "get" in hooks ) {
 			val = hooks.get( elem, true, extra );
 		}
 
 		// Otherwise, if a way to get the computed value exists, use that
 		if ( val === undefined ) {
 			val = curCSS( elem, name, styles );
 		}
 
 		//convert "normal" to computed value
 		if ( val === "normal" && name in cssNormalTransform ) {
 			val = cssNormalTransform[ name ];
 		}
 
 		// Return, converting to number if forced or a qualifier was provided and val looks numeric
 		if ( extra === "" || extra ) {
 			num = parseFloat( val );
 			return extra === true || isFinite( num ) ? num || 0 : val;
 		}
 		return val;
 	}
 } );
 
 jQuery.each( [ "height", "width" ], function( i, name ) {
 	jQuery.cssHooks[ name ] = {
 		get: function( elem, computed, extra ) {
 			if ( computed ) {
 
 				// certain elements can have dimension info if we invisibly show them
 				// however, it must have a current display style that would benefit from this
 				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
 					elem.offsetWidth === 0 ?
 						swap( elem, cssShow, function() {
 							return getWidthOrHeight( elem, name, extra );
 						} ) :
 						getWidthOrHeight( elem, name, extra );
 			}
 		},
 
 		set: function( elem, value, extra ) {
 			var styles = extra && getStyles( elem );
 			return setPositiveNumber( elem, value, extra ?
 				augmentWidthOrHeight(
 					elem,
 					name,
 					extra,
 					support.boxSizing &&
 						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
 					styles
 				) : 0
 			);
 		}
 	};
 } );
 
 if ( !support.opacity ) {
 	jQuery.cssHooks.opacity = {
 		get: function( elem, computed ) {
 
 			// IE uses filters for opacity
 			return ropacity.test( ( computed && elem.currentStyle ?
 				elem.currentStyle.filter :
 				elem.style.filter ) || "" ) ?
 					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
 					computed ? "1" : "";
 		},
 
 		set: function( elem, value ) {
 			var style = elem.style,
 				currentStyle = elem.currentStyle,
 				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
 				filter = currentStyle && currentStyle.filter || style.filter || "";
 
 			// IE has trouble with opacity if it does not have layout
 			// Force it by setting the zoom level
 			style.zoom = 1;
 
 			// if setting opacity to 1, and no other filters exist -
 			// attempt to remove filter attribute #6652
 			// if value === "", then remove inline opacity #12685
 			if ( ( value >= 1 || value === "" ) &&
 					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
 					style.removeAttribute ) {
 
 				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
 				// if "filter:" is present at all, clearType is disabled, we want to avoid this
 				// style.removeAttribute is IE Only, but so apparently is this code path...
 				style.removeAttribute( "filter" );
 
 				// if there is no filter style applied in a css rule
 				// or unset inline opacity, we are done
 				if ( value === "" || currentStyle && !currentStyle.filter ) {
 					return;
 				}
 			}
 
 			// otherwise, set new filter values
 			style.filter = ralpha.test( filter ) ?
 				filter.replace( ralpha, opacity ) :
 				filter + " " + opacity;
 		}
 	};
 }
 
 jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
 	function( elem, computed ) {
 		if ( computed ) {
 			return swap( elem, { "display": "inline-block" },
 				curCSS, [ elem, "marginRight" ] );
 		}
 	}
 );
 
 jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
 	function( elem, computed ) {
 		if ( computed ) {
 			return (
 				parseFloat( curCSS( elem, "marginLeft" ) ) ||
 
 				// Support: IE<=11+
 				// Running getBoundingClientRect on a disconnected node in IE throws an error
 				// Support: IE8 only
 				// getClientRects() errors on disconnected elems
 				( jQuery.contains( elem.ownerDocument, elem ) ?
 					elem.getBoundingClientRect().left -
 						swap( elem, { marginLeft: 0 }, function() {
 							return elem.getBoundingClientRect().left;
 						} ) :
 					0
 				)
 			) + "px";
 		}
 	}
 );
 
 // These hooks are used by animate to expand properties
 jQuery.each( {
 	margin: "",
 	padding: "",
 	border: "Width"
 }, function( prefix, suffix ) {
 	jQuery.cssHooks[ prefix + suffix ] = {
 		expand: function( value ) {
 			var i = 0,
 				expanded = {},
 
 				// assumes a single number if not a string
 				parts = typeof value === "string" ? value.split( " " ) : [ value ];
 
 			for ( ; i < 4; i++ ) {
 				expanded[ prefix + cssExpand[ i ] + suffix ] =
 					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
 			}
 
 			return expanded;
 		}
 	};
 
 	if ( !rmargin.test( prefix ) ) {
 		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
 	}
 } );
 
 jQuery.fn.extend( {
 	css: function( name, value ) {
 		return access( this, function( elem, name, value ) {
 			var styles, len,
 				map = {},
 				i = 0;
 
 			if ( jQuery.isArray( name ) ) {
 				styles = getStyles( elem );
 				len = name.length;
 
 				for ( ; i < len; i++ ) {
 					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
 				}
 
 				return map;
 			}
 
 			return value !== undefined ?
 				jQuery.style( elem, name, value ) :
 				jQuery.css( elem, name );
 		}, name, value, arguments.length > 1 );
 	},
 	show: function() {
 		return showHide( this, true );
 	},
 	hide: function() {
 		return showHide( this );
 	},
 	toggle: function( state ) {
 		if ( typeof state === "boolean" ) {
 			return state ? this.show() : this.hide();
 		}
 
 		return this.each( function() {
 			if ( isHidden( this ) ) {
 				jQuery( this ).show();
 			} else {
 				jQuery( this ).hide();
 			}
 		} );
 	}
 } );
 
 
 function Tween( elem, options, prop, end, easing ) {
 	return new Tween.prototype.init( elem, options, prop, end, easing );
 }
 jQuery.Tween = Tween;
 
 Tween.prototype = {
 	constructor: Tween,
 	init: function( elem, options, prop, end, easing, unit ) {
 		this.elem = elem;
 		this.prop = prop;
 		this.easing = easing || jQuery.easing._default;
 		this.options = options;
 		this.start = this.now = this.cur();
 		this.end = end;
 		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
 	},
 	cur: function() {
 		var hooks = Tween.propHooks[ this.prop ];
 
 		return hooks && hooks.get ?
 			hooks.get( this ) :
 			Tween.propHooks._default.get( this );
 	},
 	run: function( percent ) {
 		var eased,
 			hooks = Tween.propHooks[ this.prop ];
 
 		if ( this.options.duration ) {
 			this.pos = eased = jQuery.easing[ this.easing ](
 				percent, this.options.duration * percent, 0, 1, this.options.duration
 			);
 		} else {
 			this.pos = eased = percent;
 		}
 		this.now = ( this.end - this.start ) * eased + this.start;
 
 		if ( this.options.step ) {
 			this.options.step.call( this.elem, this.now, this );
 		}
 
 		if ( hooks && hooks.set ) {
 			hooks.set( this );
 		} else {
 			Tween.propHooks._default.set( this );
 		}
 		return this;
 	}
 };
 
 Tween.prototype.init.prototype = Tween.prototype;
 
 Tween.propHooks = {
 	_default: {
 		get: function( tween ) {
 			var result;
 
 			// Use a property on the element directly when it is not a DOM element,
 			// or when there is no matching style property that exists.
 			if ( tween.elem.nodeType !== 1 ||
 				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
 				return tween.elem[ tween.prop ];
 			}
 
 			// passing an empty string as a 3rd parameter to .css will automatically
 			// attempt a parseFloat and fallback to a string if the parse fails
 			// so, simple values such as "10px" are parsed to Float.
 			// complex values such as "rotate(1rad)" are returned as is.
 			result = jQuery.css( tween.elem, tween.prop, "" );
 
 			// Empty strings, null, undefined and "auto" are converted to 0.
 			return !result || result === "auto" ? 0 : result;
 		},
 		set: function( tween ) {
 
 			// use step hook for back compat - use cssHook if its there - use .style if its
 			// available and use plain properties where available
 			if ( jQuery.fx.step[ tween.prop ] ) {
 				jQuery.fx.step[ tween.prop ]( tween );
 			} else if ( tween.elem.nodeType === 1 &&
 				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
 					jQuery.cssHooks[ tween.prop ] ) ) {
 				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
 			} else {
 				tween.elem[ tween.prop ] = tween.now;
 			}
 		}
 	}
 };
 
 // Support: IE <=9
 // Panic based approach to setting things on disconnected nodes
 
 Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
 	set: function( tween ) {
 		if ( tween.elem.nodeType && tween.elem.parentNode ) {
 			tween.elem[ tween.prop ] = tween.now;
 		}
 	}
 };
 
 jQuery.easing = {
 	linear: function( p ) {
 		return p;
 	},
 	swing: function( p ) {
 		return 0.5 - Math.cos( p * Math.PI ) / 2;
 	},
 	_default: "swing"
 };
 
 jQuery.fx = Tween.prototype.init;
 
 // Back Compat <1.8 extension point
 jQuery.fx.step = {};
 
 
 
 
 var
 	fxNow, timerId,
 	rfxtypes = /^(?:toggle|show|hide)$/,
 	rrun = /queueHooks$/;
 
 // Animations created synchronously will run synchronously
 function createFxNow() {
 	window.setTimeout( function() {
 		fxNow = undefined;
 	} );
 	return ( fxNow = jQuery.now() );
 }
 
 // Generate parameters to create a standard animation
 function genFx( type, includeWidth ) {
 	var which,
 		attrs = { height: type },
 		i = 0;
 
 	// if we include width, step value is 1 to do all cssExpand values,
 	// if we don't include width, step value is 2 to skip over Left and Right
 	includeWidth = includeWidth ? 1 : 0;
 	for ( ; i < 4 ; i += 2 - includeWidth ) {
 		which = cssExpand[ i ];
 		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
 	}
 
 	if ( includeWidth ) {
 		attrs.opacity = attrs.width = type;
 	}
 
 	return attrs;
 }
 
 function createTween( value, prop, animation ) {
 	var tween,
 		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
 		index = 0,
 		length = collection.length;
 	for ( ; index < length; index++ ) {
 		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
 
 			// we're done with this property
 			return tween;
 		}
 	}
 }
 
 function defaultPrefilter( elem, props, opts ) {
 	/* jshint validthis: true */
 	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
 		anim = this,
 		orig = {},
 		style = elem.style,
 		hidden = elem.nodeType && isHidden( elem ),
 		dataShow = jQuery._data( elem, "fxshow" );
 
 	// handle queue: false promises
 	if ( !opts.queue ) {
 		hooks = jQuery._queueHooks( elem, "fx" );
 		if ( hooks.unqueued == null ) {
 			hooks.unqueued = 0;
 			oldfire = hooks.empty.fire;
 			hooks.empty.fire = function() {
 				if ( !hooks.unqueued ) {
 					oldfire();
 				}
 			};
 		}
 		hooks.unqueued++;
 
 		anim.always( function() {
 
 			// doing this makes sure that the complete handler will be called
 			// before this completes
 			anim.always( function() {
 				hooks.unqueued--;
 				if ( !jQuery.queue( elem, "fx" ).length ) {
 					hooks.empty.fire();
 				}
 			} );
 		} );
 	}
 
 	// height/width overflow pass
 	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
 
 		// Make sure that nothing sneaks out
 		// Record all 3 overflow attributes because IE does not
 		// change the overflow attribute when overflowX and
 		// overflowY are set to the same value
 		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
 
 		// Set display property to inline-block for height/width
 		// animations on inline elements that are having width/height animated
 		display = jQuery.css( elem, "display" );
 
 		// Test default display if display is currently "none"
 		checkDisplay = display === "none" ?
 			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
 
 		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
 
 			// inline-level elements accept inline-block;
 			// block-level elements need to be inline with layout
 			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
 				style.display = "inline-block";
 			} else {
 				style.zoom = 1;
 			}
 		}
 	}
 
 	if ( opts.overflow ) {
 		style.overflow = "hidden";
 		if ( !support.shrinkWrapBlocks() ) {
 			anim.always( function() {
 				style.overflow = opts.overflow[ 0 ];
 				style.overflowX = opts.overflow[ 1 ];
 				style.overflowY = opts.overflow[ 2 ];
 			} );
 		}
 	}
 
 	// show/hide pass
 	for ( prop in props ) {
 		value = props[ prop ];
 		if ( rfxtypes.exec( value ) ) {
 			delete props[ prop ];
 			toggle = toggle || value === "toggle";
 			if ( value === ( hidden ? "hide" : "show" ) ) {
 
 				// If there is dataShow left over from a stopped hide or show
 				// and we are going to proceed with show, we should pretend to be hidden
 				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
 					hidden = true;
 				} else {
 					continue;
 				}
 			}
 			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
 
 		// Any non-fx value stops us from restoring the original display value
 		} else {
 			display = undefined;
 		}
 	}
 
 	if ( !jQuery.isEmptyObject( orig ) ) {
 		if ( dataShow ) {
 			if ( "hidden" in dataShow ) {
 				hidden = dataShow.hidden;
 			}
 		} else {
 			dataShow = jQuery._data( elem, "fxshow", {} );
 		}
 
 		// store state if its toggle - enables .stop().toggle() to "reverse"
 		if ( toggle ) {
 			dataShow.hidden = !hidden;
 		}
 		if ( hidden ) {
 			jQuery( elem ).show();
 		} else {
 			anim.done( function() {
 				jQuery( elem ).hide();
 			} );
 		}
 		anim.done( function() {
 			var prop;
 			jQuery._removeData( elem, "fxshow" );
 			for ( prop in orig ) {
 				jQuery.style( elem, prop, orig[ prop ] );
 			}
 		} );
 		for ( prop in orig ) {
 			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
 
 			if ( !( prop in dataShow ) ) {
 				dataShow[ prop ] = tween.start;
 				if ( hidden ) {
 					tween.end = tween.start;
 					tween.start = prop === "width" || prop === "height" ? 1 : 0;
 				}
 			}
 		}
 
 	// If this is a noop like .hide().hide(), restore an overwritten display value
 	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
 		style.display = display;
 	}
 }
 
 function propFilter( props, specialEasing ) {
 	var index, name, easing, value, hooks;
 
 	// camelCase, specialEasing and expand cssHook pass
 	for ( index in props ) {
 		name = jQuery.camelCase( index );
 		easing = specialEasing[ name ];
 		value = props[ index ];
 		if ( jQuery.isArray( value ) ) {
 			easing = value[ 1 ];
 			value = props[ index ] = value[ 0 ];
 		}
 
 		if ( index !== name ) {
 			props[ name ] = value;
 			delete props[ index ];
 		}
 
 		hooks = jQuery.cssHooks[ name ];
 		if ( hooks && "expand" in hooks ) {
 			value = hooks.expand( value );
 			delete props[ name ];
 
 			// not quite $.extend, this wont overwrite keys already present.
 			// also - reusing 'index' from above because we have the correct "name"
 			for ( index in value ) {
 				if ( !( index in props ) ) {
 					props[ index ] = value[ index ];
 					specialEasing[ index ] = easing;
 				}
 			}
 		} else {
 			specialEasing[ name ] = easing;
 		}
 	}
 }
 
 function Animation( elem, properties, options ) {
 	var result,
 		stopped,
 		index = 0,
 		length = Animation.prefilters.length,
 		deferred = jQuery.Deferred().always( function() {
 
 			// don't match elem in the :animated selector
 			delete tick.elem;
 		} ),
 		tick = function() {
 			if ( stopped ) {
 				return false;
 			}
 			var currentTime = fxNow || createFxNow(),
 				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
 
 				// Support: Android 2.3
 				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
 				temp = remaining / animation.duration || 0,
 				percent = 1 - temp,
 				index = 0,
 				length = animation.tweens.length;
 
 			for ( ; index < length ; index++ ) {
 				animation.tweens[ index ].run( percent );
 			}
 
 			deferred.notifyWith( elem, [ animation, percent, remaining ] );
 
 			if ( percent < 1 && length ) {
 				return remaining;
 			} else {
 				deferred.resolveWith( elem, [ animation ] );
 				return false;
 			}
 		},
 		animation = deferred.promise( {
 			elem: elem,
 			props: jQuery.extend( {}, properties ),
 			opts: jQuery.extend( true, {
 				specialEasing: {},
 				easing: jQuery.easing._default
 			}, options ),
 			originalProperties: properties,
 			originalOptions: options,
 			startTime: fxNow || createFxNow(),
 			duration: options.duration,
 			tweens: [],
 			createTween: function( prop, end ) {
 				var tween = jQuery.Tween( elem, animation.opts, prop, end,
 						animation.opts.specialEasing[ prop ] || animation.opts.easing );
 				animation.tweens.push( tween );
 				return tween;
 			},
 			stop: function( gotoEnd ) {
 				var index = 0,
 
 					// if we are going to the end, we want to run all the tweens
 					// otherwise we skip this part
 					length = gotoEnd ? animation.tweens.length : 0;
 				if ( stopped ) {
 					return this;
 				}
 				stopped = true;
 				for ( ; index < length ; index++ ) {
 					animation.tweens[ index ].run( 1 );
 				}
 
 				// resolve when we played the last frame
 				// otherwise, reject
 				if ( gotoEnd ) {
 					deferred.notifyWith( elem, [ animation, 1, 0 ] );
 					deferred.resolveWith( elem, [ animation, gotoEnd ] );
 				} else {
 					deferred.rejectWith( elem, [ animation, gotoEnd ] );
 				}
 				return this;
 			}
 		} ),
 		props = animation.props;
 
 	propFilter( props, animation.opts.specialEasing );
 
 	for ( ; index < length ; index++ ) {
 		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
 		if ( result ) {
 			if ( jQuery.isFunction( result.stop ) ) {
 				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
 					jQuery.proxy( result.stop, result );
 			}
 			return result;
 		}
 	}
 
 	jQuery.map( props, createTween, animation );
 
 	if ( jQuery.isFunction( animation.opts.start ) ) {
 		animation.opts.start.call( elem, animation );
 	}
 
 	jQuery.fx.timer(
 		jQuery.extend( tick, {
 			elem: elem,
 			anim: animation,
 			queue: animation.opts.queue
 		} )
 	);
 
 	// attach callbacks from options
 	return animation.progress( animation.opts.progress )
 		.done( animation.opts.done, animation.opts.complete )
 		.fail( animation.opts.fail )
 		.always( animation.opts.always );
 }
 
 jQuery.Animation = jQuery.extend( Animation, {
 
 	tweeners: {
 		"*": [ function( prop, value ) {
 			var tween = this.createTween( prop, value );
 			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
 			return tween;
 		} ]
 	},
 
 	tweener: function( props, callback ) {
 		if ( jQuery.isFunction( props ) ) {
 			callback = props;
 			props = [ "*" ];
 		} else {
 			props = props.match( rnotwhite );
 		}
 
 		var prop,
 			index = 0,
 			length = props.length;
 
 		for ( ; index < length ; index++ ) {
 			prop = props[ index ];
 			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
 			Animation.tweeners[ prop ].unshift( callback );
 		}
 	},
 
 	prefilters: [ defaultPrefilter ],
 
 	prefilter: function( callback, prepend ) {
 		if ( prepend ) {
 			Animation.prefilters.unshift( callback );
 		} else {
 			Animation.prefilters.push( callback );
 		}
 	}
 } );
 
 jQuery.speed = function( speed, easing, fn ) {
 	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
 		complete: fn || !fn && easing ||
 			jQuery.isFunction( speed ) && speed,
 		duration: speed,
 		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
 	};
 
 	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
 		opt.duration in jQuery.fx.speeds ?
 			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
 
 	// normalize opt.queue - true/undefined/null -> "fx"
 	if ( opt.queue == null || opt.queue === true ) {
 		opt.queue = "fx";
 	}
 
 	// Queueing
 	opt.old = opt.complete;
 
 	opt.complete = function() {
 		if ( jQuery.isFunction( opt.old ) ) {
 			opt.old.call( this );
 		}
 
 		if ( opt.queue ) {
 			jQuery.dequeue( this, opt.queue );
 		}
 	};
 
 	return opt;
 };
 
 jQuery.fn.extend( {
 	fadeTo: function( speed, to, easing, callback ) {
 
 		// show any hidden elements after setting opacity to 0
 		return this.filter( isHidden ).css( "opacity", 0 ).show()
 
 			// animate to the value specified
 			.end().animate( { opacity: to }, speed, easing, callback );
 	},
 	animate: function( prop, speed, easing, callback ) {
 		var empty = jQuery.isEmptyObject( prop ),
 			optall = jQuery.speed( speed, easing, callback ),
 			doAnimation = function() {
 
 				// Operate on a copy of prop so per-property easing won't be lost
 				var anim = Animation( this, jQuery.extend( {}, prop ), optall );
 
 				// Empty animations, or finishing resolves immediately
 				if ( empty || jQuery._data( this, "finish" ) ) {
 					anim.stop( true );
 				}
 			};
 			doAnimation.finish = doAnimation;
 
 		return empty || optall.queue === false ?
 			this.each( doAnimation ) :
 			this.queue( optall.queue, doAnimation );
 	},
 	stop: function( type, clearQueue, gotoEnd ) {
 		var stopQueue = function( hooks ) {
 			var stop = hooks.stop;
 			delete hooks.stop;
 			stop( gotoEnd );
 		};
 
 		if ( typeof type !== "string" ) {
 			gotoEnd = clearQueue;
 			clearQueue = type;
 			type = undefined;
 		}
 		if ( clearQueue && type !== false ) {
 			this.queue( type || "fx", [] );
 		}
 
 		return this.each( function() {
 			var dequeue = true,
 				index = type != null && type + "queueHooks",
 				timers = jQuery.timers,
 				data = jQuery._data( this );
 
 			if ( index ) {
 				if ( data[ index ] && data[ index ].stop ) {
 					stopQueue( data[ index ] );
 				}
 			} else {
 				for ( index in data ) {
 					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
 						stopQueue( data[ index ] );
 					}
 				}
 			}
 
 			for ( index = timers.length; index--; ) {
 				if ( timers[ index ].elem === this &&
 					( type == null || timers[ index ].queue === type ) ) {
 
 					timers[ index ].anim.stop( gotoEnd );
 					dequeue = false;
 					timers.splice( index, 1 );
 				}
 			}
 
 			// start the next in the queue if the last step wasn't forced
 			// timers currently will call their complete callbacks, which will dequeue
 			// but only if they were gotoEnd
 			if ( dequeue || !gotoEnd ) {
 				jQuery.dequeue( this, type );
 			}
 		} );
 	},
 	finish: function( type ) {
 		if ( type !== false ) {
 			type = type || "fx";
 		}
 		return this.each( function() {
 			var index,
 				data = jQuery._data( this ),
 				queue = data[ type + "queue" ],
 				hooks = data[ type + "queueHooks" ],
 				timers = jQuery.timers,
 				length = queue ? queue.length : 0;
 
 			// enable finishing flag on private data
 			data.finish = true;
 
 			// empty the queue first
 			jQuery.queue( this, type, [] );
 
 			if ( hooks && hooks.stop ) {
 				hooks.stop.call( this, true );
 			}
 
 			// look for any active animations, and finish them
 			for ( index = timers.length; index--; ) {
 				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
 					timers[ index ].anim.stop( true );
 					timers.splice( index, 1 );
 				}
 			}
 
 			// look for any animations in the old queue and finish them
 			for ( index = 0; index < length; index++ ) {
 				if ( queue[ index ] && queue[ index ].finish ) {
 					queue[ index ].finish.call( this );
 				}
 			}
 
 			// turn off finishing flag
 			delete data.finish;
 		} );
 	}
 } );
 
 jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
 	var cssFn = jQuery.fn[ name ];
 	jQuery.fn[ name ] = function( speed, easing, callback ) {
 		return speed == null || typeof speed === "boolean" ?
 			cssFn.apply( this, arguments ) :
 			this.animate( genFx( name, true ), speed, easing, callback );
 	};
 } );
 
 // Generate shortcuts for custom animations
 jQuery.each( {
 	slideDown: genFx( "show" ),
 	slideUp: genFx( "hide" ),
 	slideToggle: genFx( "toggle" ),
 	fadeIn: { opacity: "show" },
 	fadeOut: { opacity: "hide" },
 	fadeToggle: { opacity: "toggle" }
 }, function( name, props ) {
 	jQuery.fn[ name ] = function( speed, easing, callback ) {
 		return this.animate( props, speed, easing, callback );
 	};
 } );
 
 jQuery.timers = [];
 jQuery.fx.tick = function() {
 	var timer,
 		timers = jQuery.timers,
 		i = 0;
 
 	fxNow = jQuery.now();
 
 	for ( ; i < timers.length; i++ ) {
 		timer = timers[ i ];
 
 		// Checks the timer has not already been removed
 		if ( !timer() && timers[ i ] === timer ) {
 			timers.splice( i--, 1 );
 		}
 	}
 
 	if ( !timers.length ) {
 		jQuery.fx.stop();
 	}
 	fxNow = undefined;
 };
 
 jQuery.fx.timer = function( timer ) {
 	jQuery.timers.push( timer );
 	if ( timer() ) {
 		jQuery.fx.start();
 	} else {
 		jQuery.timers.pop();
 	}
 };
 
 jQuery.fx.interval = 13;
 
 jQuery.fx.start = function() {
 	if ( !timerId ) {
 		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
 	}
 };
 
 jQuery.fx.stop = function() {
 	window.clearInterval( timerId );
 	timerId = null;
 };
 
 jQuery.fx.speeds = {
 	slow: 600,
 	fast: 200,
 
 	// Default speed
 	_default: 400
 };
 
 
 // Based off of the plugin by Clint Helfers, with permission.
 // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
 jQuery.fn.delay = function( time, type ) {
 	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
 	type = type || "fx";
 
 	return this.queue( type, function( next, hooks ) {
 		var timeout = window.setTimeout( next, time );
 		hooks.stop = function() {
 			window.clearTimeout( timeout );
 		};
 	} );
 };
 
 
 ( function() {
 	var a,
 		input = document.createElement( "input" ),
 		div = document.createElement( "div" ),
 		select = document.createElement( "select" ),
 		opt = select.appendChild( document.createElement( "option" ) );
 
 	// Setup
 	div = document.createElement( "div" );
 	div.setAttribute( "className", "t" );
 	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
 	a = div.getElementsByTagName( "a" )[ 0 ];
 
 	// Support: Windows Web Apps (WWA)
 	// `type` must use .setAttribute for WWA (#14901)
 	input.setAttribute( "type", "checkbox" );
 	div.appendChild( input );
 
 	a = div.getElementsByTagName( "a" )[ 0 ];
 
 	// First batch of tests.
 	a.style.cssText = "top:1px";
 
 	// Test setAttribute on camelCase class.
 	// If it works, we need attrFixes when doing get/setAttribute (ie6/7)
 	support.getSetAttribute = div.className !== "t";
 
 	// Get the style information from getAttribute
 	// (IE uses .cssText instead)
 	support.style = /top/.test( a.getAttribute( "style" ) );
 
 	// Make sure that URLs aren't manipulated
 	// (IE normalizes it by default)
 	support.hrefNormalized = a.getAttribute( "href" ) === "/a";
 
 	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
 	support.checkOn = !!input.value;
 
 	// Make sure that a selected-by-default option has a working selected property.
 	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
 	support.optSelected = opt.selected;
 
 	// Tests for enctype support on a form (#6743)
 	support.enctype = !!document.createElement( "form" ).enctype;
 
 	// Make sure that the options inside disabled selects aren't marked as disabled
 	// (WebKit marks them as disabled)
 	select.disabled = true;
 	support.optDisabled = !opt.disabled;
 
 	// Support: IE8 only
 	// Check if we can trust getAttribute("value")
 	input = document.createElement( "input" );
 	input.setAttribute( "value", "" );
 	support.input = input.getAttribute( "value" ) === "";
 
 	// Check if an input maintains its value after becoming a radio
 	input.value = "t";
 	input.setAttribute( "type", "radio" );
 	support.radioValue = input.value === "t";
 } )();
 
 
 var rreturn = /\r/g,
 	rspaces = /[\x20\t\r\n\f]+/g;
 
 jQuery.fn.extend( {
 	val: function( value ) {
 		var hooks, ret, isFunction,
 			elem = this[ 0 ];
 
 		if ( !arguments.length ) {
 			if ( elem ) {
 				hooks = jQuery.valHooks[ elem.type ] ||
 					jQuery.valHooks[ elem.nodeName.toLowerCase() ];
 
 				if (
 					hooks &&
 					"get" in hooks &&
 					( ret = hooks.get( elem, "value" ) ) !== undefined
 				) {
 					return ret;
 				}
 
 				ret = elem.value;
 
 				return typeof ret === "string" ?
 
 					// handle most common string cases
 					ret.replace( rreturn, "" ) :
 
 					// handle cases where value is null/undef or number
 					ret == null ? "" : ret;
 			}
 
 			return;
 		}
 
 		isFunction = jQuery.isFunction( value );
 
 		return this.each( function( i ) {
 			var val;
 
 			if ( this.nodeType !== 1 ) {
 				return;
 			}
 
 			if ( isFunction ) {
 				val = value.call( this, i, jQuery( this ).val() );
 			} else {
 				val = value;
 			}
 
 			// Treat null/undefined as ""; convert numbers to string
 			if ( val == null ) {
 				val = "";
 			} else if ( typeof val === "number" ) {
 				val += "";
 			} else if ( jQuery.isArray( val ) ) {
 				val = jQuery.map( val, function( value ) {
 					return value == null ? "" : value + "";
 				} );
 			}
 
 			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
 
 			// If set returns undefined, fall back to normal setting
 			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
 				this.value = val;
 			}
 		} );
 	}
 } );
 
 jQuery.extend( {
 	valHooks: {
 		option: {
 			get: function( elem ) {
 				var val = jQuery.find.attr( elem, "value" );
 				return val != null ?
 					val :
 
 					// Support: IE10-11+
 					// option.text throws exceptions (#14686, #14858)
 					// Strip and collapse whitespace
 					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
 					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
 			}
 		},
 		select: {
 			get: function( elem ) {
 				var value, option,
 					options = elem.options,
 					index = elem.selectedIndex,
 					one = elem.type === "select-one" || index < 0,
 					values = one ? null : [],
 					max = one ? index + 1 : options.length,
 					i = index < 0 ?
 						max :
 						one ? index : 0;
 
 				// Loop through all the selected options
 				for ( ; i < max; i++ ) {
 					option = options[ i ];
 
 					// oldIE doesn't update selected after form reset (#2551)
 					if ( ( option.selected || i === index ) &&
 
 							// Don't return options that are disabled or in a disabled optgroup
 							( support.optDisabled ?
 								!option.disabled :
 								option.getAttribute( "disabled" ) === null ) &&
 							( !option.parentNode.disabled ||
 								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
 
 						// Get the specific value for the option
 						value = jQuery( option ).val();
 
 						// We don't need an array for one selects
 						if ( one ) {
 							return value;
 						}
 
 						// Multi-Selects return an array
 						values.push( value );
 					}
 				}
 
 				return values;
 			},
 
 			set: function( elem, value ) {
 				var optionSet, option,
 					options = elem.options,
 					values = jQuery.makeArray( value ),
 					i = options.length;
 
 				while ( i-- ) {
 					option = options[ i ];
 
 					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1 ) {
 
 						// Support: IE6
 						// When new option element is added to select box we need to
 						// force reflow of newly added node in order to workaround delay
 						// of initialization properties
 						try {
 							option.selected = optionSet = true;
 
 						} catch ( _ ) {
 
 							// Will be executed only in IE6
 							option.scrollHeight;
 						}
 
 					} else {
 						option.selected = false;
 					}
 				}
 
 				// Force browsers to behave consistently when non-matching value is set
 				if ( !optionSet ) {
 					elem.selectedIndex = -1;
 				}
 
 				return options;
 			}
 		}
 	}
 } );
 
 // Radios and checkboxes getter/setter
 jQuery.each( [ "radio", "checkbox" ], function() {
 	jQuery.valHooks[ this ] = {
 		set: function( elem, value ) {
 			if ( jQuery.isArray( value ) ) {
 				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
 			}
 		}
 	};
 	if ( !support.checkOn ) {
 		jQuery.valHooks[ this ].get = function( elem ) {
 			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
 		};
 	}
 } );
 
 
 
 
 var nodeHook, boolHook,
 	attrHandle = jQuery.expr.attrHandle,
 	ruseDefault = /^(?:checked|selected)$/i,
 	getSetAttribute = support.getSetAttribute,
 	getSetInput = support.input;
 
 jQuery.fn.extend( {
 	attr: function( name, value ) {
 		return access( this, jQuery.attr, name, value, arguments.length > 1 );
 	},
 
 	removeAttr: function( name ) {
 		return this.each( function() {
 			jQuery.removeAttr( this, name );
 		} );
 	}
 } );
 
 jQuery.extend( {
 	attr: function( elem, name, value ) {
 		var ret, hooks,
 			nType = elem.nodeType;
 
 		// Don't get/set attributes on text, comment and attribute nodes
 		if ( nType === 3 || nType === 8 || nType === 2 ) {
 			return;
 		}
 
 		// Fallback to prop when attributes are not supported
 		if ( typeof elem.getAttribute === "undefined" ) {
 			return jQuery.prop( elem, name, value );
 		}
 
 		// All attributes are lowercase
 		// Grab necessary hook if one is defined
 		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
 			name = name.toLowerCase();
 			hooks = jQuery.attrHooks[ name ] ||
 				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
 		}
 
 		if ( value !== undefined ) {
 			if ( value === null ) {
 				jQuery.removeAttr( elem, name );
 				return;
 			}
 
 			if ( hooks && "set" in hooks &&
 				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
 				return ret;
 			}
 
 			elem.setAttribute( name, value + "" );
 			return value;
 		}
 
 		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
 			return ret;
 		}
 
 		ret = jQuery.find.attr( elem, name );
 
 		// Non-existent attributes return null, we normalize to undefined
 		return ret == null ? undefined : ret;
 	},
 
 	attrHooks: {
 		type: {
 			set: function( elem, value ) {
 				if ( !support.radioValue && value === "radio" &&
 					jQuery.nodeName( elem, "input" ) ) {
 
 					// Setting the type on a radio button after the value resets the value in IE8-9
 					// Reset value to default in case type is set after value during creation
 					var val = elem.value;
 					elem.setAttribute( "type", value );
 					if ( val ) {
 						elem.value = val;
 					}
 					return value;
 				}
 			}
 		}
 	},
 
 	removeAttr: function( elem, value ) {
 		var name, propName,
 			i = 0,
 			attrNames = value && value.match( rnotwhite );
 
 		if ( attrNames && elem.nodeType === 1 ) {
 			while ( ( name = attrNames[ i++ ] ) ) {
 				propName = jQuery.propFix[ name ] || name;
 
 				// Boolean attributes get special treatment (#10870)
 				if ( jQuery.expr.match.bool.test( name ) ) {
 
 					// Set corresponding property to false
 					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
 						elem[ propName ] = false;
 
 					// Support: IE<9
 					// Also clear defaultChecked/defaultSelected (if appropriate)
 					} else {
 						elem[ jQuery.camelCase( "default-" + name ) ] =
 							elem[ propName ] = false;
 					}
 
 				// See #9699 for explanation of this approach (setting first, then removal)
 				} else {
 					jQuery.attr( elem, name, "" );
 				}
 
 				elem.removeAttribute( getSetAttribute ? name : propName );
 			}
 		}
 	}
 } );
 
 // Hooks for boolean attributes
 boolHook = {
 	set: function( elem, value, name ) {
 		if ( value === false ) {
 
 			// Remove boolean attributes when set to false
 			jQuery.removeAttr( elem, name );
 		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
 
 			// IE<8 needs the *property* name
 			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );
 
 		} else {
 
 			// Support: IE<9
 			// Use defaultChecked and defaultSelected for oldIE
 			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
 		}
 		return name;
 	}
 };
 
 jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
 	var getter = attrHandle[ name ] || jQuery.find.attr;
 
 	if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
 		attrHandle[ name ] = function( elem, name, isXML ) {
 			var ret, handle;
 			if ( !isXML ) {
 
 				// Avoid an infinite loop by temporarily removing this function from the getter
 				handle = attrHandle[ name ];
 				attrHandle[ name ] = ret;
 				ret = getter( elem, name, isXML ) != null ?
 					name.toLowerCase() :
 					null;
 				attrHandle[ name ] = handle;
 			}
 			return ret;
 		};
 	} else {
 		attrHandle[ name ] = function( elem, name, isXML ) {
 			if ( !isXML ) {
 				return elem[ jQuery.camelCase( "default-" + name ) ] ?
 					name.toLowerCase() :
 					null;
 			}
 		};
 	}
 } );
 
 // fix oldIE attroperties
 if ( !getSetInput || !getSetAttribute ) {
 	jQuery.attrHooks.value = {
 		set: function( elem, value, name ) {
 			if ( jQuery.nodeName( elem, "input" ) ) {
 
 				// Does not return so that setAttribute is also used
 				elem.defaultValue = value;
 			} else {
 
 				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
 				return nodeHook && nodeHook.set( elem, value, name );
 			}
 		}
 	};
 }
 
 // IE6/7 do not support getting/setting some attributes with get/setAttribute
 if ( !getSetAttribute ) {
 
 	// Use this for any attribute in IE6/7
 	// This fixes almost every IE6/7 issue
 	nodeHook = {
 		set: function( elem, value, name ) {
 
 			// Set the existing or create a new attribute node
 			var ret = elem.getAttributeNode( name );
 			if ( !ret ) {
 				elem.setAttributeNode(
 					( ret = elem.ownerDocument.createAttribute( name ) )
 				);
 			}
 
 			ret.value = value += "";
 
 			// Break association with cloned elements by also using setAttribute (#9646)
 			if ( name === "value" || value === elem.getAttribute( name ) ) {
 				return value;
 			}
 		}
 	};
 
 	// Some attributes are constructed with empty-string values when not defined
 	attrHandle.id = attrHandle.name = attrHandle.coords =
 		function( elem, name, isXML ) {
 			var ret;
 			if ( !isXML ) {
 				return ( ret = elem.getAttributeNode( name ) ) && ret.value !== "" ?
 					ret.value :
 					null;
 			}
 		};
 
 	// Fixing value retrieval on a button requires this module
 	jQuery.valHooks.button = {
 		get: function( elem, name ) {
 			var ret = elem.getAttributeNode( name );
 			if ( ret && ret.specified ) {
 				return ret.value;
 			}
 		},
 		set: nodeHook.set
 	};
 
 	// Set contenteditable to false on removals(#10429)
 	// Setting to empty string throws an error as an invalid value
 	jQuery.attrHooks.contenteditable = {
 		set: function( elem, value, name ) {
 			nodeHook.set( elem, value === "" ? false : value, name );
 		}
 	};
 
 	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
 	// This is for removals
 	jQuery.each( [ "width", "height" ], function( i, name ) {
 		jQuery.attrHooks[ name ] = {
 			set: function( elem, value ) {
 				if ( value === "" ) {
 					elem.setAttribute( name, "auto" );
 					return value;
 				}
 			}
 		};
 	} );
 }
 
 if ( !support.style ) {
 	jQuery.attrHooks.style = {
 		get: function( elem ) {
 
 			// Return undefined in the case of empty string
 			// Note: IE uppercases css property names, but if we were to .toLowerCase()
 			// .cssText, that would destroy case sensitivity in URL's, like in "background"
 			return elem.style.cssText || undefined;
 		},
 		set: function( elem, value ) {
 			return ( elem.style.cssText = value + "" );
 		}
 	};
 }
 
 
 
 
 var rfocusable = /^(?:input|select|textarea|button|object)$/i,
 	rclickable = /^(?:a|area)$/i;
 
 jQuery.fn.extend( {
 	prop: function( name, value ) {
 		return access( this, jQuery.prop, name, value, arguments.length > 1 );
 	},
 
 	removeProp: function( name ) {
 		name = jQuery.propFix[ name ] || name;
 		return this.each( function() {
 
 			// try/catch handles cases where IE balks (such as removing a property on window)
 			try {
 				this[ name ] = undefined;
 				delete this[ name ];
 			} catch ( e ) {}
 		} );
 	}
 } );
 
 jQuery.extend( {
 	prop: function( elem, name, value ) {
 		var ret, hooks,
 			nType = elem.nodeType;
 
 		// Don't get/set properties on text, comment and attribute nodes
 		if ( nType === 3 || nType === 8 || nType === 2 ) {
 			return;
 		}
 
 		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
 
 			// Fix name and attach hooks
 			name = jQuery.propFix[ name ] || name;
 			hooks = jQuery.propHooks[ name ];
 		}
 
 		if ( value !== undefined ) {
 			if ( hooks && "set" in hooks &&
 				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
 				return ret;
 			}
 
 			return ( elem[ name ] = value );
 		}
 
 		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
 			return ret;
 		}
 
 		return elem[ name ];
 	},
 
 	propHooks: {
 		tabIndex: {
 			get: function( elem ) {
 
 				// elem.tabIndex doesn't always return the
 				// correct value when it hasn't been explicitly set
 				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
 				// Use proper attribute retrieval(#12072)
 				var tabindex = jQuery.find.attr( elem, "tabindex" );
 
 				return tabindex ?
 					parseInt( tabindex, 10 ) :
 					rfocusable.test( elem.nodeName ) ||
 						rclickable.test( elem.nodeName ) && elem.href ?
 							0 :
 							-1;
 			}
 		}
 	},
 
 	propFix: {
 		"for": "htmlFor",
 		"class": "className"
 	}
 } );
 
 // Some attributes require a special call on IE
 // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
 if ( !support.hrefNormalized ) {
 
 	// href/src property should get the full normalized URL (#10299/#12915)
 	jQuery.each( [ "href", "src" ], function( i, name ) {
 		jQuery.propHooks[ name ] = {
 			get: function( elem ) {
 				return elem.getAttribute( name, 4 );
 			}
 		};
 	} );
 }
 
 // Support: Safari, IE9+
 // Accessing the selectedIndex property
 // forces the browser to respect setting selected
 // on the option
 // The getter ensures a default option is selected
 // when in an optgroup
 if ( !support.optSelected ) {
 	jQuery.propHooks.selected = {
 		get: function( elem ) {
 			var parent = elem.parentNode;
 
 			if ( parent ) {
 				parent.selectedIndex;
 
 				// Make sure that it also works with optgroups, see #5701
 				if ( parent.parentNode ) {
 					parent.parentNode.selectedIndex;
 				}
 			}
 			return null;
 		},
 		set: function( elem ) {
 			var parent = elem.parentNode;
 			if ( parent ) {
 				parent.selectedIndex;
 
 				if ( parent.parentNode ) {
 					parent.parentNode.selectedIndex;
 				}
 			}
 		}
 	};
 }
 
 jQuery.each( [
 	"tabIndex",
 	"readOnly",
 	"maxLength",
 	"cellSpacing",
 	"cellPadding",
 	"rowSpan",
 	"colSpan",
 	"useMap",
 	"frameBorder",
 	"contentEditable"
 ], function() {
 	jQuery.propFix[ this.toLowerCase() ] = this;
 } );
 
 // IE6/7 call enctype encoding
 if ( !support.enctype ) {
 	jQuery.propFix.enctype = "encoding";
 }
 
 
 
 
 var rclass = /[\t\r\n\f]/g;
 
 function getClass( elem ) {
 	return jQuery.attr( elem, "class" ) || "";
 }
 
 jQuery.fn.extend( {
 	addClass: function( value ) {
 		var classes, elem, cur, curValue, clazz, j, finalValue,
 			i = 0;
 
 		if ( jQuery.isFunction( value ) ) {
 			return this.each( function( j ) {
 				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
 			} );
 		}
 
 		if ( typeof value === "string" && value ) {
 			classes = value.match( rnotwhite ) || [];
 
 			while ( ( elem = this[ i++ ] ) ) {
 				curValue = getClass( elem );
 				cur = elem.nodeType === 1 &&
 					( " " + curValue + " " ).replace( rclass, " " );
 
 				if ( cur ) {
 					j = 0;
 					while ( ( clazz = classes[ j++ ] ) ) {
 						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
 							cur += clazz + " ";
 						}
 					}
 
 					// only assign if different to avoid unneeded rendering.
 					finalValue = jQuery.trim( cur );
 					if ( curValue !== finalValue ) {
 						jQuery.attr( elem, "class", finalValue );
 					}
 				}
 			}
 		}
 
 		return this;
 	},
 
 	removeClass: function( value ) {
 		var classes, elem, cur, curValue, clazz, j, finalValue,
 			i = 0;
 
 		if ( jQuery.isFunction( value ) ) {
 			return this.each( function( j ) {
 				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
 			} );
 		}
 
 		if ( !arguments.length ) {
 			return this.attr( "class", "" );
 		}
 
 		if ( typeof value === "string" && value ) {
 			classes = value.match( rnotwhite ) || [];
 
 			while ( ( elem = this[ i++ ] ) ) {
 				curValue = getClass( elem );
 
 				// This expression is here for better compressibility (see addClass)
 				cur = elem.nodeType === 1 &&
 					( " " + curValue + " " ).replace( rclass, " " );
 
 				if ( cur ) {
 					j = 0;
 					while ( ( clazz = classes[ j++ ] ) ) {
 
 						// Remove *all* instances
 						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
 							cur = cur.replace( " " + clazz + " ", " " );
 						}
 					}
 
 					// Only assign if different to avoid unneeded rendering.
 					finalValue = jQuery.trim( cur );
 					if ( curValue !== finalValue ) {
 						jQuery.attr( elem, "class", finalValue );
 					}
 				}
 			}
 		}
 
 		return this;
 	},
 
 	toggleClass: function( value, stateVal ) {
 		var type = typeof value;
 
 		if ( typeof stateVal === "boolean" && type === "string" ) {
 			return stateVal ? this.addClass( value ) : this.removeClass( value );
 		}
 
 		if ( jQuery.isFunction( value ) ) {
 			return this.each( function( i ) {
 				jQuery( this ).toggleClass(
 					value.call( this, i, getClass( this ), stateVal ),
 					stateVal
 				);
 			} );
 		}
 
 		return this.each( function() {
 			var className, i, self, classNames;
 
 			if ( type === "string" ) {
 
 				// Toggle individual class names
 				i = 0;
 				self = jQuery( this );
 				classNames = value.match( rnotwhite ) || [];
 
 				while ( ( className = classNames[ i++ ] ) ) {
 
 					// Check each className given, space separated list
 					if ( self.hasClass( className ) ) {
 						self.removeClass( className );
 					} else {
 						self.addClass( className );
 					}
 				}
 
 			// Toggle whole class name
 			} else if ( value === undefined || type === "boolean" ) {
 				className = getClass( this );
 				if ( className ) {
 
 					// store className if set
 					jQuery._data( this, "__className__", className );
 				}
 
 				// If the element has a class name or if we're passed "false",
 				// then remove the whole classname (if there was one, the above saved it).
 				// Otherwise bring back whatever was previously saved (if anything),
 				// falling back to the empty string if nothing was stored.
 				jQuery.attr( this, "class",
 					className || value === false ?
 					"" :
 					jQuery._data( this, "__className__" ) || ""
 				);
 			}
 		} );
 	},
 
 	hasClass: function( selector ) {
 		var className, elem,
 			i = 0;
 
 		className = " " + selector + " ";
 		while ( ( elem = this[ i++ ] ) ) {
 			if ( elem.nodeType === 1 &&
 				( " " + getClass( elem ) + " " ).replace( rclass, " " )
 					.indexOf( className ) > -1
 			) {
 				return true;
 			}
 		}
 
 		return false;
 	}
 } );
 
 
 
 
 // Return jQuery for attributes-only inclusion
 
 
 jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
 	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
 	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
 	function( i, name ) {
 
 	// Handle event binding
 	jQuery.fn[ name ] = function( data, fn ) {
 		return arguments.length > 0 ?
 			this.on( name, null, data, fn ) :
 			this.trigger( name );
 	};
 } );
 
 jQuery.fn.extend( {
 	hover: function( fnOver, fnOut ) {
 		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
 	}
 } );
 
 
 var location = window.location;
 
 var nonce = jQuery.now();
 
 var rquery = ( /\?/ );
 
 
 
 var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
 
 jQuery.parseJSON = function( data ) {
 
 	// Attempt to parse using the native JSON parser first
 	if ( window.JSON && window.JSON.parse ) {
 
 		// Support: Android 2.3
 		// Workaround failure to string-cast null input
 		return window.JSON.parse( data + "" );
 	}
 
 	var requireNonComma,
 		depth = null,
 		str = jQuery.trim( data + "" );
 
 	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
 	// after removing valid tokens
 	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {
 
 		// Force termination if we see a misplaced comma
 		if ( requireNonComma && comma ) {
 			depth = 0;
 		}
 
 		// Perform no more replacements after returning to outermost depth
 		if ( depth === 0 ) {
 			return token;
 		}
 
 		// Commas must not follow "[", "{", or ","
 		requireNonComma = open || comma;
 
 		// Determine new depth
 		// array/object open ("[" or "{"): depth += true - false (increment)
 		// array/object close ("]" or "}"): depth += false - true (decrement)
 		// other cases ("," or primitive): depth += true - true (numeric cast)
 		depth += !close - !open;
 
 		// Remove this token
 		return "";
 	} ) ) ?
 		( Function( "return " + str ) )() :
 		jQuery.error( "Invalid JSON: " + data );
 };
 
 
 // Cross-browser xml parsing
 jQuery.parseXML = function( data ) {
 	var xml, tmp;
 	if ( !data || typeof data !== "string" ) {
 		return null;
 	}
 	try {
 		if ( window.DOMParser ) { // Standard
 			tmp = new window.DOMParser();
 			xml = tmp.parseFromString( data, "text/xml" );
 		} else { // IE
 			xml = new window.ActiveXObject( "Microsoft.XMLDOM" );
 			xml.async = "false";
 			xml.loadXML( data );
 		}
 	} catch ( e ) {
 		xml = undefined;
 	}
 	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
 		jQuery.error( "Invalid XML: " + data );
 	}
 	return xml;
 };
 
 
 var
 	rhash = /#.*$/,
 	rts = /([?&])_=[^&]*/,
 
 	// IE leaves an \r character at EOL
 	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
 
 	// #7653, #8125, #8152: local protocol detection
 	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
 	rnoContent = /^(?:GET|HEAD)$/,
 	rprotocol = /^\/\//,
 	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
 
 	/* Prefilters
 	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
 	 * 2) These are called:
 	 *    - BEFORE asking for a transport
 	 *    - AFTER param serialization (s.data is a string if s.processData is true)
 	 * 3) key is the dataType
 	 * 4) the catchall symbol "*" can be used
 	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
 	 */
 	prefilters = {},
 
 	/* Transports bindings
 	 * 1) key is the dataType
 	 * 2) the catchall symbol "*" can be used
 	 * 3) selection will start with transport dataType and THEN go to "*" if needed
 	 */
 	transports = {},
 
 	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
 	allTypes = "*/".concat( "*" ),
 
 	// Document location
 	ajaxLocation = location.href,
 
 	// Segment location into parts
 	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
 
 // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
 function addToPrefiltersOrTransports( structure ) {
 
 	// dataTypeExpression is optional and defaults to "*"
 	return function( dataTypeExpression, func ) {
 
 		if ( typeof dataTypeExpression !== "string" ) {
 			func = dataTypeExpression;
 			dataTypeExpression = "*";
 		}
 
 		var dataType,
 			i = 0,
 			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
 
 		if ( jQuery.isFunction( func ) ) {
 
 			// For each dataType in the dataTypeExpression
 			while ( ( dataType = dataTypes[ i++ ] ) ) {
 
 				// Prepend if requested
 				if ( dataType.charAt( 0 ) === "+" ) {
 					dataType = dataType.slice( 1 ) || "*";
 					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
 
 				// Otherwise append
 				} else {
 					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
 				}
 			}
 		}
 	};
 }
 
 // Base inspection function for prefilters and transports
 function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
 
 	var inspected = {},
 		seekingTransport = ( structure === transports );
 
 	function inspect( dataType ) {
 		var selected;
 		inspected[ dataType ] = true;
 		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
 			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
 			if ( typeof dataTypeOrTransport === "string" &&
 				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
 
 				options.dataTypes.unshift( dataTypeOrTransport );
 				inspect( dataTypeOrTransport );
 				return false;
 			} else if ( seekingTransport ) {
 				return !( selected = dataTypeOrTransport );
 			}
 		} );
 		return selected;
 	}
 
 	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
 }
 
 // A special extend for ajax options
 // that takes "flat" options (not to be deep extended)
 // Fixes #9887
 function ajaxExtend( target, src ) {
 	var deep, key,
 		flatOptions = jQuery.ajaxSettings.flatOptions || {};
 
 	for ( key in src ) {
 		if ( src[ key ] !== undefined ) {
 			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
 		}
 	}
 	if ( deep ) {
 		jQuery.extend( true, target, deep );
 	}
 
 	return target;
 }
 
 /* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
 function ajaxHandleResponses( s, jqXHR, responses ) {
 	var firstDataType, ct, finalDataType, type,
 		contents = s.contents,
 		dataTypes = s.dataTypes;
 
 	// Remove auto dataType and get content-type in the process
 	while ( dataTypes[ 0 ] === "*" ) {
 		dataTypes.shift();
 		if ( ct === undefined ) {
 			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
 		}
 	}
 
 	// Check if we're dealing with a known content-type
 	if ( ct ) {
 		for ( type in contents ) {
 			if ( contents[ type ] && contents[ type ].test( ct ) ) {
 				dataTypes.unshift( type );
 				break;
 			}
 		}
 	}
 
 	// Check to see if we have a response for the expected dataType
 	if ( dataTypes[ 0 ] in responses ) {
 		finalDataType = dataTypes[ 0 ];
 	} else {
 
 		// Try convertible dataTypes
 		for ( type in responses ) {
 			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
 				finalDataType = type;
 				break;
 			}
 			if ( !firstDataType ) {
 				firstDataType = type;
 			}
 		}
 
 		// Or just use first one
 		finalDataType = finalDataType || firstDataType;
 	}
 
 	// If we found a dataType
 	// We add the dataType to the list if needed
 	// and return the corresponding response
 	if ( finalDataType ) {
 		if ( finalDataType !== dataTypes[ 0 ] ) {
 			dataTypes.unshift( finalDataType );
 		}
 		return responses[ finalDataType ];
 	}
 }
 
 /* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
 function ajaxConvert( s, response, jqXHR, isSuccess ) {
 	var conv2, current, conv, tmp, prev,
 		converters = {},
 
 		// Work with a copy of dataTypes in case we need to modify it for conversion
 		dataTypes = s.dataTypes.slice();
 
 	// Create converters map with lowercased keys
 	if ( dataTypes[ 1 ] ) {
 		for ( conv in s.converters ) {
 			converters[ conv.toLowerCase() ] = s.converters[ conv ];
 		}
 	}
 
 	current = dataTypes.shift();
 
 	// Convert to each sequential dataType
 	while ( current ) {
 
 		if ( s.responseFields[ current ] ) {
 			jqXHR[ s.responseFields[ current ] ] = response;
 		}
 
 		// Apply the dataFilter if provided
 		if ( !prev && isSuccess && s.dataFilter ) {
 			response = s.dataFilter( response, s.dataType );
 		}
 
 		prev = current;
 		current = dataTypes.shift();
 
 		if ( current ) {
 
 			// There's only work to do if current dataType is non-auto
 			if ( current === "*" ) {
 
 				current = prev;
 
 			// Convert response if prev dataType is non-auto and differs from current
 			} else if ( prev !== "*" && prev !== current ) {
 
 				// Seek a direct converter
 				conv = converters[ prev + " " + current ] || converters[ "* " + current ];
 
 				// If none found, seek a pair
 				if ( !conv ) {
 					for ( conv2 in converters ) {
 
 						// If conv2 outputs current
 						tmp = conv2.split( " " );
 						if ( tmp[ 1 ] === current ) {
 
 							// If prev can be converted to accepted input
 							conv = converters[ prev + " " + tmp[ 0 ] ] ||
 								converters[ "* " + tmp[ 0 ] ];
 							if ( conv ) {
 
 								// Condense equivalence converters
 								if ( conv === true ) {
 									conv = converters[ conv2 ];
 
 								// Otherwise, insert the intermediate dataType
 								} else if ( converters[ conv2 ] !== true ) {
 									current = tmp[ 0 ];
 									dataTypes.unshift( tmp[ 1 ] );
 								}
 								break;
 							}
 						}
 					}
 				}
 
 				// Apply converter (if not an equivalence)
 				if ( conv !== true ) {
 
 					// Unless errors are allowed to bubble, catch and return them
 					if ( conv && s[ "throws" ] ) { // jscs:ignore requireDotNotation
 						response = conv( response );
 					} else {
 						try {
 							response = conv( response );
 						} catch ( e ) {
 							return {
 								state: "parsererror",
 								error: conv ? e : "No conversion from " + prev + " to " + current
 							};
 						}
 					}
 				}
 			}
 		}
 	}
 
 	return { state: "success", data: response };
 }
 
 jQuery.extend( {
 
 	// Counter for holding the number of active queries
 	active: 0,
 
 	// Last-Modified header cache for next request
 	lastModified: {},
 	etag: {},
 
 	ajaxSettings: {
 		url: ajaxLocation,
 		type: "GET",
 		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
 		global: true,
 		processData: true,
 		async: true,
 		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
 		/*
 		timeout: 0,
 		data: null,
 		dataType: null,
 		username: null,
 		password: null,
 		cache: null,
 		throws: false,
 		traditional: false,
 		headers: {},
 		*/
 
 		accepts: {
 			"*": allTypes,
 			text: "text/plain",
 			html: "text/html",
 			xml: "application/xml, text/xml",
 			json: "application/json, text/javascript"
 		},
 
 		contents: {
 			xml: /\bxml\b/,
 			html: /\bhtml/,
 			json: /\bjson\b/
 		},
 
 		responseFields: {
 			xml: "responseXML",
 			text: "responseText",
 			json: "responseJSON"
 		},
 
 		// Data converters
 		// Keys separate source (or catchall "*") and destination types with a single space
 		converters: {
 
 			// Convert anything to text
 			"* text": String,
 
 			// Text to html (true = no transformation)
 			"text html": true,
 
 			// Evaluate text as a json expression
 			"text json": jQuery.parseJSON,
 
 			// Parse text as xml
 			"text xml": jQuery.parseXML
 		},
 
 		// For options that shouldn't be deep extended:
 		// you can add your own custom options here if
 		// and when you create one that shouldn't be
 		// deep extended (see ajaxExtend)
 		flatOptions: {
 			url: true,
 			context: true
 		}
 	},
 
 	// Creates a full fledged settings object into target
 	// with both ajaxSettings and settings fields.
 	// If target is omitted, writes into ajaxSettings.
 	ajaxSetup: function( target, settings ) {
 		return settings ?
 
 			// Building a settings object
 			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
 
 			// Extending ajaxSettings
 			ajaxExtend( jQuery.ajaxSettings, target );
 	},
 
 	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
 	ajaxTransport: addToPrefiltersOrTransports( transports ),
 
 	// Main method
 	ajax: function( url, options ) {
 
 		// If url is an object, simulate pre-1.5 signature
 		if ( typeof url === "object" ) {
 			options = url;
 			url = undefined;
 		}
 
 		// Force options to be an object
 		options = options || {};
 
 		var
 
 			// Cross-domain detection vars
 			parts,
 
 			// Loop variable
 			i,
 
 			// URL without anti-cache param
 			cacheURL,
 
 			// Response headers as string
 			responseHeadersString,
 
 			// timeout handle
 			timeoutTimer,
 
 			// To know if global events are to be dispatched
 			fireGlobals,
 
 			transport,
 
 			// Response headers
 			responseHeaders,
 
 			// Create the final options object
 			s = jQuery.ajaxSetup( {}, options ),
 
 			// Callbacks context
 			callbackContext = s.context || s,
 
 			// Context for global events is callbackContext if it is a DOM node or jQuery collection
 			globalEventContext = s.context &&
 				( callbackContext.nodeType || callbackContext.jquery ) ?
 					jQuery( callbackContext ) :
 					jQuery.event,
 
 			// Deferreds
 			deferred = jQuery.Deferred(),
 			completeDeferred = jQuery.Callbacks( "once memory" ),
 
 			// Status-dependent callbacks
 			statusCode = s.statusCode || {},
 
 			// Headers (they are sent all at once)
 			requestHeaders = {},
 			requestHeadersNames = {},
 
 			// The jqXHR state
 			state = 0,
 
 			// Default abort message
 			strAbort = "canceled",
 
 			// Fake xhr
 			jqXHR = {
 				readyState: 0,
 
 				// Builds headers hashtable if needed
 				getResponseHeader: function( key ) {
 					var match;
 					if ( state === 2 ) {
 						if ( !responseHeaders ) {
 							responseHeaders = {};
 							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
 								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
 							}
 						}
 						match = responseHeaders[ key.toLowerCase() ];
 					}
 					return match == null ? null : match;
 				},
 
 				// Raw string
 				getAllResponseHeaders: function() {
 					return state === 2 ? responseHeadersString : null;
 				},
 
 				// Caches the header
 				setRequestHeader: function( name, value ) {
 					var lname = name.toLowerCase();
 					if ( !state ) {
 						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
 						requestHeaders[ name ] = value;
 					}
 					return this;
 				},
 
 				// Overrides response content-type header
 				overrideMimeType: function( type ) {
 					if ( !state ) {
 						s.mimeType = type;
 					}
 					return this;
 				},
 
 				// Status-dependent callbacks
 				statusCode: function( map ) {
 					var code;
 					if ( map ) {
 						if ( state < 2 ) {
 							for ( code in map ) {
 
 								// Lazy-add the new callback in a way that preserves old ones
 								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
 							}
 						} else {
 
 							// Execute the appropriate callbacks
 							jqXHR.always( map[ jqXHR.status ] );
 						}
 					}
 					return this;
 				},
 
 				// Cancel the request
 				abort: function( statusText ) {
 					var finalText = statusText || strAbort;
 					if ( transport ) {
 						transport.abort( finalText );
 					}
 					done( 0, finalText );
 					return this;
 				}
 			};
 
 		// Attach deferreds
 		deferred.promise( jqXHR ).complete = completeDeferred.add;
 		jqXHR.success = jqXHR.done;
 		jqXHR.error = jqXHR.fail;
 
 		// Remove hash character (#7531: and string promotion)
 		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
 		// Handle falsy url in the settings object (#10093: consistency with old signature)
 		// We also use the url parameter if available
 		s.url = ( ( url || s.url || ajaxLocation ) + "" )
 			.replace( rhash, "" )
 			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
 
 		// Alias method option to type as per ticket #12004
 		s.type = options.method || options.type || s.method || s.type;
 
 		// Extract dataTypes list
 		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
 
 		// A cross-domain request is in order when we have a protocol:host:port mismatch
 		if ( s.crossDomain == null ) {
 			parts = rurl.exec( s.url.toLowerCase() );
 			s.crossDomain = !!( parts &&
 				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
 					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
 						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
 			);
 		}
 
 		// Convert data if not already a string
 		if ( s.data && s.processData && typeof s.data !== "string" ) {
 			s.data = jQuery.param( s.data, s.traditional );
 		}
 
 		// Apply prefilters
 		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
 
 		// If request was aborted inside a prefilter, stop there
 		if ( state === 2 ) {
 			return jqXHR;
 		}
 
 		// We can fire global events as of now if asked to
 		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
 		fireGlobals = jQuery.event && s.global;
 
 		// Watch for a new set of requests
 		if ( fireGlobals && jQuery.active++ === 0 ) {
 			jQuery.event.trigger( "ajaxStart" );
 		}
 
 		// Uppercase the type
 		s.type = s.type.toUpperCase();
 
 		// Determine if request has content
 		s.hasContent = !rnoContent.test( s.type );
 
 		// Save the URL in case we're toying with the If-Modified-Since
 		// and/or If-None-Match header later on
 		cacheURL = s.url;
 
 		// More options handling for requests with no content
 		if ( !s.hasContent ) {
 
 			// If data is available, append data to url
 			if ( s.data ) {
 				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
 
 				// #9682: remove data so that it's not used in an eventual retry
 				delete s.data;
 			}
 
 			// Add anti-cache in url if needed
 			if ( s.cache === false ) {
 				s.url = rts.test( cacheURL ) ?
 
 					// If there is already a '_' parameter, set its value
 					cacheURL.replace( rts, "$1_=" + nonce++ ) :
 
 					// Otherwise add one to the end
 					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
 			}
 		}
 
 		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
 		if ( s.ifModified ) {
 			if ( jQuery.lastModified[ cacheURL ] ) {
 				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
 			}
 			if ( jQuery.etag[ cacheURL ] ) {
 				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
 			}
 		}
 
 		// Set the correct header, if data is being sent
 		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
 			jqXHR.setRequestHeader( "Content-Type", s.contentType );
 		}
 
 		// Set the Accepts header for the server, depending on the dataType
 		jqXHR.setRequestHeader(
 			"Accept",
 			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
 				s.accepts[ s.dataTypes[ 0 ] ] +
 					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
 				s.accepts[ "*" ]
 		);
 
 		// Check for headers option
 		for ( i in s.headers ) {
 			jqXHR.setRequestHeader( i, s.headers[ i ] );
 		}
 
 		// Allow custom headers/mimetypes and early abort
 		if ( s.beforeSend &&
 			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
 
 			// Abort if not done already and return
 			return jqXHR.abort();
 		}
 
 		// aborting is no longer a cancellation
 		strAbort = "abort";
 
 		// Install callbacks on deferreds
 		for ( i in { success: 1, error: 1, complete: 1 } ) {
 			jqXHR[ i ]( s[ i ] );
 		}
 
 		// Get transport
 		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
 
 		// If no transport, we auto-abort
 		if ( !transport ) {
 			done( -1, "No Transport" );
 		} else {
 			jqXHR.readyState = 1;
 
 			// Send global event
 			if ( fireGlobals ) {
 				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
 			}
 
 			// If request was aborted inside ajaxSend, stop there
 			if ( state === 2 ) {
 				return jqXHR;
 			}
 
 			// Timeout
 			if ( s.async && s.timeout > 0 ) {
 				timeoutTimer = window.setTimeout( function() {
 					jqXHR.abort( "timeout" );
 				}, s.timeout );
 			}
 
 			try {
 				state = 1;
 				transport.send( requestHeaders, done );
 			} catch ( e ) {
 
 				// Propagate exception as error if not done
 				if ( state < 2 ) {
 					done( -1, e );
 
 				// Simply rethrow otherwise
 				} else {
 					throw e;
 				}
 			}
 		}
 
 		// Callback for when everything is done
 		function done( status, nativeStatusText, responses, headers ) {
 			var isSuccess, success, error, response, modified,
 				statusText = nativeStatusText;
 
 			// Called once
 			if ( state === 2 ) {
 				return;
 			}
 
 			// State is "done" now
 			state = 2;
 
 			// Clear timeout if it exists
 			if ( timeoutTimer ) {
 				window.clearTimeout( timeoutTimer );
 			}
 
 			// Dereference transport for early garbage collection
 			// (no matter how long the jqXHR object will be used)
 			transport = undefined;
 
 			// Cache response headers
 			responseHeadersString = headers || "";
 
 			// Set readyState
 			jqXHR.readyState = status > 0 ? 4 : 0;
 
 			// Determine if successful
 			isSuccess = status >= 200 && status < 300 || status === 304;
 
 			// Get response data
 			if ( responses ) {
 				response = ajaxHandleResponses( s, jqXHR, responses );
 			}
 
 			// Convert no matter what (that way responseXXX fields are always set)
 			response = ajaxConvert( s, response, jqXHR, isSuccess );
 
 			// If successful, handle type chaining
 			if ( isSuccess ) {
 
 				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
 				if ( s.ifModified ) {
 					modified = jqXHR.getResponseHeader( "Last-Modified" );
 					if ( modified ) {
 						jQuery.lastModified[ cacheURL ] = modified;
 					}
 					modified = jqXHR.getResponseHeader( "etag" );
 					if ( modified ) {
 						jQuery.etag[ cacheURL ] = modified;
 					}
 				}
 
 				// if no content
 				if ( status === 204 || s.type === "HEAD" ) {
 					statusText = "nocontent";
 
 				// if not modified
 				} else if ( status === 304 ) {
 					statusText = "notmodified";
 
 				// If we have data, let's convert it
 				} else {
 					statusText = response.state;
 					success = response.data;
 					error = response.error;
 					isSuccess = !error;
 				}
 			} else {
 
 				// We extract error from statusText
 				// then normalize statusText and status for non-aborts
 				error = statusText;
 				if ( status || !statusText ) {
 					statusText = "error";
 					if ( status < 0 ) {
 						status = 0;
 					}
 				}
 			}
 
 			// Set data for the fake xhr object
 			jqXHR.status = status;
 			jqXHR.statusText = ( nativeStatusText || statusText ) + "";
 
 			// Success/Error
 			if ( isSuccess ) {
 				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
 			} else {
 				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
 			}
 
 			// Status-dependent callbacks
 			jqXHR.statusCode( statusCode );
 			statusCode = undefined;
 
 			if ( fireGlobals ) {
 				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
 					[ jqXHR, s, isSuccess ? success : error ] );
 			}
 
 			// Complete
 			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
 
 			if ( fireGlobals ) {
 				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
 
 				// Handle the global AJAX counter
 				if ( !( --jQuery.active ) ) {
 					jQuery.event.trigger( "ajaxStop" );
 				}
 			}
 		}
 
 		return jqXHR;
 	},
 
 	getJSON: function( url, data, callback ) {
 		return jQuery.get( url, data, callback, "json" );
 	},
 
 	getScript: function( url, callback ) {
 		return jQuery.get( url, undefined, callback, "script" );
 	}
 } );
 
 jQuery.each( [ "get", "post" ], function( i, method ) {
 	jQuery[ method ] = function( url, data, callback, type ) {
 
 		// shift arguments if data argument was omitted
 		if ( jQuery.isFunction( data ) ) {
 			type = type || callback;
 			callback = data;
 			data = undefined;
 		}
 
 		// The url can be an options object (which then must have .url)
 		return jQuery.ajax( jQuery.extend( {
 			url: url,
 			type: method,
 			dataType: type,
 			data: data,
 			success: callback
 		}, jQuery.isPlainObject( url ) && url ) );
 	};
 } );
 
 
 jQuery._evalUrl = function( url ) {
 	return jQuery.ajax( {
 		url: url,
 
 		// Make this explicit, since user can override this through ajaxSetup (#11264)
 		type: "GET",
 		dataType: "script",
 		cache: true,
 		async: false,
 		global: false,
 		"throws": true
 	} );
 };
 
 
 jQuery.fn.extend( {
 	wrapAll: function( html ) {
 		if ( jQuery.isFunction( html ) ) {
 			return this.each( function( i ) {
 				jQuery( this ).wrapAll( html.call( this, i ) );
 			} );
 		}
 
 		if ( this[ 0 ] ) {
 
 			// The elements to wrap the target around
 			var wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
 
 			if ( this[ 0 ].parentNode ) {
 				wrap.insertBefore( this[ 0 ] );
 			}
 
 			wrap.map( function() {
 				var elem = this;
 
 				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
 					elem = elem.firstChild;
 				}
 
 				return elem;
 			} ).append( this );
 		}
 
 		return this;
 	},
 
 	wrapInner: function( html ) {
 		if ( jQuery.isFunction( html ) ) {
 			return this.each( function( i ) {
 				jQuery( this ).wrapInner( html.call( this, i ) );
 			} );
 		}
 
 		return this.each( function() {
 			var self = jQuery( this ),
 				contents = self.contents();
 
 			if ( contents.length ) {
 				contents.wrapAll( html );
 
 			} else {
 				self.append( html );
 			}
 		} );
 	},
 
 	wrap: function( html ) {
 		var isFunction = jQuery.isFunction( html );
 
 		return this.each( function( i ) {
 			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
 		} );
 	},
 
 	unwrap: function() {
 		return this.parent().each( function() {
 			if ( !jQuery.nodeName( this, "body" ) ) {
 				jQuery( this ).replaceWith( this.childNodes );
 			}
 		} ).end();
 	}
 } );
 
 
 function getDisplay( elem ) {
 	return elem.style && elem.style.display || jQuery.css( elem, "display" );
 }
 
 function filterHidden( elem ) {
 
 	// Disconnected elements are considered hidden
 	if ( !jQuery.contains( elem.ownerDocument || document, elem ) ) {
 		return true;
 	}
 	while ( elem && elem.nodeType === 1 ) {
 		if ( getDisplay( elem ) === "none" || elem.type === "hidden" ) {
 			return true;
 		}
 		elem = elem.parentNode;
 	}
 	return false;
 }
 
 jQuery.expr.filters.hidden = function( elem ) {
 
 	// Support: Opera <= 12.12
 	// Opera reports offsetWidths and offsetHeights less than zero on some elements
 	return support.reliableHiddenOffsets() ?
 		( elem.offsetWidth <= 0 && elem.offsetHeight <= 0 &&
 			!elem.getClientRects().length ) :
 			filterHidden( elem );
 };
 
 jQuery.expr.filters.visible = function( elem ) {
 	return !jQuery.expr.filters.hidden( elem );
 };
 
 
 
 
 var r20 = /%20/g,
 	rbracket = /\[\]$/,
 	rCRLF = /\r?\n/g,
 	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
 	rsubmittable = /^(?:input|select|textarea|keygen)/i;
 
 function buildParams( prefix, obj, traditional, add ) {
 	var name;
 
 	if ( jQuery.isArray( obj ) ) {
 
 		// Serialize array item.
 		jQuery.each( obj, function( i, v ) {
 			if ( traditional || rbracket.test( prefix ) ) {
 
 				// Treat each array item as a scalar.
 				add( prefix, v );
 
 			} else {
 
 				// Item is non-scalar (array or object), encode its numeric index.
 				buildParams(
 					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
 					v,
 					traditional,
 					add
 				);
 			}
 		} );
 
 	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
 
 		// Serialize object item.
 		for ( name in obj ) {
 			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
 		}
 
 	} else {
 
 		// Serialize scalar item.
 		add( prefix, obj );
 	}
 }
 
 // Serialize an array of form elements or a set of
 // key/values into a query string
 jQuery.param = function( a, traditional ) {
 	var prefix,
 		s = [],
 		add = function( key, value ) {
 
 			// If value is a function, invoke it and return its value
 			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
 			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
 		};
 
 	// Set traditional to true for jQuery <= 1.3.2 behavior.
 	if ( traditional === undefined ) {
 		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
 	}
 
 	// If an array was passed in, assume that it is an array of form elements.
 	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
 
 		// Serialize the form elements
 		jQuery.each( a, function() {
 			add( this.name, this.value );
 		} );
 
 	} else {
 
 		// If traditional, encode the "old" way (the way 1.3.2 or older
 		// did it), otherwise encode params recursively.
 		for ( prefix in a ) {
 			buildParams( prefix, a[ prefix ], traditional, add );
 		}
 	}
 
 	// Return the resulting serialization
 	return s.join( "&" ).replace( r20, "+" );
 };
 
 jQuery.fn.extend( {
 	serialize: function() {
 		return jQuery.param( this.serializeArray() );
 	},
 	serializeArray: function() {
 		return this.map( function() {
 
 			// Can add propHook for "elements" to filter or add form elements
 			var elements = jQuery.prop( this, "elements" );
 			return elements ? jQuery.makeArray( elements ) : this;
 		} )
 		.filter( function() {
 			var type = this.type;
 
 			// Use .is(":disabled") so that fieldset[disabled] works
 			return this.name && !jQuery( this ).is( ":disabled" ) &&
 				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
 				( this.checked || !rcheckableType.test( type ) );
 		} )
 		.map( function( i, elem ) {
 			var val = jQuery( this ).val();
 
 			return val == null ?
 				null :
 				jQuery.isArray( val ) ?
 					jQuery.map( val, function( val ) {
 						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
 					} ) :
 					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
 		} ).get();
 	}
 } );
 
 
 // Create the request object
 // (This is still attached to ajaxSettings for backward compatibility)
 jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
 
 	// Support: IE6-IE8
 	function() {
 
 		// XHR cannot access local files, always use ActiveX for that case
 		if ( this.isLocal ) {
 			return createActiveXHR();
 		}
 
 		// Support: IE 9-11
 		// IE seems to error on cross-domain PATCH requests when ActiveX XHR
 		// is used. In IE 9+ always use the native XHR.
 		// Note: this condition won't catch Edge as it doesn't define
 		// document.documentMode but it also doesn't support ActiveX so it won't
 		// reach this code.
 		if ( document.documentMode > 8 ) {
 			return createStandardXHR();
 		}
 
 		// Support: IE<9
 		// oldIE XHR does not support non-RFC2616 methods (#13240)
 		// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
 		// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
 		// Although this check for six methods instead of eight
 		// since IE also does not support "trace" and "connect"
 		return /^(get|post|head|put|delete|options)$/i.test( this.type ) &&
 			createStandardXHR() || createActiveXHR();
 	} :
 
 	// For all other browsers, use the standard XMLHttpRequest object
 	createStandardXHR;
 
 var xhrId = 0,
 	xhrCallbacks = {},
 	xhrSupported = jQuery.ajaxSettings.xhr();
 
 // Support: IE<10
 // Open requests must be manually aborted on unload (#5280)
 // See https://support.microsoft.com/kb/2856746 for more info
 if ( window.attachEvent ) {
 	window.attachEvent( "onunload", function() {
 		for ( var key in xhrCallbacks ) {
 			xhrCallbacks[ key ]( undefined, true );
 		}
 	} );
 }
 
 // Determine support properties
 support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
 xhrSupported = support.ajax = !!xhrSupported;
 
 // Create transport if the browser can provide an xhr
 if ( xhrSupported ) {
 
 	jQuery.ajaxTransport( function( options ) {
 
 		// Cross domain only allowed if supported through XMLHttpRequest
 		if ( !options.crossDomain || support.cors ) {
 
 			var callback;
 
 			return {
 				send: function( headers, complete ) {
 					var i,
 						xhr = options.xhr(),
 						id = ++xhrId;
 
 					// Open the socket
 					xhr.open(
 						options.type,
 						options.url,
 						options.async,
 						options.username,
 						options.password
 					);
 
 					// Apply custom fields if provided
 					if ( options.xhrFields ) {
 						for ( i in options.xhrFields ) {
 							xhr[ i ] = options.xhrFields[ i ];
 						}
 					}
 
 					// Override mime type if needed
 					if ( options.mimeType && xhr.overrideMimeType ) {
 						xhr.overrideMimeType( options.mimeType );
 					}
 
 					// X-Requested-With header
 					// For cross-domain requests, seeing as conditions for a preflight are
 					// akin to a jigsaw puzzle, we simply never set it to be sure.
 					// (it can always be set on a per-request basis or even using ajaxSetup)
 					// For same-domain requests, won't change header if already provided.
 					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
 						headers[ "X-Requested-With" ] = "XMLHttpRequest";
 					}
 
 					// Set headers
 					for ( i in headers ) {
 
 						// Support: IE<9
 						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
 						// request header to a null-value.
 						//
 						// To keep consistent with other XHR implementations, cast the value
 						// to string and ignore `undefined`.
 						if ( headers[ i ] !== undefined ) {
 							xhr.setRequestHeader( i, headers[ i ] + "" );
 						}
 					}
 
 					// Do send the request
 					// This may raise an exception which is actually
 					// handled in jQuery.ajax (so no try/catch here)
 					xhr.send( ( options.hasContent && options.data ) || null );
 
 					// Listener
 					callback = function( _, isAbort ) {
 						var status, statusText, responses;
 
 						// Was never called and is aborted or complete
 						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
 
 							// Clean up
 							delete xhrCallbacks[ id ];
 							callback = undefined;
 							xhr.onreadystatechange = jQuery.noop;
 
 							// Abort manually if needed
 							if ( isAbort ) {
 								if ( xhr.readyState !== 4 ) {
 									xhr.abort();
 								}
 							} else {
 								responses = {};
 								status = xhr.status;
 
 								// Support: IE<10
 								// Accessing binary-data responseText throws an exception
 								// (#11426)
 								if ( typeof xhr.responseText === "string" ) {
 									responses.text = xhr.responseText;
 								}
 
 								// Firefox throws an exception when accessing
 								// statusText for faulty cross-domain requests
 								try {
 									statusText = xhr.statusText;
 								} catch ( e ) {
 
 									// We normalize with Webkit giving an empty statusText
 									statusText = "";
 								}
 
 								// Filter status for non standard behaviors
 
 								// If the request is local and we have data: assume a success
 								// (success with no data won't get notified, that's the best we
 								// can do given current implementations)
 								if ( !status && options.isLocal && !options.crossDomain ) {
 									status = responses.text ? 200 : 404;
 
 								// IE - #1450: sometimes returns 1223 when it should be 204
 								} else if ( status === 1223 ) {
 									status = 204;
 								}
 							}
 						}
 
 						// Call complete if needed
 						if ( responses ) {
 							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
 						}
 					};
 
 					// Do send the request
 					// `xhr.send` may raise an exception, but it will be
 					// handled in jQuery.ajax (so no try/catch here)
 					if ( !options.async ) {
 
 						// If we're in sync mode we fire the callback
 						callback();
 					} else if ( xhr.readyState === 4 ) {
 
 						// (IE6 & IE7) if it's in cache and has been
 						// retrieved directly we need to fire the callback
 						window.setTimeout( callback );
 					} else {
 
 						// Register the callback, but delay it in case `xhr.send` throws
 						// Add to the list of active xhr callbacks
 						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
 					}
 				},
 
 				abort: function() {
 					if ( callback ) {
 						callback( undefined, true );
 					}
 				}
 			};
 		}
 	} );
 }
 
 // Functions to create xhrs
 function createStandardXHR() {
 	try {
 		return new window.XMLHttpRequest();
 	} catch ( e ) {}
 }
 
 function createActiveXHR() {
 	try {
 		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
 	} catch ( e ) {}
 }
 
 
 
 
 // Install script dataType
 jQuery.ajaxSetup( {
 	accepts: {
 		script: "text/javascript, application/javascript, " +
 			"application/ecmascript, application/x-ecmascript"
 	},
 	contents: {
 		script: /\b(?:java|ecma)script\b/
 	},
 	converters: {
 		"text script": function( text ) {
 			jQuery.globalEval( text );
 			return text;
 		}
 	}
 } );
 
 // Handle cache's special case and global
 jQuery.ajaxPrefilter( "script", function( s ) {
 	if ( s.cache === undefined ) {
 		s.cache = false;
 	}
 	if ( s.crossDomain ) {
 		s.type = "GET";
 		s.global = false;
 	}
 } );
 
 // Bind script tag hack transport
 jQuery.ajaxTransport( "script", function( s ) {
 
 	// This transport only deals with cross domain requests
 	if ( s.crossDomain ) {
 
 		var script,
 			head = document.head || jQuery( "head" )[ 0 ] || document.documentElement;
 
 		return {
 
 			send: function( _, callback ) {
 
 				script = document.createElement( "script" );
 
 				script.async = true;
 
 				if ( s.scriptCharset ) {
 					script.charset = s.scriptCharset;
 				}
 
 				script.src = s.url;
 
 				// Attach handlers for all browsers
 				script.onload = script.onreadystatechange = function( _, isAbort ) {
 
 					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
 
 						// Handle memory leak in IE
 						script.onload = script.onreadystatechange = null;
 
 						// Remove the script
 						if ( script.parentNode ) {
 							script.parentNode.removeChild( script );
 						}
 
 						// Dereference the script
 						script = null;
 
 						// Callback if not abort
 						if ( !isAbort ) {
 							callback( 200, "success" );
 						}
 					}
 				};
 
 				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
 				// Use native DOM manipulation to avoid our domManip AJAX trickery
 				head.insertBefore( script, head.firstChild );
 			},
 
 			abort: function() {
 				if ( script ) {
 					script.onload( undefined, true );
 				}
 			}
 		};
 	}
 } );
 
 
 
 
 var oldCallbacks = [],
 	rjsonp = /(=)\?(?=&|$)|\?\?/;
 
 // Default jsonp settings
 jQuery.ajaxSetup( {
 	jsonp: "callback",
 	jsonpCallback: function() {
 		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
 		this[ callback ] = true;
 		return callback;
 	}
 } );
 
 // Detect, normalize options and install callbacks for jsonp requests
 jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
 
 	var callbackName, overwritten, responseContainer,
 		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
 			"url" :
 			typeof s.data === "string" &&
 				( s.contentType || "" )
 					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
 				rjsonp.test( s.data ) && "data"
 		);
 
 	// Handle iff the expected data type is "jsonp" or we have a parameter to set
 	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
 
 		// Get callback name, remembering preexisting value associated with it
 		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
 			s.jsonpCallback() :
 			s.jsonpCallback;
 
 		// Insert callback into url or form data
 		if ( jsonProp ) {
 			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
 		} else if ( s.jsonp !== false ) {
 			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
 		}
 
 		// Use data converter to retrieve json after script execution
 		s.converters[ "script json" ] = function() {
 			if ( !responseContainer ) {
 				jQuery.error( callbackName + " was not called" );
 			}
 			return responseContainer[ 0 ];
 		};
 
 		// force json dataType
 		s.dataTypes[ 0 ] = "json";
 
 		// Install callback
 		overwritten = window[ callbackName ];
 		window[ callbackName ] = function() {
 			responseContainer = arguments;
 		};
 
 		// Clean-up function (fires after converters)
 		jqXHR.always( function() {
 
 			// If previous value didn't exist - remove it
 			if ( overwritten === undefined ) {
 				jQuery( window ).removeProp( callbackName );
 
 			// Otherwise restore preexisting value
 			} else {
 				window[ callbackName ] = overwritten;
 			}
 
 			// Save back as free
 			if ( s[ callbackName ] ) {
 
 				// make sure that re-using the options doesn't screw things around
 				s.jsonpCallback = originalSettings.jsonpCallback;
 
 				// save the callback name for future use
 				oldCallbacks.push( callbackName );
 			}
 
 			// Call if it was a function and we have a response
 			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
 				overwritten( responseContainer[ 0 ] );
 			}
 
 			responseContainer = overwritten = undefined;
 		} );
 
 		// Delegate to script
 		return "script";
 	}
 } );
 
 
 
 
 // data: string of html
 // context (optional): If specified, the fragment will be created in this context,
 // defaults to document
 // keepScripts (optional): If true, will include scripts passed in the html string
 jQuery.parseHTML = function( data, context, keepScripts ) {
 	if ( !data || typeof data !== "string" ) {
 		return null;
 	}
 	if ( typeof context === "boolean" ) {
 		keepScripts = context;
 		context = false;
 	}
 	context = context || document;
 
 	var parsed = rsingleTag.exec( data ),
 		scripts = !keepScripts && [];
 
 	// Single tag
 	if ( parsed ) {
 		return [ context.createElement( parsed[ 1 ] ) ];
 	}
 
 	parsed = buildFragment( [ data ], context, scripts );
 
 	if ( scripts && scripts.length ) {
 		jQuery( scripts ).remove();
 	}
 
 	return jQuery.merge( [], parsed.childNodes );
 };
 
 
 // Keep a copy of the old load method
 var _load = jQuery.fn.load;
 
 /**
  * Load a url into a page
  */
 jQuery.fn.load = function( url, params, callback ) {
 	if ( typeof url !== "string" && _load ) {
 		return _load.apply( this, arguments );
 	}
 
 	var selector, type, response,
 		self = this,
 		off = url.indexOf( " " );
 
 	if ( off > -1 ) {
 		selector = jQuery.trim( url.slice( off, url.length ) );
 		url = url.slice( 0, off );
 	}
 
 	// If it's a function
 	if ( jQuery.isFunction( params ) ) {
 
 		// We assume that it's the callback
 		callback = params;
 		params = undefined;
 
 	// Otherwise, build a param string
 	} else if ( params && typeof params === "object" ) {
 		type = "POST";
 	}
 
 	// If we have elements to modify, make the request
 	if ( self.length > 0 ) {
 		jQuery.ajax( {
 			url: url,
 
 			// If "type" variable is undefined, then "GET" method will be used.
 			// Make value of this field explicit since
 			// user can override it through ajaxSetup method
 			type: type || "GET",
 			dataType: "html",
 			data: params
 		} ).done( function( responseText ) {
 
 			// Save response for use in complete callback
 			response = arguments;
 
 			self.html( selector ?
 
 				// If a selector was specified, locate the right elements in a dummy div
 				// Exclude scripts to avoid IE 'Permission Denied' errors
 				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
 
 				// Otherwise use the full result
 				responseText );
 
 		// If the request succeeds, this function gets "data", "status", "jqXHR"
 		// but they are ignored because response was set above.
 		// If it fails, this function gets "jqXHR", "status", "error"
 		} ).always( callback && function( jqXHR, status ) {
 			self.each( function() {
 				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
 			} );
 		} );
 	}
 
 	return this;
 };
 
 
 
 
 // Attach a bunch of functions for handling common AJAX events
 jQuery.each( [
 	"ajaxStart",
 	"ajaxStop",
 	"ajaxComplete",
 	"ajaxError",
 	"ajaxSuccess",
 	"ajaxSend"
 ], function( i, type ) {
 	jQuery.fn[ type ] = function( fn ) {
 		return this.on( type, fn );
 	};
 } );
 
 
 
 
 jQuery.expr.filters.animated = function( elem ) {
 	return jQuery.grep( jQuery.timers, function( fn ) {
 		return elem === fn.elem;
 	} ).length;
 };
 
 
 
 
 
 /**
  * Gets a window from an element
  */
 function getWindow( elem ) {
 	return jQuery.isWindow( elem ) ?
 		elem :
 		elem.nodeType === 9 ?
 			elem.defaultView || elem.parentWindow :
 			false;
 }
 
 jQuery.offset = {
 	setOffset: function( elem, options, i ) {
 		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
 			position = jQuery.css( elem, "position" ),
 			curElem = jQuery( elem ),
 			props = {};
 
 		// set position first, in-case top/left are set even on static elem
 		if ( position === "static" ) {
 			elem.style.position = "relative";
 		}
 
 		curOffset = curElem.offset();
 		curCSSTop = jQuery.css( elem, "top" );
 		curCSSLeft = jQuery.css( elem, "left" );
 		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
 			jQuery.inArray( "auto", [ curCSSTop, curCSSLeft ] ) > -1;
 
 		// need to be able to calculate position if either top or left
 		// is auto and position is either absolute or fixed
 		if ( calculatePosition ) {
 			curPosition = curElem.position();
 			curTop = curPosition.top;
 			curLeft = curPosition.left;
 		} else {
 			curTop = parseFloat( curCSSTop ) || 0;
 			curLeft = parseFloat( curCSSLeft ) || 0;
 		}
 
 		if ( jQuery.isFunction( options ) ) {
 
 			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
 			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
 		}
 
 		if ( options.top != null ) {
 			props.top = ( options.top - curOffset.top ) + curTop;
 		}
 		if ( options.left != null ) {
 			props.left = ( options.left - curOffset.left ) + curLeft;
 		}
 
 		if ( "using" in options ) {
 			options.using.call( elem, props );
 		} else {
 			curElem.css( props );
 		}
 	}
 };
 
 jQuery.fn.extend( {
 	offset: function( options ) {
 		if ( arguments.length ) {
 			return options === undefined ?
 				this :
 				this.each( function( i ) {
 					jQuery.offset.setOffset( this, options, i );
 				} );
 		}
 
 		var docElem, win,
 			box = { top: 0, left: 0 },
 			elem = this[ 0 ],
 			doc = elem && elem.ownerDocument;
 
 		if ( !doc ) {
 			return;
 		}
 
 		docElem = doc.documentElement;
 
 		// Make sure it's not a disconnected DOM node
 		if ( !jQuery.contains( docElem, elem ) ) {
 			return box;
 		}
 
 		// If we don't have gBCR, just use 0,0 rather than error
 		// BlackBerry 5, iOS 3 (original iPhone)
 		if ( typeof elem.getBoundingClientRect !== "undefined" ) {
 			box = elem.getBoundingClientRect();
 		}
 		win = getWindow( doc );
 		return {
 			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
 			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
 		};
 	},
 
 	position: function() {
 		if ( !this[ 0 ] ) {
 			return;
 		}
 
 		var offsetParent, offset,
 			parentOffset = { top: 0, left: 0 },
 			elem = this[ 0 ];
 
 		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
 		// because it is its only offset parent
 		if ( jQuery.css( elem, "position" ) === "fixed" ) {
 
 			// we assume that getBoundingClientRect is available when computed position is fixed
 			offset = elem.getBoundingClientRect();
 		} else {
 
 			// Get *real* offsetParent
 			offsetParent = this.offsetParent();
 
 			// Get correct offsets
 			offset = this.offset();
 			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
 				parentOffset = offsetParent.offset();
 			}
 
 			// Add offsetParent borders
 			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
 			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
 		}
 
 		// Subtract parent offsets and element margins
 		// note: when an element has margin: auto the offsetLeft and marginLeft
 		// are the same in Safari causing offset.left to incorrectly be 0
 		return {
 			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
 			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
 		};
 	},
 
 	offsetParent: function() {
 		return this.map( function() {
 			var offsetParent = this.offsetParent;
 
 			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) &&
 				jQuery.css( offsetParent, "position" ) === "static" ) ) {
 				offsetParent = offsetParent.offsetParent;
 			}
 			return offsetParent || documentElement;
 		} );
 	}
 } );
 
 // Create scrollLeft and scrollTop methods
 jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
 	var top = /Y/.test( prop );
 
 	jQuery.fn[ method ] = function( val ) {
 		return access( this, function( elem, method, val ) {
 			var win = getWindow( elem );
 
 			if ( val === undefined ) {
 				return win ? ( prop in win ) ? win[ prop ] :
 					win.document.documentElement[ method ] :
 					elem[ method ];
 			}
 
 			if ( win ) {
 				win.scrollTo(
 					!top ? val : jQuery( win ).scrollLeft(),
 					top ? val : jQuery( win ).scrollTop()
 				);
 
 			} else {
 				elem[ method ] = val;
 			}
 		}, method, val, arguments.length, null );
 	};
 } );
 
 // Support: Safari<7-8+, Chrome<37-44+
 // Add the top/left cssHooks using jQuery.fn.position
 // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
 // getComputedStyle returns percent when specified for top/left/bottom/right
 // rather than make the css module depend on the offset module, we just check for it here
 jQuery.each( [ "top", "left" ], function( i, prop ) {
 	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
 		function( elem, computed ) {
 			if ( computed ) {
 				computed = curCSS( elem, prop );
 
 				// if curCSS returns percentage, fallback to offset
 				return rnumnonpx.test( computed ) ?
 					jQuery( elem ).position()[ prop ] + "px" :
 					computed;
 			}
 		}
 	);
 } );
 
 
 // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
 jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
 	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
 	function( defaultExtra, funcName ) {
 
 		// margin is only for outerHeight, outerWidth
 		jQuery.fn[ funcName ] = function( margin, value ) {
 			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
 				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
 
 			return access( this, function( elem, type, value ) {
 				var doc;
 
 				if ( jQuery.isWindow( elem ) ) {
 
 					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
 					// isn't a whole lot we can do. See pull request at this URL for discussion:
 					// https://github.com/jquery/jquery/pull/764
 					return elem.document.documentElement[ "client" + name ];
 				}
 
 				// Get document width or height
 				if ( elem.nodeType === 9 ) {
 					doc = elem.documentElement;
 
 					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
 					// whichever is greatest
 					// unfortunately, this causes bug #3838 in IE6/8 only,
 					// but there is currently no good, small way to fix it.
 					return Math.max(
 						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
 						elem.body[ "offset" + name ], doc[ "offset" + name ],
 						doc[ "client" + name ]
 					);
 				}
 
 				return value === undefined ?
 
 					// Get width or height on the element, requesting but not forcing parseFloat
 					jQuery.css( elem, type, extra ) :
 
 					// Set width or height on the element
 					jQuery.style( elem, type, value, extra );
 			}, type, chainable ? margin : undefined, chainable, null );
 		};
 	} );
 } );
 
 
 jQuery.fn.extend( {
 
 	bind: function( types, data, fn ) {
 		return this.on( types, null, data, fn );
 	},
 	unbind: function( types, fn ) {
 		return this.off( types, null, fn );
 	},
 
 	delegate: function( selector, types, data, fn ) {
 		return this.on( types, selector, data, fn );
 	},
 	undelegate: function( selector, types, fn ) {
 
 		// ( namespace ) or ( selector, types [, fn] )
 		return arguments.length === 1 ?
 			this.off( selector, "**" ) :
 			this.off( types, selector || "**", fn );
 	}
 } );
 
 // The number of elements contained in the matched element set
 jQuery.fn.size = function() {
 	return this.length;
 };
 
 jQuery.fn.andSelf = jQuery.fn.addBack;
 
 
 
 
 // Register as a named AMD module, since jQuery can be concatenated with other
 // files that may use define, but not via a proper concatenation script that
 // understands anonymous AMD modules. A named AMD is safest and most robust
 // way to register. Lowercase jquery is used because AMD module names are
 // derived from file names, and jQuery is normally delivered in a lowercase
 // file name. Do this after creating the global so that if an AMD module wants
 // to call noConflict to hide this version of jQuery, it will work.
 
 // Note that for maximum portability, libraries that are not jQuery should
 // declare themselves as anonymous modules, and avoid setting a global if an
 // AMD loader is present. jQuery is a special case. For more information, see
 // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
 
 if ( typeof define === "function" && define.amd ) {
 	define( "jquery", [], function() {
 		return jQuery;
 	} );
 }
 
 
 
 var
 
 	// Map over jQuery in case of overwrite
 	_jQuery = window.jQuery,
 
 	// Map over the $ in case of overwrite
 	_$ = window.$;
 
 jQuery.noConflict = function( deep ) {
 	if ( window.$ === jQuery ) {
 		window.$ = _$;
 	}
 
 	if ( deep && window.jQuery === jQuery ) {
 		window.jQuery = _jQuery;
 	}
 
 	return jQuery;
 };
 
 // Expose jQuery and $ identifiers, even in
 // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
 // and CommonJS for browser emulators (#13566)
 if ( !noGlobal ) {
 	window.jQuery = window.$ = jQuery;
 }
 
 return jQuery;
 }));
 </script>  
<script type="text/javascript">  
 /*!
  DataTables 1.10.15
  2008-2017 SpryMedia Ltd - datatables.net/license
 */
 (function(h){"function"===typeof define&&define.amd?define(["jquery"],function(E){return h(E,window,document)}):"object"===typeof exports?module.exports=function(E,H){E||(E=window);H||(H="undefined"!==typeof window?require("jquery"):require("jquery")(E));return h(H,E,E.document)}:h(jQuery,window,document)})(function(h,E,H,k){function Y(a){var b,c,d={};h.each(a,function(e){if((b=e.match(/^([^A-Z]+?)([A-Z])/))&&-1!=="a aa ai ao as b fn i m o s ".indexOf(b[1]+" "))c=e.replace(b[0],b[2].toLowerCase()),
 d[c]=e,"o"===b[1]&&Y(a[e])});a._hungarianMap=d}function J(a,b,c){a._hungarianMap||Y(a);var d;h.each(b,function(e){d=a._hungarianMap[e];if(d!==k&&(c||b[d]===k))"o"===d.charAt(0)?(b[d]||(b[d]={}),h.extend(!0,b[d],b[e]),J(a[d],b[d],c)):b[d]=b[e]})}function Fa(a){var b=m.defaults.oLanguage,c=a.sZeroRecords;!a.sEmptyTable&&(c&&"No data available in table"===b.sEmptyTable)&&F(a,a,"sZeroRecords","sEmptyTable");!a.sLoadingRecords&&(c&&"Loading..."===b.sLoadingRecords)&&F(a,a,"sZeroRecords","sLoadingRecords");
 a.sInfoThousands&&(a.sThousands=a.sInfoThousands);(a=a.sDecimal)&&fb(a)}function gb(a){A(a,"ordering","bSort");A(a,"orderMulti","bSortMulti");A(a,"orderClasses","bSortClasses");A(a,"orderCellsTop","bSortCellsTop");A(a,"order","aaSorting");A(a,"orderFixed","aaSortingFixed");A(a,"paging","bPaginate");A(a,"pagingType","sPaginationType");A(a,"pageLength","iDisplayLength");A(a,"searching","bFilter");"boolean"===typeof a.sScrollX&&(a.sScrollX=a.sScrollX?"100%":"");"boolean"===typeof a.scrollX&&(a.scrollX=
 a.scrollX?"100%":"");if(a=a.aoSearchCols)for(var b=0,c=a.length;b<c;b++)a[b]&&J(m.models.oSearch,a[b])}function hb(a){A(a,"orderable","bSortable");A(a,"orderData","aDataSort");A(a,"orderSequence","asSorting");A(a,"orderDataType","sortDataType");var b=a.aDataSort;"number"===typeof b&&!h.isArray(b)&&(a.aDataSort=[b])}function ib(a){if(!m.__browser){var b={};m.__browser=b;var c=h("<div/>").css({position:"fixed",top:0,left:-1*h(E).scrollLeft(),height:1,width:1,overflow:"hidden"}).append(h("<div/>").css({position:"absolute",
 top:1,left:1,width:100,overflow:"scroll"}).append(h("<div/>").css({width:"100%",height:10}))).appendTo("body"),d=c.children(),e=d.children();b.barWidth=d[0].offsetWidth-d[0].clientWidth;b.bScrollOversize=100===e[0].offsetWidth&&100!==d[0].clientWidth;b.bScrollbarLeft=1!==Math.round(e.offset().left);b.bBounding=c[0].getBoundingClientRect().width?!0:!1;c.remove()}h.extend(a.oBrowser,m.__browser);a.oScroll.iBarWidth=m.__browser.barWidth}function jb(a,b,c,d,e,f){var g,j=!1;c!==k&&(g=c,j=!0);for(;d!==
 e;)a.hasOwnProperty(d)&&(g=j?b(g,a[d],d,a):a[d],j=!0,d+=f);return g}function Ga(a,b){var c=m.defaults.column,d=a.aoColumns.length,c=h.extend({},m.models.oColumn,c,{nTh:b?b:H.createElement("th"),sTitle:c.sTitle?c.sTitle:b?b.innerHTML:"",aDataSort:c.aDataSort?c.aDataSort:[d],mData:c.mData?c.mData:d,idx:d});a.aoColumns.push(c);c=a.aoPreSearchCols;c[d]=h.extend({},m.models.oSearch,c[d]);la(a,d,h(b).data())}function la(a,b,c){var b=a.aoColumns[b],d=a.oClasses,e=h(b.nTh);if(!b.sWidthOrig){b.sWidthOrig=
 e.attr("width")||null;var f=(e.attr("style")||"").match(/width:\s*(\d+[pxem%]+)/);f&&(b.sWidthOrig=f[1])}c!==k&&null!==c&&(hb(c),J(m.defaults.column,c),c.mDataProp!==k&&!c.mData&&(c.mData=c.mDataProp),c.sType&&(b._sManualType=c.sType),c.className&&!c.sClass&&(c.sClass=c.className),h.extend(b,c),F(b,c,"sWidth","sWidthOrig"),c.iDataSort!==k&&(b.aDataSort=[c.iDataSort]),F(b,c,"aDataSort"));var g=b.mData,j=R(g),i=b.mRender?R(b.mRender):null,c=function(a){return"string"===typeof a&&-1!==a.indexOf("@")};
 b._bAttrSrc=h.isPlainObject(g)&&(c(g.sort)||c(g.type)||c(g.filter));b._setter=null;b.fnGetData=function(a,b,c){var d=j(a,b,k,c);return i&&b?i(d,b,a,c):d};b.fnSetData=function(a,b,c){return S(g)(a,b,c)};"number"!==typeof g&&(a._rowReadObject=!0);a.oFeatures.bSort||(b.bSortable=!1,e.addClass(d.sSortableNone));a=-1!==h.inArray("asc",b.asSorting);c=-1!==h.inArray("desc",b.asSorting);!b.bSortable||!a&&!c?(b.sSortingClass=d.sSortableNone,b.sSortingClassJUI=""):a&&!c?(b.sSortingClass=d.sSortableAsc,b.sSortingClassJUI=
 d.sSortJUIAscAllowed):!a&&c?(b.sSortingClass=d.sSortableDesc,b.sSortingClassJUI=d.sSortJUIDescAllowed):(b.sSortingClass=d.sSortable,b.sSortingClassJUI=d.sSortJUI)}function Z(a){if(!1!==a.oFeatures.bAutoWidth){var b=a.aoColumns;Ha(a);for(var c=0,d=b.length;c<d;c++)b[c].nTh.style.width=b[c].sWidth}b=a.oScroll;(""!==b.sY||""!==b.sX)&&ma(a);s(a,null,"column-sizing",[a])}function $(a,b){var c=na(a,"bVisible");return"number"===typeof c[b]?c[b]:null}function aa(a,b){var c=na(a,"bVisible"),c=h.inArray(b,
 c);return-1!==c?c:null}function ba(a){var b=0;h.each(a.aoColumns,function(a,d){d.bVisible&&"none"!==h(d.nTh).css("display")&&b++});return b}function na(a,b){var c=[];h.map(a.aoColumns,function(a,e){a[b]&&c.push(e)});return c}function Ia(a){var b=a.aoColumns,c=a.aoData,d=m.ext.type.detect,e,f,g,j,i,h,l,q,r;e=0;for(f=b.length;e<f;e++)if(l=b[e],r=[],!l.sType&&l._sManualType)l.sType=l._sManualType;else if(!l.sType){g=0;for(j=d.length;g<j;g++){i=0;for(h=c.length;i<h;i++){r[i]===k&&(r[i]=B(a,i,e,"type"));
 q=d[g](r[i],a);if(!q&&g!==d.length-1)break;if("html"===q)break}if(q){l.sType=q;break}}l.sType||(l.sType="string")}}function kb(a,b,c,d){var e,f,g,j,i,n,l=a.aoColumns;if(b)for(e=b.length-1;0<=e;e--){n=b[e];var q=n.targets!==k?n.targets:n.aTargets;h.isArray(q)||(q=[q]);f=0;for(g=q.length;f<g;f++)if("number"===typeof q[f]&&0<=q[f]){for(;l.length<=q[f];)Ga(a);d(q[f],n)}else if("number"===typeof q[f]&&0>q[f])d(l.length+q[f],n);else if("string"===typeof q[f]){j=0;for(i=l.length;j<i;j++)("_all"==q[f]||h(l[j].nTh).hasClass(q[f]))&&
 d(j,n)}}if(c){e=0;for(a=c.length;e<a;e++)d(e,c[e])}}function N(a,b,c,d){var e=a.aoData.length,f=h.extend(!0,{},m.models.oRow,{src:c?"dom":"data",idx:e});f._aData=b;a.aoData.push(f);for(var g=a.aoColumns,j=0,i=g.length;j<i;j++)g[j].sType=null;a.aiDisplayMaster.push(e);b=a.rowIdFn(b);b!==k&&(a.aIds[b]=f);(c||!a.oFeatures.bDeferRender)&&Ja(a,e,c,d);return e}function oa(a,b){var c;b instanceof h||(b=h(b));return b.map(function(b,e){c=Ka(a,e);return N(a,c.data,e,c.cells)})}function B(a,b,c,d){var e=a.iDraw,
 f=a.aoColumns[c],g=a.aoData[b]._aData,j=f.sDefaultContent,i=f.fnGetData(g,d,{settings:a,row:b,col:c});if(i===k)return a.iDrawError!=e&&null===j&&(K(a,0,"Requested unknown parameter "+("function"==typeof f.mData?"{function}":"'"+f.mData+"'")+" for row "+b+", column "+c,4),a.iDrawError=e),j;if((i===g||null===i)&&null!==j&&d!==k)i=j;else if("function"===typeof i)return i.call(g);return null===i&&"display"==d?"":i}function lb(a,b,c,d){a.aoColumns[c].fnSetData(a.aoData[b]._aData,d,{settings:a,row:b,col:c})}
 function La(a){return h.map(a.match(/(\\.|[^\.])+/g)||[""],function(a){return a.replace(/\\\./g,".")})}function R(a){if(h.isPlainObject(a)){var b={};h.each(a,function(a,c){c&&(b[a]=R(c))});return function(a,c,f,g){var j=b[c]||b._;return j!==k?j(a,c,f,g):a}}if(null===a)return function(a){return a};if("function"===typeof a)return function(b,c,f,g){return a(b,c,f,g)};if("string"===typeof a&&(-1!==a.indexOf(".")||-1!==a.indexOf("[")||-1!==a.indexOf("("))){var c=function(a,b,f){var g,j;if(""!==f){j=La(f);
 for(var i=0,n=j.length;i<n;i++){f=j[i].match(ca);g=j[i].match(V);if(f){j[i]=j[i].replace(ca,"");""!==j[i]&&(a=a[j[i]]);g=[];j.splice(0,i+1);j=j.join(".");if(h.isArray(a)){i=0;for(n=a.length;i<n;i++)g.push(c(a[i],b,j))}a=f[0].substring(1,f[0].length-1);a=""===a?g:g.join(a);break}else if(g){j[i]=j[i].replace(V,"");a=a[j[i]]();continue}if(null===a||a[j[i]]===k)return k;a=a[j[i]]}}return a};return function(b,e){return c(b,e,a)}}return function(b){return b[a]}}function S(a){if(h.isPlainObject(a))return S(a._);
 if(null===a)return function(){};if("function"===typeof a)return function(b,d,e){a(b,"set",d,e)};if("string"===typeof a&&(-1!==a.indexOf(".")||-1!==a.indexOf("[")||-1!==a.indexOf("("))){var b=function(a,d,e){var e=La(e),f;f=e[e.length-1];for(var g,j,i=0,n=e.length-1;i<n;i++){g=e[i].match(ca);j=e[i].match(V);if(g){e[i]=e[i].replace(ca,"");a[e[i]]=[];f=e.slice();f.splice(0,i+1);g=f.join(".");if(h.isArray(d)){j=0;for(n=d.length;j<n;j++)f={},b(f,d[j],g),a[e[i]].push(f)}else a[e[i]]=d;return}j&&(e[i]=e[i].replace(V,
 ""),a=a[e[i]](d));if(null===a[e[i]]||a[e[i]]===k)a[e[i]]={};a=a[e[i]]}if(f.match(V))a[f.replace(V,"")](d);else a[f.replace(ca,"")]=d};return function(c,d){return b(c,d,a)}}return function(b,d){b[a]=d}}function Ma(a){return D(a.aoData,"_aData")}function pa(a){a.aoData.length=0;a.aiDisplayMaster.length=0;a.aiDisplay.length=0;a.aIds={}}function qa(a,b,c){for(var d=-1,e=0,f=a.length;e<f;e++)a[e]==b?d=e:a[e]>b&&a[e]--; -1!=d&&c===k&&a.splice(d,1)}function da(a,b,c,d){var e=a.aoData[b],f,g=function(c,d){for(;c.childNodes.length;)c.removeChild(c.firstChild);
 c.innerHTML=B(a,b,d,"display")};if("dom"===c||(!c||"auto"===c)&&"dom"===e.src)e._aData=Ka(a,e,d,d===k?k:e._aData).data;else{var j=e.anCells;if(j)if(d!==k)g(j[d],d);else{c=0;for(f=j.length;c<f;c++)g(j[c],c)}}e._aSortData=null;e._aFilterData=null;g=a.aoColumns;if(d!==k)g[d].sType=null;else{c=0;for(f=g.length;c<f;c++)g[c].sType=null;Na(a,e)}}function Ka(a,b,c,d){var e=[],f=b.firstChild,g,j,i=0,n,l=a.aoColumns,q=a._rowReadObject,d=d!==k?d:q?{}:[],r=function(a,b){if("string"===typeof a){var c=a.indexOf("@");
 -1!==c&&(c=a.substring(c+1),S(a)(d,b.getAttribute(c)))}},m=function(a){if(c===k||c===i)j=l[i],n=h.trim(a.innerHTML),j&&j._bAttrSrc?(S(j.mData._)(d,n),r(j.mData.sort,a),r(j.mData.type,a),r(j.mData.filter,a)):q?(j._setter||(j._setter=S(j.mData)),j._setter(d,n)):d[i]=n;i++};if(f)for(;f;){g=f.nodeName.toUpperCase();if("TD"==g||"TH"==g)m(f),e.push(f);f=f.nextSibling}else{e=b.anCells;f=0;for(g=e.length;f<g;f++)m(e[f])}if(b=b.firstChild?b:b.nTr)(b=b.getAttribute("id"))&&S(a.rowId)(d,b);return{data:d,cells:e}}
 function Ja(a,b,c,d){var e=a.aoData[b],f=e._aData,g=[],j,i,n,l,q;if(null===e.nTr){j=c||H.createElement("tr");e.nTr=j;e.anCells=g;j._DT_RowIndex=b;Na(a,e);l=0;for(q=a.aoColumns.length;l<q;l++){n=a.aoColumns[l];i=c?d[l]:H.createElement(n.sCellType);i._DT_CellIndex={row:b,column:l};g.push(i);if((!c||n.mRender||n.mData!==l)&&(!h.isPlainObject(n.mData)||n.mData._!==l+".display"))i.innerHTML=B(a,b,l,"display");n.sClass&&(i.className+=" "+n.sClass);n.bVisible&&!c?j.appendChild(i):!n.bVisible&&c&&i.parentNode.removeChild(i);
 n.fnCreatedCell&&n.fnCreatedCell.call(a.oInstance,i,B(a,b,l),f,b,l)}s(a,"aoRowCreatedCallback",null,[j,f,b])}e.nTr.setAttribute("role","row")}function Na(a,b){var c=b.nTr,d=b._aData;if(c){var e=a.rowIdFn(d);e&&(c.id=e);d.DT_RowClass&&(e=d.DT_RowClass.split(" "),b.__rowc=b.__rowc?sa(b.__rowc.concat(e)):e,h(c).removeClass(b.__rowc.join(" ")).addClass(d.DT_RowClass));d.DT_RowAttr&&h(c).attr(d.DT_RowAttr);d.DT_RowData&&h(c).data(d.DT_RowData)}}function mb(a){var b,c,d,e,f,g=a.nTHead,j=a.nTFoot,i=0===
 h("th, td",g).length,n=a.oClasses,l=a.aoColumns;i&&(e=h("<tr/>").appendTo(g));b=0;for(c=l.length;b<c;b++)f=l[b],d=h(f.nTh).addClass(f.sClass),i&&d.appendTo(e),a.oFeatures.bSort&&(d.addClass(f.sSortingClass),!1!==f.bSortable&&(d.attr("tabindex",a.iTabIndex).attr("aria-controls",a.sTableId),Oa(a,f.nTh,b))),f.sTitle!=d[0].innerHTML&&d.html(f.sTitle),Pa(a,"header")(a,d,f,n);i&&ea(a.aoHeader,g);h(g).find(">tr").attr("role","row");h(g).find(">tr>th, >tr>td").addClass(n.sHeaderTH);h(j).find(">tr>th, >tr>td").addClass(n.sFooterTH);
 if(null!==j){a=a.aoFooter[0];b=0;for(c=a.length;b<c;b++)f=l[b],f.nTf=a[b].cell,f.sClass&&h(f.nTf).addClass(f.sClass)}}function fa(a,b,c){var d,e,f,g=[],j=[],i=a.aoColumns.length,n;if(b){c===k&&(c=!1);d=0;for(e=b.length;d<e;d++){g[d]=b[d].slice();g[d].nTr=b[d].nTr;for(f=i-1;0<=f;f--)!a.aoColumns[f].bVisible&&!c&&g[d].splice(f,1);j.push([])}d=0;for(e=g.length;d<e;d++){if(a=g[d].nTr)for(;f=a.firstChild;)a.removeChild(f);f=0;for(b=g[d].length;f<b;f++)if(n=i=1,j[d][f]===k){a.appendChild(g[d][f].cell);
 for(j[d][f]=1;g[d+i]!==k&&g[d][f].cell==g[d+i][f].cell;)j[d+i][f]=1,i++;for(;g[d][f+n]!==k&&g[d][f].cell==g[d][f+n].cell;){for(c=0;c<i;c++)j[d+c][f+n]=1;n++}h(g[d][f].cell).attr("rowspan",i).attr("colspan",n)}}}}function O(a){var b=s(a,"aoPreDrawCallback","preDraw",[a]);if(-1!==h.inArray(!1,b))C(a,!1);else{var b=[],c=0,d=a.asStripeClasses,e=d.length,f=a.oLanguage,g=a.iInitDisplayStart,j="ssp"==y(a),i=a.aiDisplay;a.bDrawing=!0;g!==k&&-1!==g&&(a._iDisplayStart=j?g:g>=a.fnRecordsDisplay()?0:g,a.iInitDisplayStart=
 -1);var g=a._iDisplayStart,n=a.fnDisplayEnd();if(a.bDeferLoading)a.bDeferLoading=!1,a.iDraw++,C(a,!1);else if(j){if(!a.bDestroying&&!nb(a))return}else a.iDraw++;if(0!==i.length){f=j?a.aoData.length:n;for(j=j?0:g;j<f;j++){var l=i[j],q=a.aoData[l];null===q.nTr&&Ja(a,l);l=q.nTr;if(0!==e){var r=d[c%e];q._sRowStripe!=r&&(h(l).removeClass(q._sRowStripe).addClass(r),q._sRowStripe=r)}s(a,"aoRowCallback",null,[l,q._aData,c,j]);b.push(l);c++}}else c=f.sZeroRecords,1==a.iDraw&&"ajax"==y(a)?c=f.sLoadingRecords:
 f.sEmptyTable&&0===a.fnRecordsTotal()&&(c=f.sEmptyTable),b[0]=h("<tr/>",{"class":e?d[0]:""}).append(h("<td />",{valign:"top",colSpan:ba(a),"class":a.oClasses.sRowEmpty}).html(c))[0];s(a,"aoHeaderCallback","header",[h(a.nTHead).children("tr")[0],Ma(a),g,n,i]);s(a,"aoFooterCallback","footer",[h(a.nTFoot).children("tr")[0],Ma(a),g,n,i]);d=h(a.nTBody);d.children().detach();d.append(h(b));s(a,"aoDrawCallback","draw",[a]);a.bSorted=!1;a.bFiltered=!1;a.bDrawing=!1}}function T(a,b){var c=a.oFeatures,d=c.bFilter;
 c.bSort&&ob(a);d?ga(a,a.oPreviousSearch):a.aiDisplay=a.aiDisplayMaster.slice();!0!==b&&(a._iDisplayStart=0);a._drawHold=b;O(a);a._drawHold=!1}function pb(a){var b=a.oClasses,c=h(a.nTable),c=h("<div/>").insertBefore(c),d=a.oFeatures,e=h("<div/>",{id:a.sTableId+"_wrapper","class":b.sWrapper+(a.nTFoot?"":" "+b.sNoFooter)});a.nHolding=c[0];a.nTableWrapper=e[0];a.nTableReinsertBefore=a.nTable.nextSibling;for(var f=a.sDom.split(""),g,j,i,n,l,q,k=0;k<f.length;k++){g=null;j=f[k];if("<"==j){i=h("<div/>")[0];
 n=f[k+1];if("'"==n||'"'==n){l="";for(q=2;f[k+q]!=n;)l+=f[k+q],q++;"H"==l?l=b.sJUIHeader:"F"==l&&(l=b.sJUIFooter);-1!=l.indexOf(".")?(n=l.split("."),i.id=n[0].substr(1,n[0].length-1),i.className=n[1]):"#"==l.charAt(0)?i.id=l.substr(1,l.length-1):i.className=l;k+=q}e.append(i);e=h(i)}else if(">"==j)e=e.parent();else if("l"==j&&d.bPaginate&&d.bLengthChange)g=qb(a);else if("f"==j&&d.bFilter)g=rb(a);else if("r"==j&&d.bProcessing)g=sb(a);else if("t"==j)g=tb(a);else if("i"==j&&d.bInfo)g=ub(a);else if("p"==
 j&&d.bPaginate)g=vb(a);else if(0!==m.ext.feature.length){i=m.ext.feature;q=0;for(n=i.length;q<n;q++)if(j==i[q].cFeature){g=i[q].fnInit(a);break}}g&&(i=a.aanFeatures,i[j]||(i[j]=[]),i[j].push(g),e.append(g))}c.replaceWith(e);a.nHolding=null}function ea(a,b){var c=h(b).children("tr"),d,e,f,g,j,i,n,l,q,k;a.splice(0,a.length);f=0;for(i=c.length;f<i;f++)a.push([]);f=0;for(i=c.length;f<i;f++){d=c[f];for(e=d.firstChild;e;){if("TD"==e.nodeName.toUpperCase()||"TH"==e.nodeName.toUpperCase()){l=1*e.getAttribute("colspan");
 q=1*e.getAttribute("rowspan");l=!l||0===l||1===l?1:l;q=!q||0===q||1===q?1:q;g=0;for(j=a[f];j[g];)g++;n=g;k=1===l?!0:!1;for(j=0;j<l;j++)for(g=0;g<q;g++)a[f+g][n+j]={cell:e,unique:k},a[f+g].nTr=d}e=e.nextSibling}}}function ta(a,b,c){var d=[];c||(c=a.aoHeader,b&&(c=[],ea(c,b)));for(var b=0,e=c.length;b<e;b++)for(var f=0,g=c[b].length;f<g;f++)if(c[b][f].unique&&(!d[f]||!a.bSortCellsTop))d[f]=c[b][f].cell;return d}function ua(a,b,c){s(a,"aoServerParams","serverParams",[b]);if(b&&h.isArray(b)){var d={},
 e=/(.*?)\[\]$/;h.each(b,function(a,b){var c=b.name.match(e);c?(c=c[0],d[c]||(d[c]=[]),d[c].push(b.value)):d[b.name]=b.value});b=d}var f,g=a.ajax,j=a.oInstance,i=function(b){s(a,null,"xhr",[a,b,a.jqXHR]);c(b)};if(h.isPlainObject(g)&&g.data){f=g.data;var n=h.isFunction(f)?f(b,a):f,b=h.isFunction(f)&&n?n:h.extend(!0,b,n);delete g.data}n={data:b,success:function(b){var c=b.error||b.sError;c&&K(a,0,c);a.json=b;i(b)},dataType:"json",cache:!1,type:a.sServerMethod,error:function(b,c){var d=s(a,null,"xhr",
 [a,null,a.jqXHR]);-1===h.inArray(!0,d)&&("parsererror"==c?K(a,0,"Invalid JSON response",1):4===b.readyState&&K(a,0,"Ajax error",7));C(a,!1)}};a.oAjaxData=b;s(a,null,"preXhr",[a,b]);a.fnServerData?a.fnServerData.call(j,a.sAjaxSource,h.map(b,function(a,b){return{name:b,value:a}}),i,a):a.sAjaxSource||"string"===typeof g?a.jqXHR=h.ajax(h.extend(n,{url:g||a.sAjaxSource})):h.isFunction(g)?a.jqXHR=g.call(j,b,i,a):(a.jqXHR=h.ajax(h.extend(n,g)),g.data=f)}function nb(a){return a.bAjaxDataGet?(a.iDraw++,C(a,
 !0),ua(a,wb(a),function(b){xb(a,b)}),!1):!0}function wb(a){var b=a.aoColumns,c=b.length,d=a.oFeatures,e=a.oPreviousSearch,f=a.aoPreSearchCols,g,j=[],i,n,l,k=W(a);g=a._iDisplayStart;i=!1!==d.bPaginate?a._iDisplayLength:-1;var r=function(a,b){j.push({name:a,value:b})};r("sEcho",a.iDraw);r("iColumns",c);r("sColumns",D(b,"sName").join(","));r("iDisplayStart",g);r("iDisplayLength",i);var ra={draw:a.iDraw,columns:[],order:[],start:g,length:i,search:{value:e.sSearch,regex:e.bRegex}};for(g=0;g<c;g++)n=b[g],
 l=f[g],i="function"==typeof n.mData?"function":n.mData,ra.columns.push({data:i,name:n.sName,searchable:n.bSearchable,orderable:n.bSortable,search:{value:l.sSearch,regex:l.bRegex}}),r("mDataProp_"+g,i),d.bFilter&&(r("sSearch_"+g,l.sSearch),r("bRegex_"+g,l.bRegex),r("bSearchable_"+g,n.bSearchable)),d.bSort&&r("bSortable_"+g,n.bSortable);d.bFilter&&(r("sSearch",e.sSearch),r("bRegex",e.bRegex));d.bSort&&(h.each(k,function(a,b){ra.order.push({column:b.col,dir:b.dir});r("iSortCol_"+a,b.col);r("sSortDir_"+
 a,b.dir)}),r("iSortingCols",k.length));b=m.ext.legacy.ajax;return null===b?a.sAjaxSource?j:ra:b?j:ra}function xb(a,b){var c=va(a,b),d=b.sEcho!==k?b.sEcho:b.draw,e=b.iTotalRecords!==k?b.iTotalRecords:b.recordsTotal,f=b.iTotalDisplayRecords!==k?b.iTotalDisplayRecords:b.recordsFiltered;if(d){if(1*d<a.iDraw)return;a.iDraw=1*d}pa(a);a._iRecordsTotal=parseInt(e,10);a._iRecordsDisplay=parseInt(f,10);d=0;for(e=c.length;d<e;d++)N(a,c[d]);a.aiDisplay=a.aiDisplayMaster.slice();a.bAjaxDataGet=!1;O(a);a._bInitComplete||
 wa(a,b);a.bAjaxDataGet=!0;C(a,!1)}function va(a,b){var c=h.isPlainObject(a.ajax)&&a.ajax.dataSrc!==k?a.ajax.dataSrc:a.sAjaxDataProp;return"data"===c?b.aaData||b[c]:""!==c?R(c)(b):b}function rb(a){var b=a.oClasses,c=a.sTableId,d=a.oLanguage,e=a.oPreviousSearch,f=a.aanFeatures,g='<input type="search" class="'+b.sFilterInput+'"/>',j=d.sSearch,j=j.match(/_INPUT_/)?j.replace("_INPUT_",g):j+g,b=h("<div/>",{id:!f.f?c+"_filter":null,"class":b.sFilter}).append(h("<label/>").append(j)),f=function(){var b=!this.value?
 "":this.value;b!=e.sSearch&&(ga(a,{sSearch:b,bRegex:e.bRegex,bSmart:e.bSmart,bCaseInsensitive:e.bCaseInsensitive}),a._iDisplayStart=0,O(a))},g=null!==a.searchDelay?a.searchDelay:"ssp"===y(a)?400:0,i=h("input",b).val(e.sSearch).attr("placeholder",d.sSearchPlaceholder).on("keyup.DT search.DT input.DT paste.DT cut.DT",g?Qa(f,g):f).on("keypress.DT",function(a){if(13==a.keyCode)return!1}).attr("aria-controls",c);h(a.nTable).on("search.dt.DT",function(b,c){if(a===c)try{i[0]!==H.activeElement&&i.val(e.sSearch)}catch(d){}});
 return b[0]}function ga(a,b,c){var d=a.oPreviousSearch,e=a.aoPreSearchCols,f=function(a){d.sSearch=a.sSearch;d.bRegex=a.bRegex;d.bSmart=a.bSmart;d.bCaseInsensitive=a.bCaseInsensitive};Ia(a);if("ssp"!=y(a)){yb(a,b.sSearch,c,b.bEscapeRegex!==k?!b.bEscapeRegex:b.bRegex,b.bSmart,b.bCaseInsensitive);f(b);for(b=0;b<e.length;b++)zb(a,e[b].sSearch,b,e[b].bEscapeRegex!==k?!e[b].bEscapeRegex:e[b].bRegex,e[b].bSmart,e[b].bCaseInsensitive);Ab(a)}else f(b);a.bFiltered=!0;s(a,null,"search",[a])}function Ab(a){for(var b=
 m.ext.search,c=a.aiDisplay,d,e,f=0,g=b.length;f<g;f++){for(var j=[],i=0,n=c.length;i<n;i++)e=c[i],d=a.aoData[e],b[f](a,d._aFilterData,e,d._aData,i)&&j.push(e);c.length=0;h.merge(c,j)}}function zb(a,b,c,d,e,f){if(""!==b){for(var g=[],j=a.aiDisplay,d=Ra(b,d,e,f),e=0;e<j.length;e++)b=a.aoData[j[e]]._aFilterData[c],d.test(b)&&g.push(j[e]);a.aiDisplay=g}}function yb(a,b,c,d,e,f){var d=Ra(b,d,e,f),f=a.oPreviousSearch.sSearch,g=a.aiDisplayMaster,j,e=[];0!==m.ext.search.length&&(c=!0);j=Bb(a);if(0>=b.length)a.aiDisplay=
 g.slice();else{if(j||c||f.length>b.length||0!==b.indexOf(f)||a.bSorted)a.aiDisplay=g.slice();b=a.aiDisplay;for(c=0;c<b.length;c++)d.test(a.aoData[b[c]]._sFilterRow)&&e.push(b[c]);a.aiDisplay=e}}function Ra(a,b,c,d){a=b?a:Sa(a);c&&(a="^(?=.*?"+h.map(a.match(/"[^"]+"|[^ ]+/g)||[""],function(a){if('"'===a.charAt(0))var b=a.match(/^"(.*)"$/),a=b?b[1]:a;return a.replace('"',"")}).join(")(?=.*?")+").*$");return RegExp(a,d?"i":"")}function Bb(a){var b=a.aoColumns,c,d,e,f,g,j,i,h,l=m.ext.type.search;c=!1;
 d=0;for(f=a.aoData.length;d<f;d++)if(h=a.aoData[d],!h._aFilterData){j=[];e=0;for(g=b.length;e<g;e++)c=b[e],c.bSearchable?(i=B(a,d,e,"filter"),l[c.sType]&&(i=l[c.sType](i)),null===i&&(i=""),"string"!==typeof i&&i.toString&&(i=i.toString())):i="",i.indexOf&&-1!==i.indexOf("&")&&(xa.innerHTML=i,i=$b?xa.textContent:xa.innerText),i.replace&&(i=i.replace(/[\r\n]/g,"")),j.push(i);h._aFilterData=j;h._sFilterRow=j.join("  ");c=!0}return c}function Cb(a){return{search:a.sSearch,smart:a.bSmart,regex:a.bRegex,
 caseInsensitive:a.bCaseInsensitive}}function Db(a){return{sSearch:a.search,bSmart:a.smart,bRegex:a.regex,bCaseInsensitive:a.caseInsensitive}}function ub(a){var b=a.sTableId,c=a.aanFeatures.i,d=h("<div/>",{"class":a.oClasses.sInfo,id:!c?b+"_info":null});c||(a.aoDrawCallback.push({fn:Eb,sName:"information"}),d.attr("role","status").attr("aria-live","polite"),h(a.nTable).attr("aria-describedby",b+"_info"));return d[0]}function Eb(a){var b=a.aanFeatures.i;if(0!==b.length){var c=a.oLanguage,d=a._iDisplayStart+
 1,e=a.fnDisplayEnd(),f=a.fnRecordsTotal(),g=a.fnRecordsDisplay(),j=g?c.sInfo:c.sInfoEmpty;g!==f&&(j+=" "+c.sInfoFiltered);j+=c.sInfoPostFix;j=Fb(a,j);c=c.fnInfoCallback;null!==c&&(j=c.call(a.oInstance,a,d,e,f,g,j));h(b).html(j)}}function Fb(a,b){var c=a.fnFormatNumber,d=a._iDisplayStart+1,e=a._iDisplayLength,f=a.fnRecordsDisplay(),g=-1===e;return b.replace(/_START_/g,c.call(a,d)).replace(/_END_/g,c.call(a,a.fnDisplayEnd())).replace(/_MAX_/g,c.call(a,a.fnRecordsTotal())).replace(/_TOTAL_/g,c.call(a,
 f)).replace(/_PAGE_/g,c.call(a,g?1:Math.ceil(d/e))).replace(/_PAGES_/g,c.call(a,g?1:Math.ceil(f/e)))}function ha(a){var b,c,d=a.iInitDisplayStart,e=a.aoColumns,f;c=a.oFeatures;var g=a.bDeferLoading;if(a.bInitialised){pb(a);mb(a);fa(a,a.aoHeader);fa(a,a.aoFooter);C(a,!0);c.bAutoWidth&&Ha(a);b=0;for(c=e.length;b<c;b++)f=e[b],f.sWidth&&(f.nTh.style.width=v(f.sWidth));s(a,null,"preInit",[a]);T(a);e=y(a);if("ssp"!=e||g)"ajax"==e?ua(a,[],function(c){var f=va(a,c);for(b=0;b<f.length;b++)N(a,f[b]);a.iInitDisplayStart=
 d;T(a);C(a,!1);wa(a,c)},a):(C(a,!1),wa(a))}else setTimeout(function(){ha(a)},200)}function wa(a,b){a._bInitComplete=!0;(b||a.oInit.aaData)&&Z(a);s(a,null,"plugin-init",[a,b]);s(a,"aoInitComplete","init",[a,b])}function Ta(a,b){var c=parseInt(b,10);a._iDisplayLength=c;Ua(a);s(a,null,"length",[a,c])}function qb(a){for(var b=a.oClasses,c=a.sTableId,d=a.aLengthMenu,e=h.isArray(d[0]),f=e?d[0]:d,d=e?d[1]:d,e=h("<select/>",{name:c+"_length","aria-controls":c,"class":b.sLengthSelect}),g=0,j=f.length;g<j;g++)e[0][g]=
 new Option(d[g],f[g]);var i=h("<div><label/></div>").addClass(b.sLength);a.aanFeatures.l||(i[0].id=c+"_length");i.children().append(a.oLanguage.sLengthMenu.replace("_MENU_",e[0].outerHTML));h("select",i).val(a._iDisplayLength).on("change.DT",function(){Ta(a,h(this).val());O(a)});h(a.nTable).on("length.dt.DT",function(b,c,d){a===c&&h("select",i).val(d)});return i[0]}function vb(a){var b=a.sPaginationType,c=m.ext.pager[b],d="function"===typeof c,e=function(a){O(a)},b=h("<div/>").addClass(a.oClasses.sPaging+
 b)[0],f=a.aanFeatures;d||c.fnInit(a,b,e);f.p||(b.id=a.sTableId+"_paginate",a.aoDrawCallback.push({fn:function(a){if(d){var b=a._iDisplayStart,i=a._iDisplayLength,h=a.fnRecordsDisplay(),l=-1===i,b=l?0:Math.ceil(b/i),i=l?1:Math.ceil(h/i),h=c(b,i),k,l=0;for(k=f.p.length;l<k;l++)Pa(a,"pageButton")(a,f.p[l],l,h,b,i)}else c.fnUpdate(a,e)},sName:"pagination"}));return b}function Va(a,b,c){var d=a._iDisplayStart,e=a._iDisplayLength,f=a.fnRecordsDisplay();0===f||-1===e?d=0:"number"===typeof b?(d=b*e,d>f&&
 (d=0)):"first"==b?d=0:"previous"==b?(d=0<=e?d-e:0,0>d&&(d=0)):"next"==b?d+e<f&&(d+=e):"last"==b?d=Math.floor((f-1)/e)*e:K(a,0,"Unknown paging action: "+b,5);b=a._iDisplayStart!==d;a._iDisplayStart=d;b&&(s(a,null,"page",[a]),c&&O(a));return b}function sb(a){return h("<div/>",{id:!a.aanFeatures.r?a.sTableId+"_processing":null,"class":a.oClasses.sProcessing}).html(a.oLanguage.sProcessing).insertBefore(a.nTable)[0]}function C(a,b){a.oFeatures.bProcessing&&h(a.aanFeatures.r).css("display",b?"block":"none");
 s(a,null,"processing",[a,b])}function tb(a){var b=h(a.nTable);b.attr("role","grid");var c=a.oScroll;if(""===c.sX&&""===c.sY)return a.nTable;var d=c.sX,e=c.sY,f=a.oClasses,g=b.children("caption"),j=g.length?g[0]._captionSide:null,i=h(b[0].cloneNode(!1)),n=h(b[0].cloneNode(!1)),l=b.children("tfoot");l.length||(l=null);i=h("<div/>",{"class":f.sScrollWrapper}).append(h("<div/>",{"class":f.sScrollHead}).css({overflow:"hidden",position:"relative",border:0,width:d?!d?null:v(d):"100%"}).append(h("<div/>",
 {"class":f.sScrollHeadInner}).css({"box-sizing":"content-box",width:c.sXInner||"100%"}).append(i.removeAttr("id").css("margin-left",0).append("top"===j?g:null).append(b.children("thead"))))).append(h("<div/>",{"class":f.sScrollBody}).css({position:"relative",overflow:"auto",width:!d?null:v(d)}).append(b));l&&i.append(h("<div/>",{"class":f.sScrollFoot}).css({overflow:"hidden",border:0,width:d?!d?null:v(d):"100%"}).append(h("<div/>",{"class":f.sScrollFootInner}).append(n.removeAttr("id").css("margin-left",
 0).append("bottom"===j?g:null).append(b.children("tfoot")))));var b=i.children(),k=b[0],f=b[1],r=l?b[2]:null;if(d)h(f).on("scroll.DT",function(){var a=this.scrollLeft;k.scrollLeft=a;l&&(r.scrollLeft=a)});h(f).css(e&&c.bCollapse?"max-height":"height",e);a.nScrollHead=k;a.nScrollBody=f;a.nScrollFoot=r;a.aoDrawCallback.push({fn:ma,sName:"scrolling"});return i[0]}function ma(a){var b=a.oScroll,c=b.sX,d=b.sXInner,e=b.sY,b=b.iBarWidth,f=h(a.nScrollHead),g=f[0].style,j=f.children("div"),i=j[0].style,n=j.children("table"),
 j=a.nScrollBody,l=h(j),q=j.style,r=h(a.nScrollFoot).children("div"),m=r.children("table"),p=h(a.nTHead),o=h(a.nTable),t=o[0],s=t.style,u=a.nTFoot?h(a.nTFoot):null,x=a.oBrowser,U=x.bScrollOversize,ac=D(a.aoColumns,"nTh"),P,L,Q,w,Wa=[],y=[],z=[],A=[],B,C=function(a){a=a.style;a.paddingTop="0";a.paddingBottom="0";a.borderTopWidth="0";a.borderBottomWidth="0";a.height=0};L=j.scrollHeight>j.clientHeight;if(a.scrollBarVis!==L&&a.scrollBarVis!==k)a.scrollBarVis=L,Z(a);else{a.scrollBarVis=L;o.children("thead, tfoot").remove();
 u&&(Q=u.clone().prependTo(o),P=u.find("tr"),Q=Q.find("tr"));w=p.clone().prependTo(o);p=p.find("tr");L=w.find("tr");w.find("th, td").removeAttr("tabindex");c||(q.width="100%",f[0].style.width="100%");h.each(ta(a,w),function(b,c){B=$(a,b);c.style.width=a.aoColumns[B].sWidth});u&&I(function(a){a.style.width=""},Q);f=o.outerWidth();if(""===c){s.width="100%";if(U&&(o.find("tbody").height()>j.offsetHeight||"scroll"==l.css("overflow-y")))s.width=v(o.outerWidth()-b);f=o.outerWidth()}else""!==d&&(s.width=
 v(d),f=o.outerWidth());I(C,L);I(function(a){z.push(a.innerHTML);Wa.push(v(h(a).css("width")))},L);I(function(a,b){if(h.inArray(a,ac)!==-1)a.style.width=Wa[b]},p);h(L).height(0);u&&(I(C,Q),I(function(a){A.push(a.innerHTML);y.push(v(h(a).css("width")))},Q),I(function(a,b){a.style.width=y[b]},P),h(Q).height(0));I(function(a,b){a.innerHTML='<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+z[b]+"</div>";a.style.width=Wa[b]},L);u&&I(function(a,b){a.innerHTML='<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+
 A[b]+"</div>";a.style.width=y[b]},Q);if(o.outerWidth()<f){P=j.scrollHeight>j.offsetHeight||"scroll"==l.css("overflow-y")?f+b:f;if(U&&(j.scrollHeight>j.offsetHeight||"scroll"==l.css("overflow-y")))s.width=v(P-b);(""===c||""!==d)&&K(a,1,"Possible column misalignment",6)}else P="100%";q.width=v(P);g.width=v(P);u&&(a.nScrollFoot.style.width=v(P));!e&&U&&(q.height=v(t.offsetHeight+b));c=o.outerWidth();n[0].style.width=v(c);i.width=v(c);d=o.height()>j.clientHeight||"scroll"==l.css("overflow-y");e="padding"+
 (x.bScrollbarLeft?"Left":"Right");i[e]=d?b+"px":"0px";u&&(m[0].style.width=v(c),r[0].style.width=v(c),r[0].style[e]=d?b+"px":"0px");o.children("colgroup").insertBefore(o.children("thead"));l.scroll();if((a.bSorted||a.bFiltered)&&!a._drawHold)j.scrollTop=0}}function I(a,b,c){for(var d=0,e=0,f=b.length,g,j;e<f;){g=b[e].firstChild;for(j=c?c[e].firstChild:null;g;)1===g.nodeType&&(c?a(g,j,d):a(g,d),d++),g=g.nextSibling,j=c?j.nextSibling:null;e++}}function Ha(a){var b=a.nTable,c=a.aoColumns,d=a.oScroll,
 e=d.sY,f=d.sX,g=d.sXInner,j=c.length,i=na(a,"bVisible"),n=h("th",a.nTHead),l=b.getAttribute("width"),k=b.parentNode,r=!1,m,p,o=a.oBrowser,d=o.bScrollOversize;(m=b.style.width)&&-1!==m.indexOf("%")&&(l=m);for(m=0;m<i.length;m++)p=c[i[m]],null!==p.sWidth&&(p.sWidth=Gb(p.sWidthOrig,k),r=!0);if(d||!r&&!f&&!e&&j==ba(a)&&j==n.length)for(m=0;m<j;m++)i=$(a,m),null!==i&&(c[i].sWidth=v(n.eq(m).width()));else{j=h(b).clone().css("visibility","hidden").removeAttr("id");j.find("tbody tr").remove();var t=h("<tr/>").appendTo(j.find("tbody"));
 j.find("thead, tfoot").remove();j.append(h(a.nTHead).clone()).append(h(a.nTFoot).clone());j.find("tfoot th, tfoot td").css("width","");n=ta(a,j.find("thead")[0]);for(m=0;m<i.length;m++)p=c[i[m]],n[m].style.width=null!==p.sWidthOrig&&""!==p.sWidthOrig?v(p.sWidthOrig):"",p.sWidthOrig&&f&&h(n[m]).append(h("<div/>").css({width:p.sWidthOrig,margin:0,padding:0,border:0,height:1}));if(a.aoData.length)for(m=0;m<i.length;m++)r=i[m],p=c[r],h(Hb(a,r)).clone(!1).append(p.sContentPadding).appendTo(t);h("[name]",
 j).removeAttr("name");p=h("<div/>").css(f||e?{position:"absolute",top:0,left:0,height:1,right:0,overflow:"hidden"}:{}).append(j).appendTo(k);f&&g?j.width(g):f?(j.css("width","auto"),j.removeAttr("width"),j.width()<k.clientWidth&&l&&j.width(k.clientWidth)):e?j.width(k.clientWidth):l&&j.width(l);for(m=e=0;m<i.length;m++)k=h(n[m]),g=k.outerWidth()-k.width(),k=o.bBounding?Math.ceil(n[m].getBoundingClientRect().width):k.outerWidth(),e+=k,c[i[m]].sWidth=v(k-g);b.style.width=v(e);p.remove()}l&&(b.style.width=
 v(l));if((l||f)&&!a._reszEvt)b=function(){h(E).on("resize.DT-"+a.sInstance,Qa(function(){Z(a)}))},d?setTimeout(b,1E3):b(),a._reszEvt=!0}function Gb(a,b){if(!a)return 0;var c=h("<div/>").css("width",v(a)).appendTo(b||H.body),d=c[0].offsetWidth;c.remove();return d}function Hb(a,b){var c=Ib(a,b);if(0>c)return null;var d=a.aoData[c];return!d.nTr?h("<td/>").html(B(a,c,b,"display"))[0]:d.anCells[b]}function Ib(a,b){for(var c,d=-1,e=-1,f=0,g=a.aoData.length;f<g;f++)c=B(a,f,b,"display")+"",c=c.replace(bc,
 ""),c=c.replace(/&nbsp;/g," "),c.length>d&&(d=c.length,e=f);return e}function v(a){return null===a?"0px":"number"==typeof a?0>a?"0px":a+"px":a.match(/\d$/)?a+"px":a}function W(a){var b,c,d=[],e=a.aoColumns,f,g,j,i;b=a.aaSortingFixed;c=h.isPlainObject(b);var n=[];f=function(a){a.length&&!h.isArray(a[0])?n.push(a):h.merge(n,a)};h.isArray(b)&&f(b);c&&b.pre&&f(b.pre);f(a.aaSorting);c&&b.post&&f(b.post);for(a=0;a<n.length;a++){i=n[a][0];f=e[i].aDataSort;b=0;for(c=f.length;b<c;b++)g=f[b],j=e[g].sType||
 "string",n[a]._idx===k&&(n[a]._idx=h.inArray(n[a][1],e[g].asSorting)),d.push({src:i,col:g,dir:n[a][1],index:n[a]._idx,type:j,formatter:m.ext.type.order[j+"-pre"]})}return d}function ob(a){var b,c,d=[],e=m.ext.type.order,f=a.aoData,g=0,j,i=a.aiDisplayMaster,h;Ia(a);h=W(a);b=0;for(c=h.length;b<c;b++)j=h[b],j.formatter&&g++,Jb(a,j.col);if("ssp"!=y(a)&&0!==h.length){b=0;for(c=i.length;b<c;b++)d[i[b]]=b;g===h.length?i.sort(function(a,b){var c,e,g,j,i=h.length,k=f[a]._aSortData,m=f[b]._aSortData;for(g=
 0;g<i;g++)if(j=h[g],c=k[j.col],e=m[j.col],c=c<e?-1:c>e?1:0,0!==c)return"asc"===j.dir?c:-c;c=d[a];e=d[b];return c<e?-1:c>e?1:0}):i.sort(function(a,b){var c,g,j,i,k=h.length,m=f[a]._aSortData,p=f[b]._aSortData;for(j=0;j<k;j++)if(i=h[j],c=m[i.col],g=p[i.col],i=e[i.type+"-"+i.dir]||e["string-"+i.dir],c=i(c,g),0!==c)return c;c=d[a];g=d[b];return c<g?-1:c>g?1:0})}a.bSorted=!0}function Kb(a){for(var b,c,d=a.aoColumns,e=W(a),a=a.oLanguage.oAria,f=0,g=d.length;f<g;f++){c=d[f];var j=c.asSorting;b=c.sTitle.replace(/<.*?>/g,
 "");var i=c.nTh;i.removeAttribute("aria-sort");c.bSortable&&(0<e.length&&e[0].col==f?(i.setAttribute("aria-sort","asc"==e[0].dir?"ascending":"descending"),c=j[e[0].index+1]||j[0]):c=j[0],b+="asc"===c?a.sSortAscending:a.sSortDescending);i.setAttribute("aria-label",b)}}function Xa(a,b,c,d){var e=a.aaSorting,f=a.aoColumns[b].asSorting,g=function(a,b){var c=a._idx;c===k&&(c=h.inArray(a[1],f));return c+1<f.length?c+1:b?null:0};"number"===typeof e[0]&&(e=a.aaSorting=[e]);c&&a.oFeatures.bSortMulti?(c=h.inArray(b,
 D(e,"0")),-1!==c?(b=g(e[c],!0),null===b&&1===e.length&&(b=0),null===b?e.splice(c,1):(e[c][1]=f[b],e[c]._idx=b)):(e.push([b,f[0],0]),e[e.length-1]._idx=0)):e.length&&e[0][0]==b?(b=g(e[0]),e.length=1,e[0][1]=f[b],e[0]._idx=b):(e.length=0,e.push([b,f[0]]),e[0]._idx=0);T(a);"function"==typeof d&&d(a)}function Oa(a,b,c,d){var e=a.aoColumns[c];Ya(b,{},function(b){!1!==e.bSortable&&(a.oFeatures.bProcessing?(C(a,!0),setTimeout(function(){Xa(a,c,b.shiftKey,d);"ssp"!==y(a)&&C(a,!1)},0)):Xa(a,c,b.shiftKey,d))})}
 function ya(a){var b=a.aLastSort,c=a.oClasses.sSortColumn,d=W(a),e=a.oFeatures,f,g;if(e.bSort&&e.bSortClasses){e=0;for(f=b.length;e<f;e++)g=b[e].src,h(D(a.aoData,"anCells",g)).removeClass(c+(2>e?e+1:3));e=0;for(f=d.length;e<f;e++)g=d[e].src,h(D(a.aoData,"anCells",g)).addClass(c+(2>e?e+1:3))}a.aLastSort=d}function Jb(a,b){var c=a.aoColumns[b],d=m.ext.order[c.sSortDataType],e;d&&(e=d.call(a.oInstance,a,b,aa(a,b)));for(var f,g=m.ext.type.order[c.sType+"-pre"],j=0,i=a.aoData.length;j<i;j++)if(c=a.aoData[j],
 c._aSortData||(c._aSortData=[]),!c._aSortData[b]||d)f=d?e[j]:B(a,j,b,"sort"),c._aSortData[b]=g?g(f):f}function za(a){if(a.oFeatures.bStateSave&&!a.bDestroying){var b={time:+new Date,start:a._iDisplayStart,length:a._iDisplayLength,order:h.extend(!0,[],a.aaSorting),search:Cb(a.oPreviousSearch),columns:h.map(a.aoColumns,function(b,d){return{visible:b.bVisible,search:Cb(a.aoPreSearchCols[d])}})};s(a,"aoStateSaveParams","stateSaveParams",[a,b]);a.oSavedState=b;a.fnStateSaveCallback.call(a.oInstance,a,
 b)}}function Lb(a,b,c){var d,e,f=a.aoColumns,b=function(b){if(b&&b.time){var g=s(a,"aoStateLoadParams","stateLoadParams",[a,b]);if(-1===h.inArray(!1,g)&&(g=a.iStateDuration,!(0<g&&b.time<+new Date-1E3*g)&&!(b.columns&&f.length!==b.columns.length))){a.oLoadedState=h.extend(!0,{},b);b.start!==k&&(a._iDisplayStart=b.start,a.iInitDisplayStart=b.start);b.length!==k&&(a._iDisplayLength=b.length);b.order!==k&&(a.aaSorting=[],h.each(b.order,function(b,c){a.aaSorting.push(c[0]>=f.length?[0,c[1]]:c)}));b.search!==
 k&&h.extend(a.oPreviousSearch,Db(b.search));if(b.columns){d=0;for(e=b.columns.length;d<e;d++)g=b.columns[d],g.visible!==k&&(f[d].bVisible=g.visible),g.search!==k&&h.extend(a.aoPreSearchCols[d],Db(g.search))}s(a,"aoStateLoaded","stateLoaded",[a,b])}}c()};if(a.oFeatures.bStateSave){var g=a.fnStateLoadCallback.call(a.oInstance,a,b);g!==k&&b(g)}else c()}function Aa(a){var b=m.settings,a=h.inArray(a,D(b,"nTable"));return-1!==a?b[a]:null}function K(a,b,c,d){c="DataTables warning: "+(a?"table id="+a.sTableId+
 " - ":"")+c;d&&(c+=". For more information about this error, please see http://datatables.net/tn/"+d);if(b)E.console&&console.log&&console.log(c);else if(b=m.ext,b=b.sErrMode||b.errMode,a&&s(a,null,"error",[a,d,c]),"alert"==b)alert(c);else{if("throw"==b)throw Error(c);"function"==typeof b&&b(a,d,c)}}function F(a,b,c,d){h.isArray(c)?h.each(c,function(c,d){h.isArray(d)?F(a,b,d[0],d[1]):F(a,b,d)}):(d===k&&(d=c),b[c]!==k&&(a[d]=b[c]))}function Mb(a,b,c){var d,e;for(e in b)b.hasOwnProperty(e)&&(d=b[e],
 h.isPlainObject(d)?(h.isPlainObject(a[e])||(a[e]={}),h.extend(!0,a[e],d)):a[e]=c&&"data"!==e&&"aaData"!==e&&h.isArray(d)?d.slice():d);return a}function Ya(a,b,c){h(a).on("click.DT",b,function(b){a.blur();c(b)}).on("keypress.DT",b,function(a){13===a.which&&(a.preventDefault(),c(a))}).on("selectstart.DT",function(){return!1})}function z(a,b,c,d){c&&a[b].push({fn:c,sName:d})}function s(a,b,c,d){var e=[];b&&(e=h.map(a[b].slice().reverse(),function(b){return b.fn.apply(a.oInstance,d)}));null!==c&&(b=h.Event(c+
 ".dt"),h(a.nTable).trigger(b,d),e.push(b.result));return e}function Ua(a){var b=a._iDisplayStart,c=a.fnDisplayEnd(),d=a._iDisplayLength;b>=c&&(b=c-d);b-=b%d;if(-1===d||0>b)b=0;a._iDisplayStart=b}function Pa(a,b){var c=a.renderer,d=m.ext.renderer[b];return h.isPlainObject(c)&&c[b]?d[c[b]]||d._:"string"===typeof c?d[c]||d._:d._}function y(a){return a.oFeatures.bServerSide?"ssp":a.ajax||a.sAjaxSource?"ajax":"dom"}function ia(a,b){var c=[],c=Nb.numbers_length,d=Math.floor(c/2);b<=c?c=X(0,b):a<=d?(c=X(0,
 c-2),c.push("ellipsis"),c.push(b-1)):(a>=b-1-d?c=X(b-(c-2),b):(c=X(a-d+2,a+d-1),c.push("ellipsis"),c.push(b-1)),c.splice(0,0,"ellipsis"),c.splice(0,0,0));c.DT_el="span";return c}function fb(a){h.each({num:function(b){return Ba(b,a)},"num-fmt":function(b){return Ba(b,a,Za)},"html-num":function(b){return Ba(b,a,Ca)},"html-num-fmt":function(b){return Ba(b,a,Ca,Za)}},function(b,c){x.type.order[b+a+"-pre"]=c;b.match(/^html\-/)&&(x.type.search[b+a]=x.type.search.html)})}function Ob(a){return function(){var b=
 [Aa(this[m.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));return m.ext.internal[a].apply(this,b)}}var m=function(a){this.$=function(a,b){return this.api(!0).$(a,b)};this._=function(a,b){return this.api(!0).rows(a,b).data()};this.api=function(a){return a?new t(Aa(this[x.iApiIndex])):new t(this)};this.fnAddData=function(a,b){var c=this.api(!0),d=h.isArray(a)&&(h.isArray(a[0])||h.isPlainObject(a[0]))?c.rows.add(a):c.row.add(a);(b===k||b)&&c.draw();return d.flatten().toArray()};this.fnAdjustColumnSizing=
 function(a){var b=this.api(!0).columns.adjust(),c=b.settings()[0],d=c.oScroll;a===k||a?b.draw(!1):(""!==d.sX||""!==d.sY)&&ma(c)};this.fnClearTable=function(a){var b=this.api(!0).clear();(a===k||a)&&b.draw()};this.fnClose=function(a){this.api(!0).row(a).child.hide()};this.fnDeleteRow=function(a,b,c){var d=this.api(!0),a=d.rows(a),e=a.settings()[0],h=e.aoData[a[0][0]];a.remove();b&&b.call(this,e,h);(c===k||c)&&d.draw();return h};this.fnDestroy=function(a){this.api(!0).destroy(a)};this.fnDraw=function(a){this.api(!0).draw(a)};
 this.fnFilter=function(a,b,c,d,e,h){e=this.api(!0);null===b||b===k?e.search(a,c,d,h):e.column(b).search(a,c,d,h);e.draw()};this.fnGetData=function(a,b){var c=this.api(!0);if(a!==k){var d=a.nodeName?a.nodeName.toLowerCase():"";return b!==k||"td"==d||"th"==d?c.cell(a,b).data():c.row(a).data()||null}return c.data().toArray()};this.fnGetNodes=function(a){var b=this.api(!0);return a!==k?b.row(a).node():b.rows().nodes().flatten().toArray()};this.fnGetPosition=function(a){var b=this.api(!0),c=a.nodeName.toUpperCase();
 return"TR"==c?b.row(a).index():"TD"==c||"TH"==c?(a=b.cell(a).index(),[a.row,a.columnVisible,a.column]):null};this.fnIsOpen=function(a){return this.api(!0).row(a).child.isShown()};this.fnOpen=function(a,b,c){return this.api(!0).row(a).child(b,c).show().child()[0]};this.fnPageChange=function(a,b){var c=this.api(!0).page(a);(b===k||b)&&c.draw(!1)};this.fnSetColumnVis=function(a,b,c){a=this.api(!0).column(a).visible(b);(c===k||c)&&a.columns.adjust().draw()};this.fnSettings=function(){return Aa(this[x.iApiIndex])};
 this.fnSort=function(a){this.api(!0).order(a).draw()};this.fnSortListener=function(a,b,c){this.api(!0).order.listener(a,b,c)};this.fnUpdate=function(a,b,c,d,e){var h=this.api(!0);c===k||null===c?h.row(b).data(a):h.cell(b,c).data(a);(e===k||e)&&h.columns.adjust();(d===k||d)&&h.draw();return 0};this.fnVersionCheck=x.fnVersionCheck;var b=this,c=a===k,d=this.length;c&&(a={});this.oApi=this.internal=x.internal;for(var e in m.ext.internal)e&&(this[e]=Ob(e));this.each(function(){var e={},g=1<d?Mb(e,a,!0):
 a,j=0,i,e=this.getAttribute("id"),n=!1,l=m.defaults,q=h(this);if("table"!=this.nodeName.toLowerCase())K(null,0,"Non-table node initialisation ("+this.nodeName+")",2);else{gb(l);hb(l.column);J(l,l,!0);J(l.column,l.column,!0);J(l,h.extend(g,q.data()));var r=m.settings,j=0;for(i=r.length;j<i;j++){var p=r[j];if(p.nTable==this||p.nTHead.parentNode==this||p.nTFoot&&p.nTFoot.parentNode==this){var t=g.bRetrieve!==k?g.bRetrieve:l.bRetrieve;if(c||t)return p.oInstance;if(g.bDestroy!==k?g.bDestroy:l.bDestroy){p.oInstance.fnDestroy();
 break}else{K(p,0,"Cannot reinitialise DataTable",3);return}}if(p.sTableId==this.id){r.splice(j,1);break}}if(null===e||""===e)this.id=e="DataTables_Table_"+m.ext._unique++;var o=h.extend(!0,{},m.models.oSettings,{sDestroyWidth:q[0].style.width,sInstance:e,sTableId:e});o.nTable=this;o.oApi=b.internal;o.oInit=g;r.push(o);o.oInstance=1===b.length?b:q.dataTable();gb(g);g.oLanguage&&Fa(g.oLanguage);g.aLengthMenu&&!g.iDisplayLength&&(g.iDisplayLength=h.isArray(g.aLengthMenu[0])?g.aLengthMenu[0][0]:g.aLengthMenu[0]);
 g=Mb(h.extend(!0,{},l),g);F(o.oFeatures,g,"bPaginate bLengthChange bFilter bSort bSortMulti bInfo bProcessing bAutoWidth bSortClasses bServerSide bDeferRender".split(" "));F(o,g,["asStripeClasses","ajax","fnServerData","fnFormatNumber","sServerMethod","aaSorting","aaSortingFixed","aLengthMenu","sPaginationType","sAjaxSource","sAjaxDataProp","iStateDuration","sDom","bSortCellsTop","iTabIndex","fnStateLoadCallback","fnStateSaveCallback","renderer","searchDelay","rowId",["iCookieDuration","iStateDuration"],
 ["oSearch","oPreviousSearch"],["aoSearchCols","aoPreSearchCols"],["iDisplayLength","_iDisplayLength"],["bJQueryUI","bJUI"]]);F(o.oScroll,g,[["sScrollX","sX"],["sScrollXInner","sXInner"],["sScrollY","sY"],["bScrollCollapse","bCollapse"]]);F(o.oLanguage,g,"fnInfoCallback");z(o,"aoDrawCallback",g.fnDrawCallback,"user");z(o,"aoServerParams",g.fnServerParams,"user");z(o,"aoStateSaveParams",g.fnStateSaveParams,"user");z(o,"aoStateLoadParams",g.fnStateLoadParams,"user");z(o,"aoStateLoaded",g.fnStateLoaded,
 "user");z(o,"aoRowCallback",g.fnRowCallback,"user");z(o,"aoRowCreatedCallback",g.fnCreatedRow,"user");z(o,"aoHeaderCallback",g.fnHeaderCallback,"user");z(o,"aoFooterCallback",g.fnFooterCallback,"user");z(o,"aoInitComplete",g.fnInitComplete,"user");z(o,"aoPreDrawCallback",g.fnPreDrawCallback,"user");o.rowIdFn=R(g.rowId);ib(o);var u=o.oClasses;g.bJQueryUI?(h.extend(u,m.ext.oJUIClasses,g.oClasses),g.sDom===l.sDom&&"lfrtip"===l.sDom&&(o.sDom='<"H"lfr>t<"F"ip>'),o.renderer)?h.isPlainObject(o.renderer)&&
 !o.renderer.header&&(o.renderer.header="jqueryui"):o.renderer="jqueryui":h.extend(u,m.ext.classes,g.oClasses);q.addClass(u.sTable);o.iInitDisplayStart===k&&(o.iInitDisplayStart=g.iDisplayStart,o._iDisplayStart=g.iDisplayStart);null!==g.iDeferLoading&&(o.bDeferLoading=!0,e=h.isArray(g.iDeferLoading),o._iRecordsDisplay=e?g.iDeferLoading[0]:g.iDeferLoading,o._iRecordsTotal=e?g.iDeferLoading[1]:g.iDeferLoading);var v=o.oLanguage;h.extend(!0,v,g.oLanguage);v.sUrl&&(h.ajax({dataType:"json",url:v.sUrl,success:function(a){Fa(a);
 J(l.oLanguage,a);h.extend(true,v,a);ha(o)},error:function(){ha(o)}}),n=!0);null===g.asStripeClasses&&(o.asStripeClasses=[u.sStripeOdd,u.sStripeEven]);var e=o.asStripeClasses,x=q.children("tbody").find("tr").eq(0);-1!==h.inArray(!0,h.map(e,function(a){return x.hasClass(a)}))&&(h("tbody tr",this).removeClass(e.join(" ")),o.asDestroyStripes=e.slice());e=[];r=this.getElementsByTagName("thead");0!==r.length&&(ea(o.aoHeader,r[0]),e=ta(o));if(null===g.aoColumns){r=[];j=0;for(i=e.length;j<i;j++)r.push(null)}else r=
 g.aoColumns;j=0;for(i=r.length;j<i;j++)Ga(o,e?e[j]:null);kb(o,g.aoColumnDefs,r,function(a,b){la(o,a,b)});if(x.length){var w=function(a,b){return a.getAttribute("data-"+b)!==null?b:null};h(x[0]).children("th, td").each(function(a,b){var c=o.aoColumns[a];if(c.mData===a){var d=w(b,"sort")||w(b,"order"),e=w(b,"filter")||w(b,"search");if(d!==null||e!==null){c.mData={_:a+".display",sort:d!==null?a+".@data-"+d:k,type:d!==null?a+".@data-"+d:k,filter:e!==null?a+".@data-"+e:k};la(o,a)}}})}var U=o.oFeatures,
 e=function(){if(g.aaSorting===k){var a=o.aaSorting;j=0;for(i=a.length;j<i;j++)a[j][1]=o.aoColumns[j].asSorting[0]}ya(o);U.bSort&&z(o,"aoDrawCallback",function(){if(o.bSorted){var a=W(o),b={};h.each(a,function(a,c){b[c.src]=c.dir});s(o,null,"order",[o,a,b]);Kb(o)}});z(o,"aoDrawCallback",function(){(o.bSorted||y(o)==="ssp"||U.bDeferRender)&&ya(o)},"sc");var a=q.children("caption").each(function(){this._captionSide=h(this).css("caption-side")}),b=q.children("thead");b.length===0&&(b=h("<thead/>").appendTo(q));
 o.nTHead=b[0];b=q.children("tbody");b.length===0&&(b=h("<tbody/>").appendTo(q));o.nTBody=b[0];b=q.children("tfoot");if(b.length===0&&a.length>0&&(o.oScroll.sX!==""||o.oScroll.sY!==""))b=h("<tfoot/>").appendTo(q);if(b.length===0||b.children().length===0)q.addClass(u.sNoFooter);else if(b.length>0){o.nTFoot=b[0];ea(o.aoFooter,o.nTFoot)}if(g.aaData)for(j=0;j<g.aaData.length;j++)N(o,g.aaData[j]);else(o.bDeferLoading||y(o)=="dom")&&oa(o,h(o.nTBody).children("tr"));o.aiDisplay=o.aiDisplayMaster.slice();
 o.bInitialised=true;n===false&&ha(o)};g.bStateSave?(U.bStateSave=!0,z(o,"aoDrawCallback",za,"state_save"),Lb(o,g,e)):e()}});b=null;return this},x,t,p,u,$a={},Pb=/[\r\n]/g,Ca=/<.*?>/g,cc=/^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/,dc=RegExp("(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\|\\$|\\^|\\-)","g"),Za=/[',$?\u2009\u202F\u20BD\u20a9\u20BArfk]/gi,M=function(a){return!a||!0===a||"-"===a?!0:!1},Qb=function(a){var b=parseInt(a,10);return!isNaN(b)&&
 isFinite(a)?b:null},Rb=function(a,b){$a[b]||($a[b]=RegExp(Sa(b),"g"));return"string"===typeof a&&"."!==b?a.replace(/\./g,"").replace($a[b],"."):a},ab=function(a,b,c){var d="string"===typeof a;if(M(a))return!0;b&&d&&(a=Rb(a,b));c&&d&&(a=a.replace(Za,""));return!isNaN(parseFloat(a))&&isFinite(a)},Sb=function(a,b,c){return M(a)?!0:!(M(a)||"string"===typeof a)?null:ab(a.replace(Ca,""),b,c)?!0:null},D=function(a,b,c){var d=[],e=0,f=a.length;if(c!==k)for(;e<f;e++)a[e]&&a[e][b]&&d.push(a[e][b][c]);else for(;e<
 f;e++)a[e]&&d.push(a[e][b]);return d},ja=function(a,b,c,d){var e=[],f=0,g=b.length;if(d!==k)for(;f<g;f++)a[b[f]][c]&&e.push(a[b[f]][c][d]);else for(;f<g;f++)e.push(a[b[f]][c]);return e},X=function(a,b){var c=[],d;b===k?(b=0,d=a):(d=b,b=a);for(var e=b;e<d;e++)c.push(e);return c},Tb=function(a){for(var b=[],c=0,d=a.length;c<d;c++)a[c]&&b.push(a[c]);return b},sa=function(a){var b;a:{if(!(2>a.length)){b=a.slice().sort();for(var c=b[0],d=1,e=b.length;d<e;d++){if(b[d]===c){b=!1;break a}c=b[d]}}b=!0}if(b)return a.slice();
 b=[];var e=a.length,f,g=0,d=0;a:for(;d<e;d++){c=a[d];for(f=0;f<g;f++)if(b[f]===c)continue a;b.push(c);g++}return b};m.util={throttle:function(a,b){var c=b!==k?b:200,d,e;return function(){var b=this,g=+new Date,h=arguments;d&&g<d+c?(clearTimeout(e),e=setTimeout(function(){d=k;a.apply(b,h)},c)):(d=g,a.apply(b,h))}},escapeRegex:function(a){return a.replace(dc,"\\$1")}};var A=function(a,b,c){a[b]!==k&&(a[c]=a[b])},ca=/\[.*?\]$/,V=/\(\)$/,Sa=m.util.escapeRegex,xa=h("<div>")[0],$b=xa.textContent!==k,bc=
 /<.*?>/g,Qa=m.util.throttle,Ub=[],w=Array.prototype,ec=function(a){var b,c,d=m.settings,e=h.map(d,function(a){return a.nTable});if(a){if(a.nTable&&a.oApi)return[a];if(a.nodeName&&"table"===a.nodeName.toLowerCase())return b=h.inArray(a,e),-1!==b?[d[b]]:null;if(a&&"function"===typeof a.settings)return a.settings().toArray();"string"===typeof a?c=h(a):a instanceof h&&(c=a)}else return[];if(c)return c.map(function(){b=h.inArray(this,e);return-1!==b?d[b]:null}).toArray()};t=function(a,b){if(!(this instanceof
 t))return new t(a,b);var c=[],d=function(a){(a=ec(a))&&(c=c.concat(a))};if(h.isArray(a))for(var e=0,f=a.length;e<f;e++)d(a[e]);else d(a);this.context=sa(c);b&&h.merge(this,b);this.selector={rows:null,cols:null,opts:null};t.extend(this,this,Ub)};m.Api=t;h.extend(t.prototype,{any:function(){return 0!==this.count()},concat:w.concat,context:[],count:function(){return this.flatten().length},each:function(a){for(var b=0,c=this.length;b<c;b++)a.call(this,this[b],b,this);return this},eq:function(a){var b=
 this.context;return b.length>a?new t(b[a],this[a]):null},filter:function(a){var b=[];if(w.filter)b=w.filter.call(this,a,this);else for(var c=0,d=this.length;c<d;c++)a.call(this,this[c],c,this)&&b.push(this[c]);return new t(this.context,b)},flatten:function(){var a=[];return new t(this.context,a.concat.apply(a,this.toArray()))},join:w.join,indexOf:w.indexOf||function(a,b){for(var c=b||0,d=this.length;c<d;c++)if(this[c]===a)return c;return-1},iterator:function(a,b,c,d){var e=[],f,g,h,i,n,l=this.context,
 m,p,u=this.selector;"string"===typeof a&&(d=c,c=b,b=a,a=!1);g=0;for(h=l.length;g<h;g++){var s=new t(l[g]);if("table"===b)f=c.call(s,l[g],g),f!==k&&e.push(f);else if("columns"===b||"rows"===b)f=c.call(s,l[g],this[g],g),f!==k&&e.push(f);else if("column"===b||"column-rows"===b||"row"===b||"cell"===b){p=this[g];"column-rows"===b&&(m=Da(l[g],u.opts));i=0;for(n=p.length;i<n;i++)f=p[i],f="cell"===b?c.call(s,l[g],f.row,f.column,g,i):c.call(s,l[g],f,g,i,m),f!==k&&e.push(f)}}return e.length||d?(a=new t(l,a?
 e.concat.apply([],e):e),b=a.selector,b.rows=u.rows,b.cols=u.cols,b.opts=u.opts,a):this},lastIndexOf:w.lastIndexOf||function(a,b){return this.indexOf.apply(this.toArray.reverse(),arguments)},length:0,map:function(a){var b=[];if(w.map)b=w.map.call(this,a,this);else for(var c=0,d=this.length;c<d;c++)b.push(a.call(this,this[c],c));return new t(this.context,b)},pluck:function(a){return this.map(function(b){return b[a]})},pop:w.pop,push:w.push,reduce:w.reduce||function(a,b){return jb(this,a,b,0,this.length,
 1)},reduceRight:w.reduceRight||function(a,b){return jb(this,a,b,this.length-1,-1,-1)},reverse:w.reverse,selector:null,shift:w.shift,slice:function(){return new t(this.context,this)},sort:w.sort,splice:w.splice,toArray:function(){return w.slice.call(this)},to$:function(){return h(this)},toJQuery:function(){return h(this)},unique:function(){return new t(this.context,sa(this))},unshift:w.unshift});t.extend=function(a,b,c){if(c.length&&b&&(b instanceof t||b.__dt_wrapper)){var d,e,f,g=function(a,b,c){return function(){var d=
 b.apply(a,arguments);t.extend(d,d,c.methodExt);return d}};d=0;for(e=c.length;d<e;d++)f=c[d],b[f.name]="function"===typeof f.val?g(a,f.val,f):h.isPlainObject(f.val)?{}:f.val,b[f.name].__dt_wrapper=!0,t.extend(a,b[f.name],f.propExt)}};t.register=p=function(a,b){if(h.isArray(a))for(var c=0,d=a.length;c<d;c++)t.register(a[c],b);else for(var e=a.split("."),f=Ub,g,j,c=0,d=e.length;c<d;c++){g=(j=-1!==e[c].indexOf("()"))?e[c].replace("()",""):e[c];var i;a:{i=0;for(var n=f.length;i<n;i++)if(f[i].name===g){i=
 f[i];break a}i=null}i||(i={name:g,val:{},methodExt:[],propExt:[]},f.push(i));c===d-1?i.val=b:f=j?i.methodExt:i.propExt}};t.registerPlural=u=function(a,b,c){t.register(a,c);t.register(b,function(){var a=c.apply(this,arguments);return a===this?this:a instanceof t?a.length?h.isArray(a[0])?new t(a.context,a[0]):a[0]:k:a})};p("tables()",function(a){var b;if(a){b=t;var c=this.context;if("number"===typeof a)a=[c[a]];else var d=h.map(c,function(a){return a.nTable}),a=h(d).filter(a).map(function(){var a=h.inArray(this,
 d);return c[a]}).toArray();b=new b(a)}else b=this;return b});p("table()",function(a){var a=this.tables(a),b=a.context;return b.length?new t(b[0]):a});u("tables().nodes()","table().node()",function(){return this.iterator("table",function(a){return a.nTable},1)});u("tables().body()","table().body()",function(){return this.iterator("table",function(a){return a.nTBody},1)});u("tables().header()","table().header()",function(){return this.iterator("table",function(a){return a.nTHead},1)});u("tables().footer()",
 "table().footer()",function(){return this.iterator("table",function(a){return a.nTFoot},1)});u("tables().containers()","table().container()",function(){return this.iterator("table",function(a){return a.nTableWrapper},1)});p("draw()",function(a){return this.iterator("table",function(b){"page"===a?O(b):("string"===typeof a&&(a="full-hold"===a?!1:!0),T(b,!1===a))})});p("page()",function(a){return a===k?this.page.info().page:this.iterator("table",function(b){Va(b,a)})});p("page.info()",function(){if(0===
 this.context.length)return k;var a=this.context[0],b=a._iDisplayStart,c=a.oFeatures.bPaginate?a._iDisplayLength:-1,d=a.fnRecordsDisplay(),e=-1===c;return{page:e?0:Math.floor(b/c),pages:e?1:Math.ceil(d/c),start:b,end:a.fnDisplayEnd(),length:c,recordsTotal:a.fnRecordsTotal(),recordsDisplay:d,serverSide:"ssp"===y(a)}});p("page.len()",function(a){return a===k?0!==this.context.length?this.context[0]._iDisplayLength:k:this.iterator("table",function(b){Ta(b,a)})});var Vb=function(a,b,c){if(c){var d=new t(a);
 d.one("draw",function(){c(d.ajax.json())})}if("ssp"==y(a))T(a,b);else{C(a,!0);var e=a.jqXHR;e&&4!==e.readyState&&e.abort();ua(a,[],function(c){pa(a);for(var c=va(a,c),d=0,e=c.length;d<e;d++)N(a,c[d]);T(a,b);C(a,!1)})}};p("ajax.json()",function(){var a=this.context;if(0<a.length)return a[0].json});p("ajax.params()",function(){var a=this.context;if(0<a.length)return a[0].oAjaxData});p("ajax.reload()",function(a,b){return this.iterator("table",function(c){Vb(c,!1===b,a)})});p("ajax.url()",function(a){var b=
 this.context;if(a===k){if(0===b.length)return k;b=b[0];return b.ajax?h.isPlainObject(b.ajax)?b.ajax.url:b.ajax:b.sAjaxSource}return this.iterator("table",function(b){h.isPlainObject(b.ajax)?b.ajax.url=a:b.ajax=a})});p("ajax.url().load()",function(a,b){return this.iterator("table",function(c){Vb(c,!1===b,a)})});var bb=function(a,b,c,d,e){var f=[],g,j,i,n,l,m;i=typeof b;if(!b||"string"===i||"function"===i||b.length===k)b=[b];i=0;for(n=b.length;i<n;i++){j=b[i]&&b[i].split&&!b[i].match(/[\[\(:]/)?b[i].split(","):
 [b[i]];l=0;for(m=j.length;l<m;l++)(g=c("string"===typeof j[l]?h.trim(j[l]):j[l]))&&g.length&&(f=f.concat(g))}a=x.selector[a];if(a.length){i=0;for(n=a.length;i<n;i++)f=a[i](d,e,f)}return sa(f)},cb=function(a){a||(a={});a.filter&&a.search===k&&(a.search=a.filter);return h.extend({search:"none",order:"current",page:"all"},a)},db=function(a){for(var b=0,c=a.length;b<c;b++)if(0<a[b].length)return a[0]=a[b],a[0].length=1,a.length=1,a.context=[a.context[b]],a;a.length=0;return a},Da=function(a,b){var c,
 d,e,f=[],g=a.aiDisplay;c=a.aiDisplayMaster;var j=b.search;d=b.order;e=b.page;if("ssp"==y(a))return"removed"===j?[]:X(0,c.length);if("current"==e){c=a._iDisplayStart;for(d=a.fnDisplayEnd();c<d;c++)f.push(g[c])}else if("current"==d||"applied"==d)f="none"==j?c.slice():"applied"==j?g.slice():h.map(c,function(a){return-1===h.inArray(a,g)?a:null});else if("index"==d||"original"==d){c=0;for(d=a.aoData.length;c<d;c++)"none"==j?f.push(c):(e=h.inArray(c,g),(-1===e&&"removed"==j||0<=e&&"applied"==j)&&f.push(c))}return f};
 p("rows()",function(a,b){a===k?a="":h.isPlainObject(a)&&(b=a,a="");var b=cb(b),c=this.iterator("table",function(c){var e=b,f;return bb("row",a,function(a){var b=Qb(a);if(b!==null&&!e)return[b];f||(f=Da(c,e));if(b!==null&&h.inArray(b,f)!==-1)return[b];if(a===null||a===k||a==="")return f;if(typeof a==="function")return h.map(f,function(b){var e=c.aoData[b];return a(b,e._aData,e.nTr)?b:null});b=Tb(ja(c.aoData,f,"nTr"));if(a.nodeName){if(a._DT_RowIndex!==k)return[a._DT_RowIndex];if(a._DT_CellIndex)return[a._DT_CellIndex.row];
 b=h(a).closest("*[data-dt-row]");return b.length?[b.data("dt-row")]:[]}if(typeof a==="string"&&a.charAt(0)==="#"){var i=c.aIds[a.replace(/^#/,"")];if(i!==k)return[i.idx]}return h(b).filter(a).map(function(){return this._DT_RowIndex}).toArray()},c,e)},1);c.selector.rows=a;c.selector.opts=b;return c});p("rows().nodes()",function(){return this.iterator("row",function(a,b){return a.aoData[b].nTr||k},1)});p("rows().data()",function(){return this.iterator(!0,"rows",function(a,b){return ja(a.aoData,b,"_aData")},
 1)});u("rows().cache()","row().cache()",function(a){return this.iterator("row",function(b,c){var d=b.aoData[c];return"search"===a?d._aFilterData:d._aSortData},1)});u("rows().invalidate()","row().invalidate()",function(a){return this.iterator("row",function(b,c){da(b,c,a)})});u("rows().indexes()","row().index()",function(){return this.iterator("row",function(a,b){return b},1)});u("rows().ids()","row().id()",function(a){for(var b=[],c=this.context,d=0,e=c.length;d<e;d++)for(var f=0,g=this[d].length;f<
 g;f++){var h=c[d].rowIdFn(c[d].aoData[this[d][f]]._aData);b.push((!0===a?"#":"")+h)}return new t(c,b)});u("rows().remove()","row().remove()",function(){var a=this;this.iterator("row",function(b,c,d){var e=b.aoData,f=e[c],g,h,i,n,l;e.splice(c,1);g=0;for(h=e.length;g<h;g++)if(i=e[g],l=i.anCells,null!==i.nTr&&(i.nTr._DT_RowIndex=g),null!==l){i=0;for(n=l.length;i<n;i++)l[i]._DT_CellIndex.row=g}qa(b.aiDisplayMaster,c);qa(b.aiDisplay,c);qa(a[d],c,!1);Ua(b);c=b.rowIdFn(f._aData);c!==k&&delete b.aIds[c]});
 this.iterator("table",function(a){for(var c=0,d=a.aoData.length;c<d;c++)a.aoData[c].idx=c});return this});p("rows.add()",function(a){var b=this.iterator("table",function(b){var c,f,g,h=[];f=0;for(g=a.length;f<g;f++)c=a[f],c.nodeName&&"TR"===c.nodeName.toUpperCase()?h.push(oa(b,c)[0]):h.push(N(b,c));return h},1),c=this.rows(-1);c.pop();h.merge(c,b);return c});p("row()",function(a,b){return db(this.rows(a,b))});p("row().data()",function(a){var b=this.context;if(a===k)return b.length&&this.length?b[0].aoData[this[0]]._aData:
 k;b[0].aoData[this[0]]._aData=a;da(b[0],this[0],"data");return this});p("row().node()",function(){var a=this.context;return a.length&&this.length?a[0].aoData[this[0]].nTr||null:null});p("row.add()",function(a){a instanceof h&&a.length&&(a=a[0]);var b=this.iterator("table",function(b){return a.nodeName&&"TR"===a.nodeName.toUpperCase()?oa(b,a)[0]:N(b,a)});return this.row(b[0])});var eb=function(a,b){var c=a.context;if(c.length&&(c=c[0].aoData[b!==k?b:a[0]])&&c._details)c._details.remove(),c._detailsShow=
 k,c._details=k},Wb=function(a,b){var c=a.context;if(c.length&&a.length){var d=c[0].aoData[a[0]];if(d._details){(d._detailsShow=b)?d._details.insertAfter(d.nTr):d._details.detach();var e=c[0],f=new t(e),g=e.aoData;f.off("draw.dt.DT_details column-visibility.dt.DT_details destroy.dt.DT_details");0<D(g,"_details").length&&(f.on("draw.dt.DT_details",function(a,b){e===b&&f.rows({page:"current"}).eq(0).each(function(a){a=g[a];a._detailsShow&&a._details.insertAfter(a.nTr)})}),f.on("column-visibility.dt.DT_details",
 function(a,b){if(e===b)for(var c,d=ba(b),f=0,h=g.length;f<h;f++)c=g[f],c._details&&c._details.children("td[colspan]").attr("colspan",d)}),f.on("destroy.dt.DT_details",function(a,b){if(e===b)for(var c=0,d=g.length;c<d;c++)g[c]._details&&eb(f,c)}))}}};p("row().child()",function(a,b){var c=this.context;if(a===k)return c.length&&this.length?c[0].aoData[this[0]]._details:k;if(!0===a)this.child.show();else if(!1===a)eb(this);else if(c.length&&this.length){var d=c[0],c=c[0].aoData[this[0]],e=[],f=function(a,
 b){if(h.isArray(a)||a instanceof h)for(var c=0,k=a.length;c<k;c++)f(a[c],b);else a.nodeName&&"tr"===a.nodeName.toLowerCase()?e.push(a):(c=h("<tr><td/></tr>").addClass(b),h("td",c).addClass(b).html(a)[0].colSpan=ba(d),e.push(c[0]))};f(a,b);c._details&&c._details.detach();c._details=h(e);c._detailsShow&&c._details.insertAfter(c.nTr)}return this});p(["row().child.show()","row().child().show()"],function(){Wb(this,!0);return this});p(["row().child.hide()","row().child().hide()"],function(){Wb(this,!1);
 return this});p(["row().child.remove()","row().child().remove()"],function(){eb(this);return this});p("row().child.isShown()",function(){var a=this.context;return a.length&&this.length?a[0].aoData[this[0]]._detailsShow||!1:!1});var fc=/^([^:]+):(name|visIdx|visible)$/,Xb=function(a,b,c,d,e){for(var c=[],d=0,f=e.length;d<f;d++)c.push(B(a,e[d],b));return c};p("columns()",function(a,b){a===k?a="":h.isPlainObject(a)&&(b=a,a="");var b=cb(b),c=this.iterator("table",function(c){var e=a,f=b,g=c.aoColumns,
 j=D(g,"sName"),i=D(g,"nTh");return bb("column",e,function(a){var b=Qb(a);if(a==="")return X(g.length);if(b!==null)return[b>=0?b:g.length+b];if(typeof a==="function"){var e=Da(c,f);return h.map(g,function(b,f){return a(f,Xb(c,f,0,0,e),i[f])?f:null})}var k=typeof a==="string"?a.match(fc):"";if(k)switch(k[2]){case "visIdx":case "visible":b=parseInt(k[1],10);if(b<0){var m=h.map(g,function(a,b){return a.bVisible?b:null});return[m[m.length+b]]}return[$(c,b)];case "name":return h.map(j,function(a,b){return a===
 k[1]?b:null});default:return[]}if(a.nodeName&&a._DT_CellIndex)return[a._DT_CellIndex.column];b=h(i).filter(a).map(function(){return h.inArray(this,i)}).toArray();if(b.length||!a.nodeName)return b;b=h(a).closest("*[data-dt-column]");return b.length?[b.data("dt-column")]:[]},c,f)},1);c.selector.cols=a;c.selector.opts=b;return c});u("columns().header()","column().header()",function(){return this.iterator("column",function(a,b){return a.aoColumns[b].nTh},1)});u("columns().footer()","column().footer()",
 function(){return this.iterator("column",function(a,b){return a.aoColumns[b].nTf},1)});u("columns().data()","column().data()",function(){return this.iterator("column-rows",Xb,1)});u("columns().dataSrc()","column().dataSrc()",function(){return this.iterator("column",function(a,b){return a.aoColumns[b].mData},1)});u("columns().cache()","column().cache()",function(a){return this.iterator("column-rows",function(b,c,d,e,f){return ja(b.aoData,f,"search"===a?"_aFilterData":"_aSortData",c)},1)});u("columns().nodes()",
 "column().nodes()",function(){return this.iterator("column-rows",function(a,b,c,d,e){return ja(a.aoData,e,"anCells",b)},1)});u("columns().visible()","column().visible()",function(a,b){var c=this.iterator("column",function(b,c){if(a===k)return b.aoColumns[c].bVisible;var f=b.aoColumns,g=f[c],j=b.aoData,i,n,l;if(a!==k&&g.bVisible!==a){if(a){var m=h.inArray(!0,D(f,"bVisible"),c+1);i=0;for(n=j.length;i<n;i++)l=j[i].nTr,f=j[i].anCells,l&&l.insertBefore(f[c],f[m]||null)}else h(D(b.aoData,"anCells",c)).detach();
 g.bVisible=a;fa(b,b.aoHeader);fa(b,b.aoFooter);za(b)}});a!==k&&(this.iterator("column",function(c,e){s(c,null,"column-visibility",[c,e,a,b])}),(b===k||b)&&this.columns.adjust());return c});u("columns().indexes()","column().index()",function(a){return this.iterator("column",function(b,c){return"visible"===a?aa(b,c):c},1)});p("columns.adjust()",function(){return this.iterator("table",function(a){Z(a)},1)});p("column.index()",function(a,b){if(0!==this.context.length){var c=this.context[0];if("fromVisible"===
 a||"toData"===a)return $(c,b);if("fromData"===a||"toVisible"===a)return aa(c,b)}});p("column()",function(a,b){return db(this.columns(a,b))});p("cells()",function(a,b,c){h.isPlainObject(a)&&(a.row===k?(c=a,a=null):(c=b,b=null));h.isPlainObject(b)&&(c=b,b=null);if(null===b||b===k)return this.iterator("table",function(b){var d=a,e=cb(c),f=b.aoData,g=Da(b,e),j=Tb(ja(f,g,"anCells")),i=h([].concat.apply([],j)),l,n=b.aoColumns.length,m,p,u,t,s,v;return bb("cell",d,function(a){var c=typeof a==="function";
 if(a===null||a===k||c){m=[];p=0;for(u=g.length;p<u;p++){l=g[p];for(t=0;t<n;t++){s={row:l,column:t};if(c){v=f[l];a(s,B(b,l,t),v.anCells?v.anCells[t]:null)&&m.push(s)}else m.push(s)}}return m}if(h.isPlainObject(a))return[a];c=i.filter(a).map(function(a,b){return{row:b._DT_CellIndex.row,column:b._DT_CellIndex.column}}).toArray();if(c.length||!a.nodeName)return c;v=h(a).closest("*[data-dt-row]");return v.length?[{row:v.data("dt-row"),column:v.data("dt-column")}]:[]},b,e)});var d=this.columns(b,c),e=this.rows(a,
 c),f,g,j,i,n,l=this.iterator("table",function(a,b){f=[];g=0;for(j=e[b].length;g<j;g++){i=0;for(n=d[b].length;i<n;i++)f.push({row:e[b][g],column:d[b][i]})}return f},1);h.extend(l.selector,{cols:b,rows:a,opts:c});return l});u("cells().nodes()","cell().node()",function(){return this.iterator("cell",function(a,b,c){return(a=a.aoData[b])&&a.anCells?a.anCells[c]:k},1)});p("cells().data()",function(){return this.iterator("cell",function(a,b,c){return B(a,b,c)},1)});u("cells().cache()","cell().cache()",function(a){a=
 "search"===a?"_aFilterData":"_aSortData";return this.iterator("cell",function(b,c,d){return b.aoData[c][a][d]},1)});u("cells().render()","cell().render()",function(a){return this.iterator("cell",function(b,c,d){return B(b,c,d,a)},1)});u("cells().indexes()","cell().index()",function(){return this.iterator("cell",function(a,b,c){return{row:b,column:c,columnVisible:aa(a,c)}},1)});u("cells().invalidate()","cell().invalidate()",function(a){return this.iterator("cell",function(b,c,d){da(b,c,a,d)})});p("cell()",
 function(a,b,c){return db(this.cells(a,b,c))});p("cell().data()",function(a){var b=this.context,c=this[0];if(a===k)return b.length&&c.length?B(b[0],c[0].row,c[0].column):k;lb(b[0],c[0].row,c[0].column,a);da(b[0],c[0].row,"data",c[0].column);return this});p("order()",function(a,b){var c=this.context;if(a===k)return 0!==c.length?c[0].aaSorting:k;"number"===typeof a?a=[[a,b]]:a.length&&!h.isArray(a[0])&&(a=Array.prototype.slice.call(arguments));return this.iterator("table",function(b){b.aaSorting=a.slice()})});
 p("order.listener()",function(a,b,c){return this.iterator("table",function(d){Oa(d,a,b,c)})});p("order.fixed()",function(a){if(!a){var b=this.context,b=b.length?b[0].aaSortingFixed:k;return h.isArray(b)?{pre:b}:b}return this.iterator("table",function(b){b.aaSortingFixed=h.extend(!0,{},a)})});p(["columns().order()","column().order()"],function(a){var b=this;return this.iterator("table",function(c,d){var e=[];h.each(b[d],function(b,c){e.push([c,a])});c.aaSorting=e})});p("search()",function(a,b,c,d){var e=
 this.context;return a===k?0!==e.length?e[0].oPreviousSearch.sSearch:k:this.iterator("table",function(e){e.oFeatures.bFilter&&ga(e,h.extend({},e.oPreviousSearch,{sSearch:a+"",bRegex:null===b?!1:b,bSmart:null===c?!0:c,bCaseInsensitive:null===d?!0:d}),1)})});u("columns().search()","column().search()",function(a,b,c,d){return this.iterator("column",function(e,f){var g=e.aoPreSearchCols;if(a===k)return g[f].sSearch;e.oFeatures.bFilter&&(h.extend(g[f],{sSearch:a+"",bRegex:null===b?!1:b,bSmart:null===c?
 !0:c,bCaseInsensitive:null===d?!0:d}),ga(e,e.oPreviousSearch,1))})});p("state()",function(){return this.context.length?this.context[0].oSavedState:null});p("state.clear()",function(){return this.iterator("table",function(a){a.fnStateSaveCallback.call(a.oInstance,a,{})})});p("state.loaded()",function(){return this.context.length?this.context[0].oLoadedState:null});p("state.save()",function(){return this.iterator("table",function(a){za(a)})});m.versionCheck=m.fnVersionCheck=function(a){for(var b=m.version.split("."),
 a=a.split("."),c,d,e=0,f=a.length;e<f;e++)if(c=parseInt(b[e],10)||0,d=parseInt(a[e],10)||0,c!==d)return c>d;return!0};m.isDataTable=m.fnIsDataTable=function(a){var b=h(a).get(0),c=!1;if(a instanceof m.Api)return!0;h.each(m.settings,function(a,e){var f=e.nScrollHead?h("table",e.nScrollHead)[0]:null,g=e.nScrollFoot?h("table",e.nScrollFoot)[0]:null;if(e.nTable===b||f===b||g===b)c=!0});return c};m.tables=m.fnTables=function(a){var b=!1;h.isPlainObject(a)&&(b=a.api,a=a.visible);var c=h.map(m.settings,
 function(b){if(!a||a&&h(b.nTable).is(":visible"))return b.nTable});return b?new t(c):c};m.camelToHungarian=J;p("$()",function(a,b){var c=this.rows(b).nodes(),c=h(c);return h([].concat(c.filter(a).toArray(),c.find(a).toArray()))});h.each(["on","one","off"],function(a,b){p(b+"()",function(){var a=Array.prototype.slice.call(arguments);a[0]=h.map(a[0].split(/\s/),function(a){return!a.match(/\.dt\b/)?a+".dt":a}).join(" ");var d=h(this.tables().nodes());d[b].apply(d,a);return this})});p("clear()",function(){return this.iterator("table",
 function(a){pa(a)})});p("settings()",function(){return new t(this.context,this.context)});p("init()",function(){var a=this.context;return a.length?a[0].oInit:null});p("data()",function(){return this.iterator("table",function(a){return D(a.aoData,"_aData")}).flatten()});p("destroy()",function(a){a=a||!1;return this.iterator("table",function(b){var c=b.nTableWrapper.parentNode,d=b.oClasses,e=b.nTable,f=b.nTBody,g=b.nTHead,j=b.nTFoot,i=h(e),f=h(f),k=h(b.nTableWrapper),l=h.map(b.aoData,function(a){return a.nTr}),
 p;b.bDestroying=!0;s(b,"aoDestroyCallback","destroy",[b]);a||(new t(b)).columns().visible(!0);k.off(".DT").find(":not(tbody *)").off(".DT");h(E).off(".DT-"+b.sInstance);e!=g.parentNode&&(i.children("thead").detach(),i.append(g));j&&e!=j.parentNode&&(i.children("tfoot").detach(),i.append(j));b.aaSorting=[];b.aaSortingFixed=[];ya(b);h(l).removeClass(b.asStripeClasses.join(" "));h("th, td",g).removeClass(d.sSortable+" "+d.sSortableAsc+" "+d.sSortableDesc+" "+d.sSortableNone);b.bJUI&&(h("th span."+d.sSortIcon+
 ", td span."+d.sSortIcon,g).detach(),h("th, td",g).each(function(){var a=h("div."+d.sSortJUIWrapper,this);h(this).append(a.contents());a.detach()}));f.children().detach();f.append(l);g=a?"remove":"detach";i[g]();k[g]();!a&&c&&(c.insertBefore(e,b.nTableReinsertBefore),i.css("width",b.sDestroyWidth).removeClass(d.sTable),(p=b.asDestroyStripes.length)&&f.children().each(function(a){h(this).addClass(b.asDestroyStripes[a%p])}));c=h.inArray(b,m.settings);-1!==c&&m.settings.splice(c,1)})});h.each(["column",
 "row","cell"],function(a,b){p(b+"s().every()",function(a){var d=this.selector.opts,e=this;return this.iterator(b,function(f,g,h,i,m){a.call(e[b](g,"cell"===b?h:d,"cell"===b?d:k),g,h,i,m)})})});p("i18n()",function(a,b,c){var d=this.context[0],a=R(a)(d.oLanguage);a===k&&(a=b);c!==k&&h.isPlainObject(a)&&(a=a[c]!==k?a[c]:a._);return a.replace("%d",c)});m.version="1.10.15";m.settings=[];m.models={};m.models.oSearch={bCaseInsensitive:!0,sSearch:"",bRegex:!1,bSmart:!0};m.models.oRow={nTr:null,anCells:null,
 _aData:[],_aSortData:null,_aFilterData:null,_sFilterRow:null,_sRowStripe:"",src:null,idx:-1};m.models.oColumn={idx:null,aDataSort:null,asSorting:null,bSearchable:null,bSortable:null,bVisible:null,_sManualType:null,_bAttrSrc:!1,fnCreatedCell:null,fnGetData:null,fnSetData:null,mData:null,mRender:null,nTh:null,nTf:null,sClass:null,sContentPadding:null,sDefaultContent:null,sName:null,sSortDataType:"std",sSortingClass:null,sSortingClassJUI:null,sTitle:null,sType:null,sWidth:null,sWidthOrig:null};m.defaults=
 {aaData:null,aaSorting:[[0,"asc"]],aaSortingFixed:[],ajax:null,aLengthMenu:[10,25,50,100],aoColumns:null,aoColumnDefs:null,aoSearchCols:[],asStripeClasses:null,bAutoWidth:!0,bDeferRender:!1,bDestroy:!1,bFilter:!0,bInfo:!0,bJQueryUI:!1,bLengthChange:!0,bPaginate:!0,bProcessing:!1,bRetrieve:!1,bScrollCollapse:!1,bServerSide:!1,bSort:!0,bSortMulti:!0,bSortCellsTop:!1,bSortClasses:!0,bStateSave:!1,fnCreatedRow:null,fnDrawCallback:null,fnFooterCallback:null,fnFormatNumber:function(a){return a.toString().replace(/\B(?=(\d{3})+(?!\d))/g,
 this.oLanguage.sThousands)},fnHeaderCallback:null,fnInfoCallback:null,fnInitComplete:null,fnPreDrawCallback:null,fnRowCallback:null,fnServerData:null,fnServerParams:null,fnStateLoadCallback:function(a){try{return JSON.parse((-1===a.iStateDuration?sessionStorage:localStorage).getItem("DataTables_"+a.sInstance+"_"+location.pathname))}catch(b){}},fnStateLoadParams:null,fnStateLoaded:null,fnStateSaveCallback:function(a,b){try{(-1===a.iStateDuration?sessionStorage:localStorage).setItem("DataTables_"+a.sInstance+
 "_"+location.pathname,JSON.stringify(b))}catch(c){}},fnStateSaveParams:null,iStateDuration:7200,iDeferLoading:null,iDisplayLength:10,iDisplayStart:0,iTabIndex:0,oClasses:{},oLanguage:{oAria:{sSortAscending:": activate to sort column ascending",sSortDescending:": activate to sort column descending"},oPaginate:{sFirst:"First",sLast:"Last",sNext:"Next",sPrevious:"Previous"},sEmptyTable:"No data available in table",sInfo:"Showing _START_ to _END_ of _TOTAL_ entries",sInfoEmpty:"Showing 0 to 0 of 0 entries",
 sInfoFiltered:"(filtered from _MAX_ total entries)",sInfoPostFix:"",sDecimal:"",sThousands:",",sLengthMenu:"Show _MENU_ entries",sLoadingRecords:"Loading...",sProcessing:"Processing...",sSearch:"Search:",sSearchPlaceholder:"",sUrl:"",sZeroRecords:"No matching records found"},oSearch:h.extend({},m.models.oSearch),sAjaxDataProp:"data",sAjaxSource:null,sDom:"lfrtip",searchDelay:null,sPaginationType:"simple_numbers",sScrollX:"",sScrollXInner:"",sScrollY:"",sServerMethod:"GET",renderer:null,rowId:"DT_RowId"};
 Y(m.defaults);m.defaults.column={aDataSort:null,iDataSort:-1,asSorting:["asc","desc"],bSearchable:!0,bSortable:!0,bVisible:!0,fnCreatedCell:null,mData:null,mRender:null,sCellType:"td",sClass:"",sContentPadding:"",sDefaultContent:null,sName:"",sSortDataType:"std",sTitle:null,sType:null,sWidth:null};Y(m.defaults.column);m.models.oSettings={oFeatures:{bAutoWidth:null,bDeferRender:null,bFilter:null,bInfo:null,bLengthChange:null,bPaginate:null,bProcessing:null,bServerSide:null,bSort:null,bSortMulti:null,
 bSortClasses:null,bStateSave:null},oScroll:{bCollapse:null,iBarWidth:0,sX:null,sXInner:null,sY:null},oLanguage:{fnInfoCallback:null},oBrowser:{bScrollOversize:!1,bScrollbarLeft:!1,bBounding:!1,barWidth:0},ajax:null,aanFeatures:[],aoData:[],aiDisplay:[],aiDisplayMaster:[],aIds:{},aoColumns:[],aoHeader:[],aoFooter:[],oPreviousSearch:{},aoPreSearchCols:[],aaSorting:null,aaSortingFixed:[],asStripeClasses:null,asDestroyStripes:[],sDestroyWidth:0,aoRowCallback:[],aoHeaderCallback:[],aoFooterCallback:[],
 aoDrawCallback:[],aoRowCreatedCallback:[],aoPreDrawCallback:[],aoInitComplete:[],aoStateSaveParams:[],aoStateLoadParams:[],aoStateLoaded:[],sTableId:"",nTable:null,nTHead:null,nTFoot:null,nTBody:null,nTableWrapper:null,bDeferLoading:!1,bInitialised:!1,aoOpenRows:[],sDom:null,searchDelay:null,sPaginationType:"two_button",iStateDuration:0,aoStateSave:[],aoStateLoad:[],oSavedState:null,oLoadedState:null,sAjaxSource:null,sAjaxDataProp:null,bAjaxDataGet:!0,jqXHR:null,json:k,oAjaxData:k,fnServerData:null,
 aoServerParams:[],sServerMethod:null,fnFormatNumber:null,aLengthMenu:null,iDraw:0,bDrawing:!1,iDrawError:-1,_iDisplayLength:10,_iDisplayStart:0,_iRecordsTotal:0,_iRecordsDisplay:0,bJUI:null,oClasses:{},bFiltered:!1,bSorted:!1,bSortCellsTop:null,oInit:null,aoDestroyCallback:[],fnRecordsTotal:function(){return"ssp"==y(this)?1*this._iRecordsTotal:this.aiDisplayMaster.length},fnRecordsDisplay:function(){return"ssp"==y(this)?1*this._iRecordsDisplay:this.aiDisplay.length},fnDisplayEnd:function(){var a=
 this._iDisplayLength,b=this._iDisplayStart,c=b+a,d=this.aiDisplay.length,e=this.oFeatures,f=e.bPaginate;return e.bServerSide?!1===f||-1===a?b+d:Math.min(b+a,this._iRecordsDisplay):!f||c>d||-1===a?d:c},oInstance:null,sInstance:null,iTabIndex:0,nScrollHead:null,nScrollFoot:null,aLastSort:[],oPlugins:{},rowIdFn:null,rowId:null};m.ext=x={buttons:{},classes:{},builder:"-source-",errMode:"alert",feature:[],search:[],selector:{cell:[],column:[],row:[]},internal:{},legacy:{ajax:null},pager:{},renderer:{pageButton:{},
 header:{}},order:{},type:{detect:[],search:{},order:{}},_unique:0,fnVersionCheck:m.fnVersionCheck,iApiIndex:0,oJUIClasses:{},sVersion:m.version};h.extend(x,{afnFiltering:x.search,aTypes:x.type.detect,ofnSearch:x.type.search,oSort:x.type.order,afnSortData:x.order,aoFeatures:x.feature,oApi:x.internal,oStdClasses:x.classes,oPagination:x.pager});h.extend(m.ext.classes,{sTable:"dataTable",sNoFooter:"no-footer",sPageButton:"paginate_button",sPageButtonActive:"current",sPageButtonDisabled:"disabled",sStripeOdd:"odd",
 sStripeEven:"even",sRowEmpty:"dataTables_empty",sWrapper:"dataTables_wrapper",sFilter:"dataTables_filter",sInfo:"dataTables_info",sPaging:"dataTables_paginate paging_",sLength:"dataTables_length",sProcessing:"dataTables_processing",sSortAsc:"sorting_asc",sSortDesc:"sorting_desc",sSortable:"sorting",sSortableAsc:"sorting_asc_disabled",sSortableDesc:"sorting_desc_disabled",sSortableNone:"sorting_disabled",sSortColumn:"sorting_",sFilterInput:"",sLengthSelect:"",sScrollWrapper:"dataTables_scroll",sScrollHead:"dataTables_scrollHead",
 sScrollHeadInner:"dataTables_scrollHeadInner",sScrollBody:"dataTables_scrollBody",sScrollFoot:"dataTables_scrollFoot",sScrollFootInner:"dataTables_scrollFootInner",sHeaderTH:"",sFooterTH:"",sSortJUIAsc:"",sSortJUIDesc:"",sSortJUI:"",sSortJUIAscAllowed:"",sSortJUIDescAllowed:"",sSortJUIWrapper:"",sSortIcon:"",sJUIHeader:"",sJUIFooter:""});var Ea="",Ea="",G=Ea+"ui-state-default",ka=Ea+"css_right ui-icon ui-icon-",Yb=Ea+"fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix";h.extend(m.ext.oJUIClasses,
 m.ext.classes,{sPageButton:"fg-button ui-button "+G,sPageButtonActive:"ui-state-disabled",sPageButtonDisabled:"ui-state-disabled",sPaging:"dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ui-buttonset-multi paging_",sSortAsc:G+" sorting_asc",sSortDesc:G+" sorting_desc",sSortable:G+" sorting",sSortableAsc:G+" sorting_asc_disabled",sSortableDesc:G+" sorting_desc_disabled",sSortableNone:G+" sorting_disabled",sSortJUIAsc:ka+"triangle-1-n",sSortJUIDesc:ka+"triangle-1-s",sSortJUI:ka+"carat-2-n-s",
 sSortJUIAscAllowed:ka+"carat-1-n",sSortJUIDescAllowed:ka+"carat-1-s",sSortJUIWrapper:"DataTables_sort_wrapper",sSortIcon:"DataTables_sort_icon",sScrollHead:"dataTables_scrollHead "+G,sScrollFoot:"dataTables_scrollFoot "+G,sHeaderTH:G,sFooterTH:G,sJUIHeader:Yb+" ui-corner-tl ui-corner-tr",sJUIFooter:Yb+" ui-corner-bl ui-corner-br"});var Nb=m.ext.pager;h.extend(Nb,{simple:function(){return["previous","next"]},full:function(){return["first","previous","next","last"]},numbers:function(a,b){return[ia(a,
 b)]},simple_numbers:function(a,b){return["previous",ia(a,b),"next"]},full_numbers:function(a,b){return["first","previous",ia(a,b),"next","last"]},first_last_numbers:function(a,b){return["first",ia(a,b),"last"]},_numbers:ia,numbers_length:7});h.extend(!0,m.ext.renderer,{pageButton:{_:function(a,b,c,d,e,f){var g=a.oClasses,j=a.oLanguage.oPaginate,i=a.oLanguage.oAria.paginate||{},m,l,p=0,r=function(b,d){var k,t,u,s,v=function(b){Va(a,b.data.action,true)};k=0;for(t=d.length;k<t;k++){s=d[k];if(h.isArray(s)){u=
 h("<"+(s.DT_el||"div")+"/>").appendTo(b);r(u,s)}else{m=null;l="";switch(s){case "ellipsis":b.append('<span class="ellipsis">&#x2026;</span>');break;case "first":m=j.sFirst;l=s+(e>0?"":" "+g.sPageButtonDisabled);break;case "previous":m=j.sPrevious;l=s+(e>0?"":" "+g.sPageButtonDisabled);break;case "next":m=j.sNext;l=s+(e<f-1?"":" "+g.sPageButtonDisabled);break;case "last":m=j.sLast;l=s+(e<f-1?"":" "+g.sPageButtonDisabled);break;default:m=s+1;l=e===s?g.sPageButtonActive:""}if(m!==null){u=h("<a>",{"class":g.sPageButton+
 " "+l,"aria-controls":a.sTableId,"aria-label":i[s],"data-dt-idx":p,tabindex:a.iTabIndex,id:c===0&&typeof s==="string"?a.sTableId+"_"+s:null}).html(m).appendTo(b);Ya(u,{action:s},v);p++}}}},t;try{t=h(b).find(H.activeElement).data("dt-idx")}catch(u){}r(h(b).empty(),d);t!==k&&h(b).find("[data-dt-idx="+t+"]").focus()}}});h.extend(m.ext.type.detect,[function(a,b){var c=b.oLanguage.sDecimal;return ab(a,c)?"num"+c:null},function(a){if(a&&!(a instanceof Date)&&!cc.test(a))return null;var b=Date.parse(a);
 return null!==b&&!isNaN(b)||M(a)?"date":null},function(a,b){var c=b.oLanguage.sDecimal;return ab(a,c,!0)?"num-fmt"+c:null},function(a,b){var c=b.oLanguage.sDecimal;return Sb(a,c)?"html-num"+c:null},function(a,b){var c=b.oLanguage.sDecimal;return Sb(a,c,!0)?"html-num-fmt"+c:null},function(a){return M(a)||"string"===typeof a&&-1!==a.indexOf("<")?"html":null}]);h.extend(m.ext.type.search,{html:function(a){return M(a)?a:"string"===typeof a?a.replace(Pb," ").replace(Ca,""):""},string:function(a){return M(a)?
 a:"string"===typeof a?a.replace(Pb," "):a}});var Ba=function(a,b,c,d){if(0!==a&&(!a||"-"===a))return-Infinity;b&&(a=Rb(a,b));a.replace&&(c&&(a=a.replace(c,"")),d&&(a=a.replace(d,"")));return 1*a};h.extend(x.type.order,{"date-pre":function(a){return Date.parse(a)||-Infinity},"html-pre":function(a){return M(a)?"":a.replace?a.replace(/<.*?>/g,"").toLowerCase():a+""},"string-pre":function(a){return M(a)?"":"string"===typeof a?a.toLowerCase():!a.toString?"":a.toString()},"string-asc":function(a,b){return a<
 b?-1:a>b?1:0},"string-desc":function(a,b){return a<b?1:a>b?-1:0}});fb("");h.extend(!0,m.ext.renderer,{header:{_:function(a,b,c,d){h(a.nTable).on("order.dt.DT",function(e,f,g,h){if(a===f){e=c.idx;b.removeClass(c.sSortingClass+" "+d.sSortAsc+" "+d.sSortDesc).addClass(h[e]=="asc"?d.sSortAsc:h[e]=="desc"?d.sSortDesc:c.sSortingClass)}})},jqueryui:function(a,b,c,d){h("<div/>").addClass(d.sSortJUIWrapper).append(b.contents()).append(h("<span/>").addClass(d.sSortIcon+" "+c.sSortingClassJUI)).appendTo(b);
 h(a.nTable).on("order.dt.DT",function(e,f,g,h){if(a===f){e=c.idx;b.removeClass(d.sSortAsc+" "+d.sSortDesc).addClass(h[e]=="asc"?d.sSortAsc:h[e]=="desc"?d.sSortDesc:c.sSortingClass);b.find("span."+d.sSortIcon).removeClass(d.sSortJUIAsc+" "+d.sSortJUIDesc+" "+d.sSortJUI+" "+d.sSortJUIAscAllowed+" "+d.sSortJUIDescAllowed).addClass(h[e]=="asc"?d.sSortJUIAsc:h[e]=="desc"?d.sSortJUIDesc:c.sSortingClassJUI)}})}}});var Zb=function(a){return"string"===typeof a?a.replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,
 "&quot;"):a};m.render={number:function(a,b,c,d,e){return{display:function(f){if("number"!==typeof f&&"string"!==typeof f)return f;var g=0>f?"-":"",h=parseFloat(f);if(isNaN(h))return Zb(f);h=h.toFixed(c);f=Math.abs(h);h=parseInt(f,10);f=c?b+(f-h).toFixed(c).substring(2):"";return g+(d||"")+h.toString().replace(/\B(?=(\d{3})+(?!\d))/g,a)+f+(e||"")}}},text:function(){return{display:Zb}}};h.extend(m.ext.internal,{_fnExternApiFunc:Ob,_fnBuildAjax:ua,_fnAjaxUpdate:nb,_fnAjaxParameters:wb,_fnAjaxUpdateDraw:xb,
 _fnAjaxDataSrc:va,_fnAddColumn:Ga,_fnColumnOptions:la,_fnAdjustColumnSizing:Z,_fnVisibleToColumnIndex:$,_fnColumnIndexToVisible:aa,_fnVisbleColumns:ba,_fnGetColumns:na,_fnColumnTypes:Ia,_fnApplyColumnDefs:kb,_fnHungarianMap:Y,_fnCamelToHungarian:J,_fnLanguageCompat:Fa,_fnBrowserDetect:ib,_fnAddData:N,_fnAddTr:oa,_fnNodeToDataIndex:function(a,b){return b._DT_RowIndex!==k?b._DT_RowIndex:null},_fnNodeToColumnIndex:function(a,b,c){return h.inArray(c,a.aoData[b].anCells)},_fnGetCellData:B,_fnSetCellData:lb,
 _fnSplitObjNotation:La,_fnGetObjectDataFn:R,_fnSetObjectDataFn:S,_fnGetDataMaster:Ma,_fnClearTable:pa,_fnDeleteIndex:qa,_fnInvalidate:da,_fnGetRowElements:Ka,_fnCreateTr:Ja,_fnBuildHead:mb,_fnDrawHead:fa,_fnDraw:O,_fnReDraw:T,_fnAddOptionsHtml:pb,_fnDetectHeader:ea,_fnGetUniqueThs:ta,_fnFeatureHtmlFilter:rb,_fnFilterComplete:ga,_fnFilterCustom:Ab,_fnFilterColumn:zb,_fnFilter:yb,_fnFilterCreateSearch:Ra,_fnEscapeRegex:Sa,_fnFilterData:Bb,_fnFeatureHtmlInfo:ub,_fnUpdateInfo:Eb,_fnInfoMacros:Fb,_fnInitialise:ha,
 _fnInitComplete:wa,_fnLengthChange:Ta,_fnFeatureHtmlLength:qb,_fnFeatureHtmlPaginate:vb,_fnPageChange:Va,_fnFeatureHtmlProcessing:sb,_fnProcessingDisplay:C,_fnFeatureHtmlTable:tb,_fnScrollDraw:ma,_fnApplyToChildren:I,_fnCalculateColumnWidths:Ha,_fnThrottle:Qa,_fnConvertToWidth:Gb,_fnGetWidestNode:Hb,_fnGetMaxLenString:Ib,_fnStringToCss:v,_fnSortFlatten:W,_fnSort:ob,_fnSortAria:Kb,_fnSortListener:Xa,_fnSortAttachListener:Oa,_fnSortingClasses:ya,_fnSortData:Jb,_fnSaveState:za,_fnLoadState:Lb,_fnSettingsFromNode:Aa,
 _fnLog:K,_fnMap:F,_fnBindAction:Ya,_fnCallbackReg:z,_fnCallbackFire:s,_fnLengthOverflow:Ua,_fnRenderer:Pa,_fnDataSource:y,_fnRowAttributes:Na,_fnCalculateEnd:function(){}});h.fn.dataTable=m;m.$=h;h.fn.dataTableSettings=m.settings;h.fn.dataTableExt=m.ext;h.fn.DataTable=function(a){return h(this).dataTable(a).api()};h.each(m,function(a,b){h.fn.DataTable[a]=b});return h.fn.dataTable});
 </script>  
<script type="text/javascript">  
 var stIsIE = /*@cc_on!@*/false;
 
 sorttable = {
   init: function() {
     // quit if this function has already been called
     if (arguments.callee.done) return;
     // flag this function so we don't do the same thing twice
     arguments.callee.done = true;
     // kill the timer
     if (_timer) clearInterval(_timer);
 
     if (!document.createElement || !document.getElementsByTagName) return;
 
     sorttable.DATE_RE = /^(\d\d?)[\/\.-](\d\d?)[\/\.-]((\d\d)?\d\d)$/;
 
     forEach(document.getElementsByTagName('table'), function(table) {
       if (table.className.search(/\bsortable\b/) != -1) {
         sorttable.makeSortable(table);
       }
     });
 
   },
 
   makeSortable: function(table) {
     if (table.getElementsByTagName('thead').length == 0) {
       // table doesn't have a tHead. Since it should have, create one and
       // put the first table row in it.
       the = document.createElement('thead');
       the.appendChild(table.rows[0]);
       table.insertBefore(the,table.firstChild);
     }
     // Safari doesn't support table.tHead, sigh
     if (table.tHead == null) table.tHead = table.getElementsByTagName('thead')[0];
 
     if (table.tHead.rows.length != 1) return; // can't cope with two header rows
 
     // Sorttable v1 put rows with a class of "sortbottom" at the bottom (as
     // "total" rows, for example). This is B&R, since what you're supposed
     // to do is put them in a tfoot. So, if there are sortbottom rows,
     // for backwards compatibility, move them to tfoot (creating it if needed).
     sortbottomrows = [];
     for (var i=0; i<table.rows.length; i++) {
       if (table.rows[i].className.search(/\bsortbottom\b/) != -1) {
         sortbottomrows[sortbottomrows.length] = table.rows[i];
       }
     }
     if (sortbottomrows) {
       if (table.tFoot == null) {
         // table doesn't have a tfoot. Create one.
         tfo = document.createElement('tfoot');
         table.appendChild(tfo);
       }
       for (var i=0; i<sortbottomrows.length; i++) {
         tfo.appendChild(sortbottomrows[i]);
       }
       delete sortbottomrows;
     }
 
     // work through each column and calculate its type
     headrow = table.tHead.rows[0].cells;
     for (var i=0; i<headrow.length; i++) {
       // manually override the type with a sorttable_type attribute
       if (!headrow[i].className.match(/\bsorttable_nosort\b/)) { // skip this col
         mtch = headrow[i].className.match(/\bsorttable_([a-z0-9]+)\b/);
         if (mtch) { override = mtch[1]; }
 	      if (mtch && typeof sorttable["sort_"+override] == 'function') {
 	        headrow[i].sorttable_sortfunction = sorttable["sort_"+override];
 	      } else {
 	        headrow[i].sorttable_sortfunction = sorttable.guessType(table,i);
 	      }
 	      // make it clickable to sort
 	      headrow[i].sorttable_columnindex = i;
 	      headrow[i].sorttable_tbody = table.tBodies[0];
 	      dean_addEvent(headrow[i],"click", sorttable.innerSortFunction = function(e) {
 
           if (this.className.search(/\bsorttable_sorted\b/) != -1) {
             // if we're already sorted by this column, just
             // reverse the table, which is quicker
             sorttable.reverse(this.sorttable_tbody);
             this.className = this.className.replace('sorttable_sorted',
                                                     'sorttable_sorted_reverse');
             this.removeChild(document.getElementById('sorttable_sortfwdind'));
             sortrevind = document.createElement('span');
             sortrevind.id = "sorttable_sortrevind";
             sortrevind.innerHTML = stIsIE ? '&nbsp<font face="webdings">5</font>' : '&nbsp;&#x25B4;';
             this.appendChild(sortrevind);
             return;
           }
           if (this.className.search(/\bsorttable_sorted_reverse\b/) != -1) {
             // if we're already sorted by this column in reverse, just
             // re-reverse the table, which is quicker
             sorttable.reverse(this.sorttable_tbody);
             this.className = this.className.replace('sorttable_sorted_reverse',
                                                     'sorttable_sorted');
             this.removeChild(document.getElementById('sorttable_sortrevind'));
             sortfwdind = document.createElement('span');
             sortfwdind.id = "sorttable_sortfwdind";
             sortfwdind.innerHTML = stIsIE ? '&nbsp<font face="webdings">6</font>' : '&nbsp;&#x25BE;';
             this.appendChild(sortfwdind);
             return;
           }
 
           // remove sorttable_sorted classes
           theadrow = this.parentNode;
           forEach(theadrow.childNodes, function(cell) {
             if (cell.nodeType == 1) { // an element
               cell.className = cell.className.replace('sorttable_sorted_reverse','');
               cell.className = cell.className.replace('sorttable_sorted','');
             }
           });
           sortfwdind = document.getElementById('sorttable_sortfwdind');
           if (sortfwdind) { sortfwdind.parentNode.removeChild(sortfwdind); }
           sortrevind = document.getElementById('sorttable_sortrevind');
           if (sortrevind) { sortrevind.parentNode.removeChild(sortrevind); }
 
           this.className += ' sorttable_sorted';
           sortfwdind = document.createElement('span');
           sortfwdind.id = "sorttable_sortfwdind";
           sortfwdind.innerHTML = stIsIE ? '&nbsp<font face="webdings">6</font>' : '&nbsp;&#x25BE;';
           this.appendChild(sortfwdind);
 
 	        // build an array to sort. This is a Schwartzian transform thing,
 	        // i.e., we "decorate" each row with the actual sort key,
 	        // sort based on the sort keys, and then put the rows back in order
 	        // which is a lot faster because you only do getInnerText once per row
 	        row_array = [];
 	        col = this.sorttable_columnindex;
 	        rows = this.sorttable_tbody.rows;
 	        for (var j=0; j<rows.length; j++) {
 	          row_array[row_array.length] = [sorttable.getInnerText(rows[j].cells[col]), rows[j]];
 	        }
 	        /* If you want a stable sort, uncomment the following line */
 	        //sorttable.shaker_sort(row_array, this.sorttable_sortfunction);
 	        /* and comment out this one */
 	        row_array.sort(this.sorttable_sortfunction);
 
 	        tb = this.sorttable_tbody;
 	        for (var j=0; j<row_array.length; j++) {
 	          tb.appendChild(row_array[j][1]);
 	        }
 
 	        delete row_array;
 	      });
 	    }
     }
   },
 
   guessType: function(table, column) {
     // guess the type of a column based on its first non-blank row
     sortfn = sorttable.sort_alpha;
     for (var i=0; i<table.tBodies[0].rows.length; i++) {
       text = sorttable.getInnerText(table.tBodies[0].rows[i].cells[column]);
       if (text != '') {
         if (text.match(/^-?[?]?[\d,.]+%?$/)) {
           return sorttable.sort_numeric;
         }
         // check for a date: dd/mm/yyyy or dd/mm/yy
         // can have / or . or - as separator
         // can be mm/dd as well
         possdate = text.match(sorttable.DATE_RE)
         if (possdate) {
           // looks like a date
           first = parseInt(possdate[1]);
           second = parseInt(possdate[2]);
           if (first > 12) {
             // definitely dd/mm
             return sorttable.sort_ddmm;
           } else if (second > 12) {
             return sorttable.sort_mmdd;
           } else {
             // looks like a date, but we can't tell which, so assume
             // that it's dd/mm (English imperialism!) and keep looking
             sortfn = sorttable.sort_ddmm;
           }
         }
       }
     }
     return sortfn;
   },
 
   getInnerText: function(node) {
     // gets the text we want to use for sorting for a cell.
     // strips leading and trailing whitespace.
     // this is *not* a generic getInnerText function; it's special to sorttable.
     // for example, you can override the cell text with a customkey attribute.
     // it also gets .value for <input> fields.
 
     if (!node) return "";
 
     hasInputs = (typeof node.getElementsByTagName == 'function') &&
                  node.getElementsByTagName('input').length;
 
     if (node.getAttribute("sorttable_customkey") != null) {
       return node.getAttribute("sorttable_customkey");
     }
     else if (typeof node.textContent != 'undefined' && !hasInputs) {
       return node.textContent.replace(/^\s+|\s+$/g, '');
     }
     else if (typeof node.innerText != 'undefined' && !hasInputs) {
       return node.innerText.replace(/^\s+|\s+$/g, '');
     }
     else if (typeof node.text != 'undefined' && !hasInputs) {
       return node.text.replace(/^\s+|\s+$/g, '');
     }
     else {
       switch (node.nodeType) {
         case 3:
           if (node.nodeName.toLowerCase() == 'input') {
             return node.value.replace(/^\s+|\s+$/g, '');
           }
         case 4:
           return node.nodeValue.replace(/^\s+|\s+$/g, '');
           break;
         case 1:
         case 11:
           var innerText = '';
           for (var i = 0; i < node.childNodes.length; i++) {
             innerText += sorttable.getInnerText(node.childNodes[i]);
           }
           return innerText.replace(/^\s+|\s+$/g, '');
           break;
         default:
           return '';
       }
     }
   },
 
   reverse: function(tbody) {
     // reverse the rows in a tbody
     newrows = [];
     for (var i=0; i<tbody.rows.length; i++) {
       newrows[newrows.length] = tbody.rows[i];
     }
     for (var i=newrows.length-1; i>=0; i--) {
        tbody.appendChild(newrows[i]);
     }
     delete newrows;
   },
 
   /* sort functions
      each sort function takes two parameters, a and b
      you are comparing a[0] and b[0] */
   sort_numeric: function(a,b) {
     aa = parseFloat(a[0].replace(/[^0-9.-]/g,''));
     if (isNaN(aa)) aa = 0;
     bb = parseFloat(b[0].replace(/[^0-9.-]/g,''));
     if (isNaN(bb)) bb = 0;
     return aa-bb;
   },
   sort_alpha: function(a,b) {
     if (a[0]==b[0]) return 0;
     if (a[0]<b[0]) return -1;
     return 1;
   },
   sort_ddmm: function(a,b) {
     mtch = a[0].match(sorttable.DATE_RE);
     y = mtch[3]; m = mtch[2]; d = mtch[1];
     if (m.length == 1) m = '0'+m;
     if (d.length == 1) d = '0'+d;
     dt1 = y+m+d;
     mtch = b[0].match(sorttable.DATE_RE);
     y = mtch[3]; m = mtch[2]; d = mtch[1];
     if (m.length == 1) m = '0'+m;
     if (d.length == 1) d = '0'+d;
     dt2 = y+m+d;
     if (dt1==dt2) return 0;
     if (dt1<dt2) return -1;
     return 1;
   },
   sort_mmdd: function(a,b) {
     mtch = a[0].match(sorttable.DATE_RE);
     y = mtch[3]; d = mtch[2]; m = mtch[1];
     if (m.length == 1) m = '0'+m;
     if (d.length == 1) d = '0'+d;
     dt1 = y+m+d;
     mtch = b[0].match(sorttable.DATE_RE);
     y = mtch[3]; d = mtch[2]; m = mtch[1];
     if (m.length == 1) m = '0'+m;
     if (d.length == 1) d = '0'+d;
     dt2 = y+m+d;
     if (dt1==dt2) return 0;
     if (dt1<dt2) return -1;
     return 1;
   },
 
   shaker_sort: function(list, comp_func) {
     // A stable sort function to allow multi-level sorting of data
     // see: http://en.wikipedia.org/wiki/Cocktail_sort
     // thanks to Joseph Nahmias
     var b = 0;
     var t = list.length - 1;
     var swap = true;
 
     while(swap) {
         swap = false;
         for(var i = b; i < t; ++i) {
             if ( comp_func(list[i], list[i+1]) > 0 ) {
                 var q = list[i]; list[i] = list[i+1]; list[i+1] = q;
                 swap = true;
             }
         } // for
         t--;
 
         if (!swap) break;
 
         for(var i = t; i > b; --i) {
             if ( comp_func(list[i], list[i-1]) < 0 ) {
                 var q = list[i]; list[i] = list[i-1]; list[i-1] = q;
                 swap = true;
             }
         } // for
         b++;
 
     } // while(swap)
   }
 }
 
 /* ******************************************************************
    Supporting functions: bundled here to avoid depending on a library
    ****************************************************************** */
 
 // Dean Edwards/Matthias Miller/John Resig
 
 /* for Mozilla/Opera9 */
 if (document.addEventListener) {
     document.addEventListener("DOMContentLoaded", sorttable.init, false);
 }
 
 /* for Internet Explorer */
 /*@cc_on @*/
 /*@if (@_win32)
     document.write("<script id=__ie_onload defer src=javascript:void(0)><\/script>");
     var script = document.getElementById("__ie_onload");
     script.onreadystatechange = function() {
         if (this.readyState == "complete") {
             sorttable.init(); // call the onload handler
         }
     };
 /*@end @*/
 
 /* for Safari */
 if (/WebKit/i.test(navigator.userAgent)) { // sniff
     var _timer = setInterval(function() {
         if (/loaded|complete/.test(document.readyState)) {
             sorttable.init(); // call the onload handler
         }
     }, 10);
 }
 
 /* for other browsers */
 window.onload = sorttable.init;
 
 // written by Dean Edwards, 2005
 // with input from Tino Zijdel, Matthias Miller, Diego Perini
 
 // http://dean.edwards.name/weblog/2005/10/add-event/
 
 function dean_addEvent(element, type, handler) {
 	if (element.addEventListener) {
 		element.addEventListener(type, handler, false);
 	} else {
 		// assign each event handler a unique ID
 		if (!handler.$$guid) handler.$$guid = dean_addEvent.guid++;
 		// create a hash table of event types for the element
 		if (!element.events) element.events = {};
 		// create a hash table of event handlers for each element/event pair
 		var handlers = element.events[type];
 		if (!handlers) {
 			handlers = element.events[type] = {};
 			// store the existing event handler (if there is one)
 			if (element["on" + type]) {
 				handlers[0] = element["on" + type];
 			}
 		}
 		// store the event handler in the hash table
 		handlers[handler.$$guid] = handler;
 		// assign a global event handler to do all the work
 		element["on" + type] = handleEvent;
 	}
 };
 // a counter used to create unique IDs
 dean_addEvent.guid = 1;
 
 function removeEvent(element, type, handler) {
 	if (element.removeEventListener) {
 		element.removeEventListener(type, handler, false);
 	} else {
 		// delete the event handler from the hash table
 		if (element.events && element.events[type]) {
 			delete element.events[type][handler.$$guid];
 		}
 	}
 };
 
 function handleEvent(event) {
 	var returnValue = true;
 	// grab the event object (IE uses a global event object)
 	event = event || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event);
 	// get a reference to the hash table of event handlers
 	var handlers = this.events[event.type];
 	// execute each event handler
 	for (var i in handlers) {
 		this.$$handleEvent = handlers[i];
 		if (this.$$handleEvent(event) === false) {
 			returnValue = false;
 		}
 	}
 	return returnValue;
 };
 
 function fixEvent(event) {
 	// add W3C standard event methods
 	event.preventDefault = fixEvent.preventDefault;
 	event.stopPropagation = fixEvent.stopPropagation;
 	return event;
 };
 fixEvent.preventDefault = function() {
 	this.returnValue = false;
 };
 fixEvent.stopPropagation = function() {
   this.cancelBubble = true;
 }
 
 // Dean's forEach: http://dean.edwards.name/base/forEach.js
 /*
 	forEach, version 1.0
 	Copyright 2006, Dean Edwards
 	License: http://www.opensource.org/licenses/mit-license.php
 */
 
 // array-like enumeration
 if (!Array.forEach) { // mozilla already supports this
 	Array.forEach = function(array, block, context) {
 		for (var i = 0; i < array.length; i++) {
 			block.call(context, array[i], i, array);
 		}
 	};
 }
 
 // generic enumeration
 Function.prototype.forEach = function(object, block, context) {
 	for (var key in object) {
 		if (typeof this.prototype[key] == "undefined") {
 			block.call(context, object[key], key, object);
 		}
 	}
 };
 
 // character enumeration
 String.forEach = function(string, block, context) {
 	Array.forEach(string.split(""), function(chr, index) {
 		block.call(context, chr, index, string);
 	});
 };
 
 // globally resolve forEach enumeration
 var forEach = function(object, block, context) {
 	if (object) {
 		var resolve = Object; // default
 		if (object instanceof Function) {
 			// functions have a "length" property
 			resolve = Function;
 		} else if (object.forEach instanceof Function) {
 			// the object implements a custom forEach method so use that
 			object.forEach(block, context);
 			return;
 		} else if (typeof object == "string") {
 			// the object is a string
 			resolve = String;
 		} else if (typeof object.length == "number") {
 			// the object is array-like
 			resolve = Array;
 		}
 		resolve.forEach(object, block, context);
 	}
 };
 </script>  
<script type="text/javascript">  
 function openTab(evt, tabName) {
     // Declare all variables
     var i, tabcontent, tablinks;
 
     // Get all elements with class="tabcontent" and hide them
     tabcontent = document.getElementsByClassName("tabcontent");
     for (i = 0; i < tabcontent.length; i++) {
         tabcontent[i].style.display = "none";
     }
 
     // Get all elements with class="tablinks" and remove the class "active"
     tablinks = document.getElementsByClassName("tablinks");
     for (i = 0; i < tablinks.length; i++) {
         tablinks[i].className = tablinks[i].className.replace(" active", "");
     }
 
     // Show the current tab, and add an "active" class to the link that opened the tab
     document.getElementById(tabName).style.display = "block";
     evt.currentTarget.className += " active";
 }
 </script> 
        </head>
        <!-- Body -->
        <body onload="hide();">
			<!-- Report Header -->
                        <table><tbody>
            <tr>
                <td class="clientlogo"><img src="" /></td>
                <td class="MainLogo"><img src="https://raw.githubusercontent.com/hzc2012/PS-MSSQLReporter/master/example/PS-MSSQLReporter.png" /></td>
            </tr>
            </tbody></table>
            <div class="pageTitle">SQL Server Report</div>
            <hr />
            <div class="ReportCreated">Report created on 2 1, 2019 07:48 </div>

<ul class="tab">
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'Dashboard')" id="defaultOpen">Dashboard</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'BaseInfo')">BaseInfo</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'Database')">Database</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'Jobs')">Jobs</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'Backup&Restore')">Backup&Restore</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'Mirror')">Mirror</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'Replication')">Replication</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'AlwaysOn-AG')">AlwaysOn-AG</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'AlwaysOn-FCI')">AlwaysOn-FCI</a></li>
		<li><a href="javascript:void(0)" class="tablinks" onclick="openTab(event, 'Perfmon')">Perfmon</a></li>
</ul>
<div id="Dashboard" class="tabcontent">
<h7>Report: 2019-02-01</h7>
<div class="section">
<div class="header">
    <a name="WARNING : Database">WARNING : Database</a>
</div>
<div class="content" style="background-color:#D0D0D0;"> 
<table class="sortable">

<tr><th>DatabaseId</th><th>DatabaseName</th><th>CompatibilityLevel</th><th>CollationName</th><th>UserAccessDesc</th><th>IsReadOnly</th><th>StateDesc</th><th>RecoveryModelDesc</th><th>CreateDate</th></tr>
<tr class="red"><td>8</td><td>uc_hzc_proc</td><td>100</td><td></td><td>MULTI_USER</td><td>False</td><td>OFFLINE</td><td>SIMPLE</td><td>2018/8/24 16:45:29</td></tr>
</table>
</table>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="WARNING : Disk Space less then 10% !">WARNING : Disk Space less then 10% !</a>
</div>
<div class="content" style="background-color:#D0D0D0;"> 
<div class="oneoftwo column">
<canvas id="FDgYAuTctnVG" width="300" height="300"></canvas>
<script>
var ctx = document.getElementById("FDgYAuTctnVG");
var FDgYAuTctnVG = new Chart(ctx, {
	type: 'doughnut',
	data:	{
		labels: ["Free","Used"],
		datasets: [{
			label: 'Data',
			data: [44.9,73.09],
			backgroundColor: ['rgba(179,25,131,0.7)','rgba(179,221,145,0.7)'],
			hoverBackgroundColor:  ['rgba(179,25,131,1)','rgba(179,221,145,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: false,
		legend: {
                position: 'bottom',
            },
		title: {
				display: true,
				text: 'C: (GB)'
			},
	},
	animation: {
                animateScale: true,
                animateRotate: true
            }
});	
 </script>
</div>
<div class="twooftwo column">
<canvas id="eohZircQkOnz" width="300" height="300"></canvas>
<script>
var ctx = document.getElementById("eohZircQkOnz");
var eohZircQkOnz = new Chart(ctx, {
	type: 'doughnut',
	data:	{
		labels: ["Free","Used"],
		datasets: [{
			label: 'Data',
			data: [67.44,132.76],
			backgroundColor: ['rgba(187,185,248,0.7)','rgba(183,178,107,0.7)'],
			hoverBackgroundColor:  ['rgba(187,185,248,1)','rgba(183,178,107,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: false,
		legend: {
                position: 'bottom',
            },
		title: {
				display: true,
				text: 'D: (GB)'
			},
	},
	animation: {
                animateScale: true,
                animateRotate: true
            }
});	
 </script>
</div>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="WARNING : Login Name were disabled">WARNING : Login Name were disabled</a>
</div>
<div class="content" style="background-color:#D0D0D0;"> 
<table class="sortable">

<tr><th>name</th><th>TypeDesc</th><th>CreateDate</th><th>ModifyDate</th><th>DefaultDatabaseName</th><th>IsDisabled</th></tr>
<tr class="yellow"><td>sa</td><td>SQL_LOGIN</td><td>2003/4/8 9:10:35</td><td>2018/4/3 9:56:55</td><td>master</td><td>True</td></tr>
<tr class="yellow"><td>##MS_PolicyTsqlExecutionLogin##</td><td>SQL_LOGIN</td><td>2016/4/30 0:46:49</td><td>2018/4/3 10:02:47</td><td>master</td><td>True</td></tr>
<tr class="yellow"><td>##MS_PolicyEventProcessingLogin##</td><td>SQL_LOGIN</td><td>2018/4/3 10:02:47</td><td>2018/4/3 10:02:47</td><td>master</td><td>True</td></tr>
</table>
</table>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="WARNING : Failed jobs in the last seven days">WARNING : Failed jobs in the last seven days</a>
</div>
<div class="content" style="background-color:#D0D0D0;"> 
<table class="sortable">

<tr><th>JobNme</th><th>Enabled</th><th>Server</th><th>RunDate</th><th>RunTime</th><th>RunSeconds</th><th>RunStatus</th><th>Message</th></tr>
<tr class="red"><td>test_job</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20190131</td><td>170709</td><td>0</td><td>0</td><td>   TSECHENG\tsecheng  1 (test_step1).</td></tr>
</table>
</table>
    </div>
    </div>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="BaseInfo" class="tabcontent">
<h7>Report: 2019-02-01</h7>
<div class="section">
<div class="header">
    <a name="OS Product & SQL Server Product">OS Product & SQL Server Product</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<div class="first column">
<div class="section">
<div class="header">
    <a name="OS Product">OS Product</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<table class="sortable">

<tr><th>Name</th><th>Value</th></tr>
<tr><td>Domain</td><td>WORKGROUP</td></tr>
<tr><td>Name</td><td>TSECHENG</td></tr>
<tr><td>Manufacturer</td><td>Microsoft Corporation</td></tr>
<tr><td>OS Name</td><td>Microsoft Windows 10 |C:\WINDOWS|\Device\Harddisk0\Partition3</td></tr>
<tr><td>Version</td><td>10.0.17134</td></tr>
<tr><td>System Type</td><td>x64-based PC</td></tr>
<tr><td>OS Architecture</td><td>64 </td></tr>
<tr><td>Number Of Processors</td><td>1</td></tr>
<tr><td>Number Of Logical Processors</td><td>4</td></tr>
<tr><td>Total Virtual Memory Size</td><td>21.37 GB</td></tr>
<tr><td>Total Physical Memory Size</td><td>15.84 GB</td></tr>
<tr><td>Free Virtual Memory</td><td>3.76 GB</td></tr>
<tr><td>Free Physical Memory</td><td>7.7 GB</td></tr>
<tr><td>Last BootUp Time</td><td>2018/11/14 19:09:57</td></tr>
</table>
</table>
    </div>
    </div>
</div>
<div class="second column">
<div class="section">
<div class="header">
    <a name="SQL Server Product">SQL Server Product</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<table class="sortable">

<tr><th>Index</th><th>Name</th><th>CharacterValue</th></tr>
<tr><td>1</td><td>ProductName</td><td>Microsoft SQL Server</td></tr>
<tr><td>2</td><td>ProductVersion</td><td>13.0.4001.0</td></tr>
<tr><td>3</td><td>Language</td><td>()</td></tr>
<tr><td>4</td><td>Platform</td><td>NT x64</td></tr>
<tr><td>5</td><td>Comments</td><td>SQL</td></tr>
<tr><td>6</td><td>CompanyName</td><td>Microsoft Corporation</td></tr>
<tr><td>7</td><td>FileDescription</td><td>SQL Server Windows NT - 64 Bit</td></tr>
<tr><td>8</td><td>FileVersion</td><td>2015.0130.4001.00 ((SQL16_PCU_Main).161028-1734)</td></tr>
<tr><td>9</td><td>InternalName</td><td>SQLSERVR</td></tr>
<tr><td>10</td><td>LegalCopyright</td><td>Microsoft. All rights reserved.</td></tr>
<tr><td>11</td><td>LegalTrademarks</td><td>Microsoft SQL Server is a registered trademark of Microsoft Corporation.</td></tr>
<tr><td>12</td><td>OriginalFilename</td><td>SQLSERVR.EXE</td></tr>
<tr><td>13</td><td>PrivateBuild</td><td></td></tr>
<tr><td>14</td><td>SpecialBuild</td><td></td></tr>
<tr><td>15</td><td>WindowsVersion</td><td>6.3 (17134)</td></tr>
<tr><td>16</td><td>ProcessorCount</td><td>4</td></tr>
<tr><td>17</td><td>ProcessorActiveMask</td><td>               f</td></tr>
<tr><td>18</td><td>ProcessorType</td><td></td></tr>
<tr><td>19</td><td>PhysicalMemory</td><td>16223 (17010724864)</td></tr>
<tr><td>20</td><td>Product ID</td><td></td></tr>
</table>
</table>
    </div>
    </div>
</div>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Logical Disk Space">Logical Disk Space</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<div class="oneoffour column">
<canvas id="JNqErdIVQZGo" width="300" height="300"></canvas>
<script>
var ctx = document.getElementById("JNqErdIVQZGo");
var JNqErdIVQZGo = new Chart(ctx, {
	type: 'doughnut',
	data:	{
		labels: ["Free","Used"],
		datasets: [{
			label: 'Data',
			data: [44.9,73.09],
			backgroundColor: ['rgba(114,182,112,0.7)','rgba(109,128,114,0.7)'],
			hoverBackgroundColor:  ['rgba(114,182,112,1)','rgba(109,128,114,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: false,
		legend: {
                position: 'bottom',
            },
		title: {
				display: true,
				text: 'C: (GB)'
			},
	},
	animation: {
                animateScale: true,
                animateRotate: true
            }
});	
 </script>
</div>
<div class="twooffour column">
<canvas id="yRcWaKAfxhZL" width="300" height="300"></canvas>
<script>
var ctx = document.getElementById("yRcWaKAfxhZL");
var yRcWaKAfxhZL = new Chart(ctx, {
	type: 'doughnut',
	data:	{
		labels: ["Free","Used"],
		datasets: [{
			label: 'Data',
			data: [67.44,132.76],
			backgroundColor: ['rgba(8,63,166,0.7)','rgba(104,55,252,0.7)'],
			hoverBackgroundColor:  ['rgba(8,63,166,1)','rgba(104,55,252,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: false,
		legend: {
                position: 'bottom',
            },
		title: {
				display: true,
				text: 'D: (GB)'
			},
	},
	animation: {
                animateScale: true,
                animateRotate: true
            }
});	
 </script>
</div>
<div class="threeoffour column">
<canvas id="BcQYWdTreGho" width="300" height="300"></canvas>
<script>
var ctx = document.getElementById("BcQYWdTreGho");
var BcQYWdTreGho = new Chart(ctx, {
	type: 'doughnut',
	data:	{
		labels: ["Free","Used"],
		datasets: [{
			label: 'Data',
			data: [186.61,56.29],
			backgroundColor: ['rgba(159,172,207,0.7)','rgba(159,167,123,0.7)'],
			hoverBackgroundColor:  ['rgba(159,172,207,1)','rgba(159,167,123,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: false,
		legend: {
                position: 'bottom',
            },
		title: {
				display: true,
				text: 'E: (GB)'
			},
	},
	animation: {
                animateScale: true,
                animateRotate: true
            }
});	
 </script>
</div>
<div class="fouroffour column">
<canvas id="UhaTrAebKDdR" width="300" height="300"></canvas>
<script>
var ctx = document.getElementById("UhaTrAebKDdR");
var UhaTrAebKDdR = new Chart(ctx, {
	type: 'doughnut',
	data:	{
		labels: ["Free","Used"],
		datasets: [{
			label: 'Data',
			data: [471.3,16.98],
			backgroundColor: ['rgba(164,182,71,0.7)','rgba(112,180,53,0.7)'],
			hoverBackgroundColor:  ['rgba(164,182,71,1)','rgba(112,180,53,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: false,
		legend: {
                position: 'bottom',
            },
		title: {
				display: true,
				text: 'F: (GB)'
			},
	},
	animation: {
                animateScale: true,
                animateRotate: true
            }
});	
 </script>
</div>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="SQL Server Version">SQL Server Version</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<div class="first column">
<div class="section">
<div class="header">
    <a name="SQL Server Product Version">SQL Server Product Version</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<table class="sortable">

<tr><th>Index</th><th>Name</th><th>CharacterValue</th></tr>
<tr><td>1</td><td>ProductName</td><td>Microsoft SQL Server</td></tr>
<tr><td>2</td><td>ProductVersion</td><td>13.0.4001.0</td></tr>
<tr><td>3</td><td>Language</td><td>()</td></tr>
<tr><td>4</td><td>Platform</td><td>NT x64</td></tr>
<tr><td>5</td><td>Comments</td><td>SQL</td></tr>
<tr><td>6</td><td>CompanyName</td><td>Microsoft Corporation</td></tr>
<tr><td>7</td><td>FileDescription</td><td>SQL Server Windows NT - 64 Bit</td></tr>
<tr><td>8</td><td>FileVersion</td><td>2015.0130.4001.00 ((SQL16_PCU_Main).161028-1734)</td></tr>
<tr><td>9</td><td>InternalName</td><td>SQLSERVR</td></tr>
<tr><td>10</td><td>LegalCopyright</td><td>Microsoft. All rights reserved.</td></tr>
<tr><td>11</td><td>LegalTrademarks</td><td>Microsoft SQL Server is a registered trademark of Microsoft Corporation.</td></tr>
<tr><td>12</td><td>OriginalFilename</td><td>SQLSERVR.EXE</td></tr>
<tr><td>13</td><td>PrivateBuild</td><td></td></tr>
<tr><td>14</td><td>SpecialBuild</td><td></td></tr>
<tr><td>15</td><td>WindowsVersion</td><td>6.3 (17134)</td></tr>
<tr><td>16</td><td>ProcessorCount</td><td>4</td></tr>
<tr><td>17</td><td>ProcessorActiveMask</td><td>               f</td></tr>
<tr><td>18</td><td>ProcessorType</td><td></td></tr>
<tr><td>19</td><td>PhysicalMemory</td><td>16223 (17010724864)</td></tr>
<tr><td>20</td><td>Product ID</td><td></td></tr>
</table>
</table>
    </div>
    </div>
</div>
<div class="second column">
<div class="section">
<div class="header">
    <a name="SQL Server Service Status">SQL Server Service Status</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<table class="sortable">

<tr><th>Status</th><th>ServiceName</th><th>DisplayName</th></tr>
<tr><td>Running</td><td>MSSQL$MSSQL2016</td><td>SQL Server (MSSQL2016)</td></tr>
<tr><td>Running</td><td>MSSQL$MSSQL2017</td><td>SQL Server (MSSQL2017)</td></tr>
<tr><td>Running</td><td>MSSQL$MSSQL2019</td><td>SQL Server (MSSQL2019)</td></tr>
<tr><td>Running</td><td>MSSQLFDLauncher$MSSQL2016</td><td>SQL Full-text Filter Daemon Launcher (MSSQL2016)</td></tr>
<tr><td>Running</td><td>MSSQLFDLauncher$MSSQL2017</td><td>SQL Full-text Filter Daemon Launcher (MSSQL2017)</td></tr>
<tr><td>Running</td><td>MSSQLLaunchpad$MSSQL2017</td><td>SQL Server Launchpad (MSSQL2017)</td></tr>
<tr class="yellow"><td>Stopped</td><td>MySQL56</td><td>MySQL56</td></tr>
<tr><td>Running</td><td>SQLAgent$MSSQL2016</td><td>SQL Server  (MSSQL2016)</td></tr>
<tr><td>Running</td><td>SQLAgent$MSSQL2017</td><td>SQL Server  (MSSQL2017)</td></tr>
<tr class="yellow"><td>Stopped</td><td>SQLAgent$MSSQL2019</td><td>SQL Server  (MSSQL2019)</td></tr>
<tr><td>Running</td><td>SQLBrowser</td><td>SQL Server Browser</td></tr>
<tr><td>Running</td><td>SQLPBDMS$MSSQL2019</td><td>SQL Server PolyBase  (MSSQL2019)</td></tr>
<tr><td>Running</td><td>SQLPBENGINE$MSSQL2019</td><td>SQL Server PolyBase  (MSSQL2019)</td></tr>
<tr><td>Running</td><td>SQLTELEMETRY$MSSQL2016</td><td>SQL Server CEIP service (MSSQL2016)</td></tr>
<tr><td>Running</td><td>SQLTELEMETRY$MSSQL2017</td><td>SQL Server CEIP service (MSSQL2017)</td></tr>
<tr><td>Running</td><td>SQLTELEMETRY$MSSQL2019</td><td>SQL Server CEIP service (MSSQL2019)</td></tr>
<tr><td>Running</td><td>SQLWriter</td><td>SQL Server VSS Writer</td></tr>
</table>
</table>
    </div>
    </div>
</div>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Windows Scheduled Tasks">Windows Scheduled Tasks</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#uywzgfmi').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "State" },{ "data": "TaskPath" },{ "data": "TaskName" }]
     });
 } );
</script><table id="uywzgfmi" class="display compact"><thead>  <tr><th>State</th><th>TaskPath</th><th>TaskName</th></tr></thead><tbody> <tr><td>Disabled</td><td>\</td><td>GoogleUpdateTaskMachineCore</td></tr> <tr><td>Disabled</td><td>\</td><td>GoogleUpdateTaskMachineUA</td></tr> <tr><td>Ready</td><td>\</td><td>Intel PTT EK Recertification</td></tr> <tr><td>Disabled</td><td>\</td><td>Intel-IMSS</td></tr> <tr><td>Ready</td><td>\</td><td>KMS10</td></tr> <tr><td>Ready</td><td>\</td><td>KMS10Server</td></tr> <tr><td>Ready</td><td>\</td><td>New Task</td></tr> <tr><td>Ready</td><td>\</td><td>NvDriverUpdateCheckDaily_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>NVIDIA GeForce Experience SelfUpdate_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>NvNodeLauncher_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>NvProfileUpdaterDaily_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>NvProfileUpdaterOnLogon_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>NvTmMon_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>NvTmRepOnLogon_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>NvTmRep_{B2FE1952-0186-46C3-BAEC-A80AA35AC5B8}</td></tr> <tr><td>Ready</td><td>\</td><td>OneDrive Standalone Update Task v2</td></tr> <tr><td>Disabled</td><td>\</td><td>RtHDVBg_Dolby</td></tr> <tr><td>Disabled</td><td>\</td><td>RTKCPL</td></tr> <tr><td>Running</td><td>\Lenovo\</td><td>Lenovo Hardware Settings</td></tr> <tr><td>Ready</td><td>\Lenovo\ImController\</td><td>Lenovo iM Controller Monitor</td></tr> <tr><td>Ready</td><td>\Lenovo\ImController\</td><td>Lenovo iM Controller Scheduled Maintenance</td></tr> <tr><td>Ready</td><td>\Lenovo\ImController\Plugins\</td><td>LenovoSystemUpdatePlugin_WeeklyTask</td></tr> <tr><td>Ready</td><td>\Lenovo\ImController\TimeBasedEvents\</td><td>10eb161f-aa4d-431c-aad5-94ef6f9014b0</td></tr> <tr><td>Ready</td><td>\Lenovo\ImController\TimeBasedEvents\</td><td>6a321312-fedd-4d7f-b6b5-bf3c7843ef76</td></tr> <tr><td>Ready</td><td>\Lenovo\ImController\TimeBasedEvents\</td><td>dbe4d2ce-a045-4021-979d-cbebd52187af</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\.NET Framework\</td><td>.NET Framework NGEN v4.0.30319</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\.NET Framework\</td><td>.NET Framework NGEN v4.0.30319 64</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\.NET Framework\</td><td>.NET Framework NGEN v4.0.30319 64 Critical</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\.NET Framework\</td><td>.NET Framework NGEN v4.0.30319 Critical</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Active Directory Rights Management Services Client\</td><td>AD RMS Rights Policy Template Management (Automated)</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Active Directory Rights Management Services Client\</td><td>AD RMS Rights Policy Template Management (Manual)</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\AppID\</td><td>EDP Policy Manager</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\AppID\</td><td>PolicyConverter</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\AppID\</td><td>VerifiedPublisherCertStoreCheck</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Application Experience\</td><td>Microsoft Compatibility Appraiser</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Application Experience\</td><td>ProgramDataUpdater</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Application Experience\</td><td>StartupAppTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\ApplicationData\</td><td>appuriverifierdaily</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\ApplicationData\</td><td>appuriverifierinstall</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\ApplicationData\</td><td>CleanupTemporaryState</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\ApplicationData\</td><td>DsSvcCleanup</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\AppxDeploymentClient\</td><td>Pre-staged app cleanup</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Autochk\</td><td>Proxy</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\BitLocker\</td><td>BitLocker MDM policy Refresh</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Bluetooth\</td><td>UninstallDeviceTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\BrokerInfrastructure\</td><td>BgTaskRegistrationMaintenanceTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\CertificateServicesClient\</td><td>AikCertEnrollTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\CertificateServicesClient\</td><td>CryptoPolicyTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\CertificateServicesClient\</td><td>KeyPreGenTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\CertificateServicesClient\</td><td>SystemTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\CertificateServicesClient\</td><td>UserTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\CertificateServicesClient\</td><td>UserTask-Roam</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Chkdsk\</td><td>ProactiveScan</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Chkdsk\</td><td>SyspartRepair</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Clip\</td><td>License Validation</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\CloudExperienceHost\</td><td>CreateObjectTask</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Customer Experience Improvement Program\</td><td>Consolidator</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Customer Experience Improvement Program\</td><td>UsbCeip</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Data Integrity Scan\</td><td>Data Integrity Scan</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Data Integrity Scan\</td><td>Data Integrity Scan for Crash Recovery</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Defrag\</td><td>ScheduledDefrag</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Device Information\</td><td>Device</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Device Setup\</td><td>Metadata Refresh</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>HandleCommand</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>HandleWnsCommand</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>IntegrityCheck</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>LocateCommandUserSession</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>RegisterDeviceAccountChange</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>RegisterDeviceLocationRightsChange</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>RegisterDevicePeriodic24</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>RegisterDevicePolicyChange</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>RegisterDeviceProtectionStateChanged</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>RegisterDeviceSettingChange</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DeviceDirectoryClient\</td><td>RegisterUserDevice</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Diagnosis\</td><td>Scheduled</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DirectX\</td><td>DXGIAdapterCache</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\DiskCleanup\</td><td>SilentCleanup</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\DiskDiagnostic\</td><td>Microsoft-Windows-DiskDiagnosticDataCollector</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\DiskDiagnostic\</td><td>Microsoft-Windows-DiskDiagnosticResolver</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DiskFootprint\</td><td>Diagnostics</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DiskFootprint\</td><td>StorageSense</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\DUSM\</td><td>dusmtask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\EDP\</td><td>EDP App Launch Task</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\EDP\</td><td>EDP Auth Task</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\EDP\</td><td>EDP Inaccessible Credentials Task</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\EDP\</td><td>StorageCardEncryption Task</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\EnterpriseMgmt\</td><td>MDMMaintenenceTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\ExploitGuard\</td><td>ExploitGuard MDM policy Refresh</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Feedback\Siuf\</td><td>DmClient</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Feedback\Siuf\</td><td>DmClientOnScenarioDownload</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\FileHistory\</td><td>File History (maintenance mode)</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\HelloFace\</td><td>FODCleanupTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\InstallService\</td><td>ScanForUpdates</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\InstallService\</td><td>ScanForUpdatesAsUser</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\InstallService\</td><td>SmartRetry</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\InstallService\</td><td>WakeUpAndContinueUpdates</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\InstallService\</td><td>WakeUpAndScanForUpdates</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\LanguageComponentsInstaller\</td><td>Installation</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\LanguageComponentsInstaller\</td><td>ReconcileLanguageResources</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\LanguageComponentsInstaller\</td><td>Uninstallation</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\License Manager\</td><td>TempSignedLicenseExchange</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Location\</td><td>Notifications</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Location\</td><td>WindowsActionDialog</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Maintenance\</td><td>WinSAT</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Management\Provisioning\</td><td>Cellular</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Management\Provisioning\</td><td>Logon</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Maps\</td><td>MapsToastTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Maps\</td><td>MapsUpdateTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\MemoryDiagnostic\</td><td>ProcessMemoryDiagnosticEvents</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\MemoryDiagnostic\</td><td>RunFullMemoryDiagnostic</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Mobile Broadband Accounts\</td><td>MNO Metadata Parser</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\MUI\</td><td>LPRemove</td></tr> <tr><td>Running</td><td>\Microsoft\Windows\Multimedia\</td><td>SystemSoundsService</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\NetTrace\</td><td>GatherNetworkInfo</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\NlaSvc\</td><td>WiFiTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\PI\</td><td>Secure-Boot-Update</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\PI\</td><td>Sqm-Tasks</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Plug and Play\</td><td>Device Install Group Policy</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Plug and Play\</td><td>Device Install Reboot Required</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Plug and Play\</td><td>Sysprep Generalize Drivers</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Power Efficiency Diagnostics\</td><td>AnalyzeSystem</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Printing\</td><td>EduPrintProv</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\PushToInstall\</td><td>LoginCheck</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\PushToInstall\</td><td>Registration</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Ras\</td><td>MobilityManager</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\RecoveryEnvironment\</td><td>VerifyWinRE</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Registry\</td><td>RegIdleBackup</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\RemoteAssistance\</td><td>RemoteAssistanceTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Servicing\</td><td>StartComponentCleanup</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\SettingSync\</td><td>BackgroundUploadTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\SettingSync\</td><td>NetworkStateChangeTask</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\SharedPC\</td><td>Account Cleanup</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Shell\</td><td>CreateObjectTask</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Shell\</td><td>FamilySafetyMonitor</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Shell\</td><td>FamilySafetyMonitorToastTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Shell\</td><td>FamilySafetyRefreshTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Shell\</td><td>IndexerAutomaticMaintenance</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\SoftwareProtectionPlatform\</td><td>SvcRestartTask</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\SoftwareProtectionPlatform\</td><td>SvcRestartTaskLogon</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\SoftwareProtectionPlatform\</td><td>SvcRestartTaskNetwork</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\SpacePort\</td><td>SpaceAgentTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\SpacePort\</td><td>SpaceManagerTask</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Speech\</td><td>HeadsetButtonPress</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Speech\</td><td>SpeechModelDownloadTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Storage Tiers Management\</td><td>Storage Tiers Management Initialization</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Storage Tiers Management\</td><td>Storage Tiers Optimization</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Subscription\</td><td>EnableLicenseAcquisition</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Subscription\</td><td>LicenseAcquisition</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Sysmain\</td><td>HybridDriveCachePrepopulate</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Sysmain\</td><td>HybridDriveCacheRebalance</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Sysmain\</td><td>ResPriStaticDbSync</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Sysmain\</td><td>WsSwapAssessmentTask</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\SystemRestore\</td><td>SR</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Task Manager\</td><td>Interactive</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\TextServicesFramework\</td><td>MsCtfMonitor</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Time Synchronization\</td><td>ForceSynchronizeTime</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Time Synchronization\</td><td>SynchronizeTime</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Time Zone\</td><td>SynchronizeTimeZone</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\TPM\</td><td>Tpm-HASCertRetr</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\TPM\</td><td>Tpm-Maintenance</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\UNP\</td><td>RunUpdateNotificationMgr</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>Maintenance Install</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>Reboot</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>Schedule Scan</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>UpdateAssistant</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>UpdateAssistantAllUsersRun</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>UpdateAssistantCalendarRun</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>UpdateAssistantWakeupRun</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\UpdateOrchestrator\</td><td>USO_Broker_Display</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\UPnP\</td><td>UPnPHostConfig</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\USB\</td><td>Usb-Notifications</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\User Profile Service\</td><td>HiveUploadTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WaaSMedic\</td><td>PerformRemediation</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WCM\</td><td>WiFiTask</td></tr> <tr><td>Running</td><td>\Microsoft\Windows\WDI\</td><td>ResolutionHost</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Windows Error Reporting\</td><td>QueueReporting</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Windows Filtering Platform\</td><td>BfeOnServiceStartTypeChange</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Windows Media Sharing\</td><td>UpdateLibrary</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WindowsColorSystem\</td><td>Calibration Loader</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WindowsUpdate\</td><td>Scheduled Start</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WindowsUpdate\</td><td>sih</td></tr> <tr><td>Running</td><td>\Microsoft\Windows\Wininet\</td><td>CacheTask</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WOF\</td><td>WIM-Hash-Management</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WOF\</td><td>WIM-Hash-Validation</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Work Folders\</td><td>Work Folders Logon Synchronization</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\Work Folders\</td><td>Work Folders Maintenance Work</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Workplace Join\</td><td>Automatic-Device-Join</td></tr> <tr><td>Disabled</td><td>\Microsoft\Windows\Workplace Join\</td><td>Recovery-Check</td></tr> <tr><td>Ready</td><td>\Microsoft\Windows\WwanSvc\</td><td>NotificationTask</td></tr> <tr><td>Disabled</td><td>\Microsoft\XblGameSave\</td><td>XblGameSaveTask</td></tr> <tr><td>Ready</td><td>\MySQL\Installer\</td><td>ManifestUpdate</td></tr> <tr><td>Disabled</td><td>\OfficeSoftwareProtectionPlatform\</td><td>SvcRestartTask</td></tr> </tbody> </table>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="SQL Server Configurations">SQL Server Configurations</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#kydoggpt').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "configuration_id" },{ "data": "name" },{ "data": "value" },{ "data": "minimum" },{ "data": "maximum" },{ "data": "value_in_use" },{ "data": "description" },{ "data": "is_dynamic" },{ "data": "is_advanced" }]
     });
 } );
</script><table id="kydoggpt" class="display compact"><thead>  <tr><th>configuration_id</th><th>name</th><th>value</th><th>minimum</th><th>maximum</th><th>value_in_use</th><th>description</th><th>is_dynamic</th><th>is_advanced</th></tr></thead><tbody> <tr><td>101</td><td>recovery interval (min)</td><td>0</td><td>0</td><td>32767</td><td>0</td><td>Maximum recovery interval in minutes</td><td>True</td><td>True</td></tr> <tr><td>102</td><td>allow updates</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Allow updates to system tables</td><td>True</td><td>False</td></tr> <tr><td>103</td><td>user connections</td><td>0</td><td>0</td><td>32767</td><td>0</td><td>Number of user connections allowed</td><td>False</td><td>True</td></tr> <tr><td>106</td><td>locks</td><td>0</td><td>5000</td><td>2147483647</td><td>0</td><td>Number of locks for all users</td><td>False</td><td>True</td></tr> <tr><td>107</td><td>open objects</td><td>0</td><td>0</td><td>2147483647</td><td>0</td><td>Number of open database objects</td><td>False</td><td>True</td></tr> <tr><td>109</td><td>fill factor (%)</td><td>0</td><td>0</td><td>100</td><td>0</td><td>Default fill factor percentage</td><td>False</td><td>True</td></tr> <tr><td>114</td><td>disallow results from triggers</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Disallow returning results from triggers</td><td>True</td><td>True</td></tr> <tr><td>115</td><td>nested triggers</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Allow triggers to be invoked within triggers</td><td>True</td><td>False</td></tr> <tr><td>116</td><td>server trigger recursion</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Allow recursion for server level triggers</td><td>True</td><td>False</td></tr> <tr><td>117</td><td>remote access</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Allow remote access</td><td>False</td><td>False</td></tr> <tr><td>124</td><td>default language</td><td>30</td><td>0</td><td>9999</td><td>30</td><td>default language</td><td>True</td><td>False</td></tr> <tr><td>400</td><td>cross db ownership chaining</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Allow cross db ownership chaining</td><td>True</td><td>False</td></tr> <tr><td>503</td><td>max worker threads</td><td>0</td><td>128</td><td>65535</td><td>0</td><td>Maximum worker threads</td><td>True</td><td>True</td></tr> <tr><td>505</td><td>network packet size (B)</td><td>4096</td><td>512</td><td>32767</td><td>4096</td><td>Network packet size</td><td>True</td><td>True</td></tr> <tr><td>518</td><td>show advanced options</td><td>1</td><td>0</td><td>1</td><td>1</td><td>show advanced options</td><td>True</td><td>False</td></tr> <tr><td>542</td><td>remote proc trans</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Create DTC transaction for remote procedures</td><td>True</td><td>False</td></tr> <tr><td>544</td><td>c2 audit mode</td><td>0</td><td>0</td><td>1</td><td>0</td><td>c2 audit mode</td><td>False</td><td>True</td></tr> <tr><td>1126</td><td>default full-text language</td><td>2052</td><td>0</td><td>2147483647</td><td>2052</td><td>default full-text language</td><td>True</td><td>True</td></tr> <tr><td>1127</td><td>two digit year cutoff</td><td>2049</td><td>1753</td><td>9999</td><td>2049</td><td>two digit year cutoff</td><td>True</td><td>True</td></tr> <tr><td>1505</td><td>index create memory (KB)</td><td>0</td><td>704</td><td>2147483647</td><td>0</td><td>Memory for index create sorts (kBytes)</td><td>True</td><td>True</td></tr> <tr><td>1517</td><td>priority boost</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Priority boost</td><td>False</td><td>True</td></tr> <tr><td>1519</td><td>remote login timeout (s)</td><td>10</td><td>0</td><td>2147483647</td><td>10</td><td>remote login timeout</td><td>True</td><td>False</td></tr> <tr><td>1520</td><td>remote query timeout (s)</td><td>600</td><td>0</td><td>2147483647</td><td>600</td><td>remote query timeout</td><td>True</td><td>False</td></tr> <tr><td>1531</td><td>cursor threshold</td><td>-1</td><td>-1</td><td>2147483647</td><td>-1</td><td>cursor threshold</td><td>True</td><td>True</td></tr> <tr><td>1532</td><td>set working set size</td><td>0</td><td>0</td><td>1</td><td>0</td><td>set working set size</td><td>False</td><td>True</td></tr> <tr><td>1534</td><td>user options</td><td>0</td><td>0</td><td>32767</td><td>0</td><td>user options</td><td>True</td><td>False</td></tr> <tr><td>1535</td><td>affinity mask</td><td>0</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>affinity mask</td><td>True</td><td>True</td></tr> <tr><td>1536</td><td>max text repl size (B)</td><td>65536</td><td>-1</td><td>2147483647</td><td>65536</td><td>Maximum size of a text field in replication.</td><td>True</td><td>False</td></tr> <tr><td>1537</td><td>media retention</td><td>0</td><td>0</td><td>365</td><td>0</td><td>Tape retention period in days</td><td>True</td><td>True</td></tr> <tr><td>1538</td><td>cost threshold for parallelism</td><td>5</td><td>0</td><td>32767</td><td>5</td><td>cost threshold for parallelism</td><td>True</td><td>True</td></tr> <tr><td>1539</td><td>max degree of parallelism</td><td>0</td><td>0</td><td>32767</td><td>0</td><td>maximum degree of parallelism</td><td>True</td><td>True</td></tr> <tr><td>1540</td><td>min memory per query (KB)</td><td>1024</td><td>512</td><td>2147483647</td><td>1024</td><td>minimum memory per query (kBytes)</td><td>True</td><td>True</td></tr> <tr><td>1541</td><td>query wait (s)</td><td>-1</td><td>-1</td><td>2147483647</td><td>-1</td><td>maximum time to wait for query memory (s)</td><td>True</td><td>True</td></tr> <tr><td>1543</td><td>min server memory (MB)</td><td>0</td><td>0</td><td>2147483647</td><td>16</td><td>Minimum size of server memory (MB)</td><td>True</td><td>True</td></tr> <tr><td>1544</td><td>max server memory (MB)</td><td>2147483647</td><td>128</td><td>2147483647</td><td>2147483647</td><td>Maximum size of server memory (MB)</td><td>True</td><td>True</td></tr> <tr><td>1545</td><td>query governor cost limit</td><td>0</td><td>0</td><td>2147483647</td><td>0</td><td>Maximum estimated cost allowed by query governor</td><td>True</td><td>True</td></tr> <tr><td>1546</td><td>lightweight pooling</td><td>0</td><td>0</td><td>1</td><td>0</td><td>User mode scheduler uses lightweight pooling</td><td>False</td><td>True</td></tr> <tr><td>1547</td><td>scan for startup procs</td><td>1</td><td>0</td><td>1</td><td>0</td><td>scan for startup stored procedures</td><td>False</td><td>True</td></tr> <tr><td>1549</td><td>affinity64 mask</td><td>0</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>affinity64 mask</td><td>True</td><td>True</td></tr> <tr><td>1550</td><td>affinity I/O mask</td><td>0</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>affinity I/O mask</td><td>False</td><td>True</td></tr> <tr><td>1551</td><td>affinity64 I/O mask</td><td>0</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>affinity64 I/O mask</td><td>False</td><td>True</td></tr> <tr><td>1555</td><td>transform noise words</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Transform noise words for full-text query</td><td>True</td><td>True</td></tr> <tr><td>1556</td><td>precompute rank</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Use precomputed rank for full-text query</td><td>True</td><td>True</td></tr> <tr><td>1557</td><td>PH timeout (s)</td><td>60</td><td>1</td><td>3600</td><td>60</td><td>DB connection timeout for full-text protocol handler (s)</td><td>True</td><td>True</td></tr> <tr><td>1562</td><td>clr enabled</td><td>0</td><td>0</td><td>1</td><td>0</td><td>CLR user code execution enabled in the server</td><td>True</td><td>False</td></tr> <tr><td>1563</td><td>max full-text crawl range</td><td>4</td><td>0</td><td>256</td><td>4</td><td>Maximum  crawl ranges allowed in full-text indexing</td><td>True</td><td>True</td></tr> <tr><td>1564</td><td>ft notify bandwidth (min)</td><td>0</td><td>0</td><td>32767</td><td>0</td><td>Number of reserved full-text notifications buffers</td><td>True</td><td>True</td></tr> <tr><td>1565</td><td>ft notify bandwidth (max)</td><td>100</td><td>0</td><td>32767</td><td>100</td><td>Max number of full-text notifications buffers</td><td>True</td><td>True</td></tr> <tr><td>1566</td><td>ft crawl bandwidth (min)</td><td>0</td><td>0</td><td>32767</td><td>0</td><td>Number of reserved full-text crawl buffers</td><td>True</td><td>True</td></tr> <tr><td>1567</td><td>ft crawl bandwidth (max)</td><td>100</td><td>0</td><td>32767</td><td>100</td><td>Max number of full-text crawl buffers</td><td>True</td><td>True</td></tr> <tr><td>1568</td><td>default trace enabled</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Enable or disable the default trace</td><td>True</td><td>True</td></tr> <tr><td>1569</td><td>blocked process threshold (s)</td><td>0</td><td>0</td><td>86400</td><td>0</td><td>Blocked process reporting threshold</td><td>True</td><td>True</td></tr> <tr><td>1570</td><td>in-doubt xact resolution</td><td>0</td><td>0</td><td>2</td><td>0</td><td>Recovery policy for DTC transactions with unknown outcome</td><td>True</td><td>True</td></tr> <tr><td>1576</td><td>remote admin connections</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Dedicated Admin Connections are allowed from remote clients</td><td>True</td><td>False</td></tr> <tr><td>1577</td><td>common criteria compliance enabled</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Common Criteria compliance mode enabled</td><td>False</td><td>True</td></tr> <tr><td>1578</td><td>EKM provider enabled</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enable or disable EKM provider</td><td>True</td><td>True</td></tr> <tr><td>1579</td><td>backup compression default</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Enable compression of backups by default</td><td>True</td><td>False</td></tr> <tr><td>1580</td><td>filestream access level</td><td>0</td><td>0</td><td>2</td><td>0</td><td>Sets the FILESTREAM access level</td><td>True</td><td>False</td></tr> <tr><td>1581</td><td>optimize for ad hoc workloads</td><td>0</td><td>0</td><td>1</td><td>0</td><td>When this option is set, plan cache size is further reduced for single-use adhoc OLTP workload.</td><td>True</td><td>True</td></tr> <tr><td>1582</td><td>access check cache bucket count</td><td>0</td><td>0</td><td>65536</td><td>0</td><td>Default hash bucket count for the access check result security cache</td><td>True</td><td>True</td></tr> <tr><td>1583</td><td>access check cache quota</td><td>0</td><td>0</td><td>2147483647</td><td>0</td><td>Default quota for the access check result security cache</td><td>True</td><td>True</td></tr> <tr><td>1584</td><td>backup checksum default</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enable checksum of backups by default</td><td>True</td><td>False</td></tr> <tr><td>1585</td><td>automatic soft-NUMA disabled</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Automatic soft-NUMA is enabled by default</td><td>False</td><td>True</td></tr> <tr><td>1586</td><td>external scripts enabled</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Allows execution of external scripts</td><td>False</td><td>False</td></tr> <tr><td>16384</td><td>Agent XPs</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Enable or disable Agent XPs</td><td>True</td><td>True</td></tr> <tr><td>16386</td><td>Database Mail XPs</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enable or disable Database Mail XPs</td><td>True</td><td>True</td></tr> <tr><td>16387</td><td>SMO and DMO XPs</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Enable or disable SMO and DMO XPs</td><td>True</td><td>True</td></tr> <tr><td>16388</td><td>Ole Automation Procedures</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enable or disable Ole Automation Procedures</td><td>True</td><td>True</td></tr> <tr><td>16390</td><td>xp_cmdshell</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enable or disable command shell</td><td>True</td><td>True</td></tr> <tr><td>16391</td><td>Ad Hoc Distributed Queries</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enable or disable Ad Hoc Distributed Queries</td><td>True</td><td>True</td></tr> <tr><td>16392</td><td>Replication XPs</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enable or disable Replication XPs</td><td>True</td><td>True</td></tr> <tr><td>16393</td><td>contained database authentication</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Enables contained databases and contained authentication</td><td>True</td><td>False</td></tr> <tr><td>16394</td><td>hadoop connectivity</td><td>0</td><td>0</td><td>7</td><td>0</td><td>Configure SQL Server to connect to external Hadoop or Microsoft Azure storage blob data sources through PolyBase</td><td>False</td><td>False</td></tr> <tr><td>16395</td><td>polybase network encryption</td><td>1</td><td>0</td><td>1</td><td>1</td><td>Configure SQL Server to encrypt control and data channels when using PolyBase</td><td>False</td><td>False</td></tr> <tr><td>16396</td><td>remote data archive</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Allow the use of the REMOTE_DATA_ARCHIVE data access for databases</td><td>True</td><td>False</td></tr> <tr><td>16397</td><td>allow polybase export</td><td>0</td><td>0</td><td>1</td><td>0</td><td>Allow INSERT into a Hadoop external table</td><td>True</td><td>False</td></tr> </tbody> </table>
    </div>
    </div>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="Database" class="tabcontent">
<h7>Report: 2019-02-01</h7>
<div class="section">
<div class="header">
    <a name="Database Information">Database Information</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#wsakgryo').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "DatabaseId" },{ "data": "DatabaseName" },{ "data": "CompatibilityLevel" },{ "data": "CollationName" },{ "data": "UserAccessDesc" },{ "data": "IsReadOnly" },{ "data": "StateDesc" },{ "data": "RecoveryModelDesc" },{ "data": "CreateDate" }]
     });
 } );
</script><table id="wsakgryo" class="display compact"><thead>  <tr><th>DatabaseId</th><th>DatabaseName</th><th>CompatibilityLevel</th><th>CollationName</th><th>UserAccessDesc</th><th>IsReadOnly</th><th>StateDesc</th><th>RecoveryModelDesc</th><th>CreateDate</th></tr></thead><tbody> <tr><td>1</td><td>master</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>SIMPLE</td><td>2003/4/8 9:13:36</td></tr> <tr><td>2</td><td>tempdb</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>SIMPLE</td><td>2018/12/29 12:07:19</td></tr> <tr><td>3</td><td>model</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>FULL</td><td>2003/4/8 9:13:36</td></tr> <tr><td>4</td><td>msdb</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>SIMPLE</td><td>2016/4/30 0:46:38</td></tr> <tr><td>5</td><td>demo</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>FULL</td><td>2019/2/1 9:35:38</td></tr> <tr><td>6</td><td>uc_hzc</td><td>100</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>SIMPLE</td><td>2018/8/29 21:04:20</td></tr> <tr><td>7</td><td>test</td><td>130</td><td>Latin1_General_BIN2</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>SIMPLE</td><td>2018/8/10 14:11:00</td></tr> <tr><td>8</td><td>uc_hzc_proc</td><td>100</td><td></td><td>MULTI_USER</td><td>False</td><td>OFFLINE</td><td>SIMPLE</td><td>2018/8/24 16:45:29</td></tr> <tr><td>9</td><td>bank</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>SIMPLE</td><td>2018/12/29 12:07:42</td></tr> <tr><td>10</td><td>DemoRepl</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>FULL</td><td>2019/2/1 9:40:38</td></tr> <tr><td>11</td><td>TestRepl</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>FULL</td><td>2019/2/1 10:15:15</td></tr> <tr><td>12</td><td>Test2016Pub</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>FULL</td><td>2019/2/1 10:51:37</td></tr> <tr><td>13</td><td>DemoRepl2</td><td>130</td><td>Chinese_PRC_CI_AS</td><td>MULTI_USER</td><td>False</td><td>ONLINE</td><td>FULL</td><td>2019/2/1 12:53:20</td></tr> </tbody> </table>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Database File Information">Database File Information</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#ebrufdxv').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "DatabaseId" },{ "data": "DatabaseName" },{ "data": "LogicName" },{ "data": "TypeDesc" },{ "data": "StateDesc" },{ "data": "Size" },{ "data": "MaxSize" },{ "data": "Growth" },{ "data": "PhysicalName" }]
     });
 } );
</script><table id="ebrufdxv" class="display compact"><thead>  <tr><th>DatabaseId</th><th>DatabaseName</th><th>LogicName</th><th>TypeDesc</th><th>StateDesc</th><th>Size</th><th>MaxSize</th><th>Growth</th><th>PhysicalName</th></tr></thead><tbody> <tr><td>1</td><td>master</td><td>master</td><td>ROWS</td><td>ONLINE</td><td>5.38 MB</td><td>unlimited</td><td>10%</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\master.mdf</td></tr> <tr><td>1</td><td>master</td><td>mastlog</td><td>LOG</td><td>ONLINE</td><td>2.25 MB</td><td>unlimited</td><td>10%</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\mastlog.ldf</td></tr> <tr><td>2</td><td>tempdb</td><td>tempdev</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\tempdb.mdf</td></tr> <tr><td>2</td><td>tempdb</td><td>templog</td><td>LOG</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\templog.ldf</td></tr> <tr><td>2</td><td>tempdb</td><td>temp2</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\tempdb_mssql_2.ndf</td></tr> <tr><td>2</td><td>tempdb</td><td>temp3</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\tempdb_mssql_3.ndf</td></tr> <tr><td>2</td><td>tempdb</td><td>temp4</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\tempdb_mssql_4.ndf</td></tr> <tr><td>3</td><td>model</td><td>modeldev</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\model.mdf</td></tr> <tr><td>3</td><td>model</td><td>modellog</td><td>LOG</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\modellog.ldf</td></tr> <tr><td>4</td><td>msdb</td><td>MSDBData</td><td>ROWS</td><td>ONLINE</td><td>17.94 MB</td><td>unlimited</td><td>10%</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\MSDBData.mdf</td></tr> <tr><td>4</td><td>msdb</td><td>MSDBLog</td><td>LOG</td><td>ONLINE</td><td>28.81 MB</td><td>2 TB</td><td>10%</td><td>D:\Program Files\Microsoft SQL Server\MSSQL13.MSSQL2016\MSSQL\DATA\MSDBLog.ldf</td></tr> <tr><td>5</td><td>demo</td><td>demo</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\MSSQL\demo.mdf</td></tr> <tr><td>5</td><td>demo</td><td>demo_log</td><td>LOG</td><td>ONLINE</td><td>8 MB</td><td>2 TB</td><td>64 MB</td><td>D:\MSSQL\demo_log.ldf</td></tr> <tr><td>6</td><td>uc_hzc</td><td>uc_hzc</td><td>ROWS</td><td>ONLINE</td><td>166 MB</td><td>unlimited</td><td>1 MB</td><td>D:\MSSQL\uc_hzc.mdf</td></tr> <tr><td>6</td><td>uc_hzc</td><td>uc_hzc_log</td><td>LOG</td><td>ONLINE</td><td>42.25 MB</td><td>2 TB</td><td>10%</td><td>D:\MSSQL\uc_hzc_log.ldf</td></tr> <tr><td>7</td><td>test</td><td>test</td><td>ROWS</td><td>ONLINE</td><td>72 MB</td><td>unlimited</td><td>64 MB</td><td>D:\MSSQL\test.mdf</td></tr> <tr><td>7</td><td>test</td><td>test_log</td><td>LOG</td><td>ONLINE</td><td>72 MB</td><td>2 TB</td><td>64 MB</td><td>D:\MSSQL\test_log.ldf</td></tr> <tr><td>8</td><td>uc_hzc_proc</td><td>uc_hzc</td><td>ROWS</td><td>ONLINE</td><td>166 MB</td><td>unlimited</td><td>1 MB</td><td>D:\MSSQL\uc_hzc_proc.mdf</td></tr> <tr><td>8</td><td>uc_hzc_proc</td><td>uc_hzc_log</td><td>LOG</td><td>ONLINE</td><td>42.25 MB</td><td>2 TB</td><td>10%</td><td>D:\MSSQL\uc_hzc_proc_log.ldf</td></tr> <tr><td>9</td><td>bank</td><td>bank</td><td>ROWS</td><td>ONLINE</td><td>14.57 GB</td><td>unlimited</td><td>64 MB</td><td>D:\MSSQL\bank.mdf</td></tr> <tr><td>9</td><td>bank</td><td>bank_log</td><td>LOG</td><td>ONLINE</td><td>72 MB</td><td>2 TB</td><td>64 MB</td><td>D:\MSSQL\bank_log.ldf</td></tr> <tr><td>10</td><td>DemoRepl</td><td>DemoRepl</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\MSSQL\DemoRepl.mdf</td></tr> <tr><td>10</td><td>DemoRepl</td><td>DemoRepl_log</td><td>LOG</td><td>ONLINE</td><td>8 MB</td><td>2 TB</td><td>64 MB</td><td>D:\MSSQL\DemoRepl_log.ldf</td></tr> <tr><td>11</td><td>TestRepl</td><td>TestRepl</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\MSSQL\TestRepl.mdf</td></tr> <tr><td>11</td><td>TestRepl</td><td>TestRepl_log</td><td>LOG</td><td>ONLINE</td><td>8 MB</td><td>2 TB</td><td>64 MB</td><td>D:\MSSQL\TestRepl_log.ldf</td></tr> <tr><td>12</td><td>Test2016Pub</td><td>Test2016Pub</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\MSSQL\Test2016Pub.mdf</td></tr> <tr><td>12</td><td>Test2016Pub</td><td>Test2016Pub_log</td><td>LOG</td><td>ONLINE</td><td>8 MB</td><td>2 TB</td><td>64 MB</td><td>D:\MSSQL\Test2016Pub_log.ldf</td></tr> <tr><td>13</td><td>DemoRepl2</td><td>DemoRepl2</td><td>ROWS</td><td>ONLINE</td><td>8 MB</td><td>unlimited</td><td>64 MB</td><td>D:\MSSQL\DemoRepl2.mdf</td></tr> <tr><td>13</td><td>DemoRepl2</td><td>DemoRepl2_log</td><td>LOG</td><td>ONLINE</td><td>8 MB</td><td>2 TB</td><td>64 MB</td><td>D:\MSSQL\DemoRepl2_log.ldf</td></tr> </tbody> </table>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Transaction Log">Transaction Log</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<div class="first column">
<div class="section">
<div class="header">
    <a name="Transaction Log Size">Transaction Log Size</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#dsusexnh').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "DatabaseName" },{ "data": "LogSize" },{ "data": "LogSpaceUsed(%)" },{ "data": "Status" }]
     });
 } );
</script><table id="dsusexnh" class="display compact"><thead>  <tr><th>DatabaseName</th><th>LogSize</th><th>LogSpaceUsed(%)</th><th>Status</th></tr></thead><tbody> <tr><td>master</td><td>2.24 MB</td><td>41.98606</td><td>0</td></tr> <tr><td>tempdb</td><td>7.99 MB</td><td>9.921799</td><td>0</td></tr> <tr><td>model</td><td>7.99 MB</td><td>28.20137</td><td>0</td></tr> <tr><td>msdb</td><td>28.8 MB</td><td>6.495796</td><td>0</td></tr> <tr><td>demo</td><td>7.99 MB</td><td>6.451613</td><td>0</td></tr> <tr><td>uc_hzc</td><td>42.24 MB</td><td>7.749214</td><td>0</td></tr> <tr><td>test</td><td>71.99 MB</td><td>13.78188</td><td>0</td></tr> <tr><td>bank</td><td>71.99 MB</td><td>12.89202</td><td>0</td></tr> <tr><td>DemoRepl</td><td>7.99 MB</td><td>13.04985</td><td>0</td></tr> <tr><td>TestRepl</td><td>7.99 MB</td><td>10.65494</td><td>0</td></tr> <tr><td>Test2016Pub</td><td>7.99 MB</td><td>17.54643</td><td>0</td></tr> <tr><td>DemoRepl2</td><td>7.99 MB</td><td>9.824047</td><td>0</td></tr> </tbody> </table>
    </div>
    </div>
</div>
<div class="second column">
<div class="section">
<div class="header">
    <a name="Transaction Log Size">Transaction Log Size</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<canvas id="bWFaAniVQSpK" width="500" height="300"></canvas>
<script>
var ctx = document.getElementById("bWFaAniVQSpK");
var bWFaAniVQSpK = new Chart(ctx, {
	type: 'bar',
	data:	{
		labels: ["bank","test","uc_hzc","msdb","TestRepl","Test2016Pub","DemoRepl","model","tempdb","DemoRepl2"],
		datasets: [{
			label: 'Data',
			data: [71.99219,71.99219,42.24219,28.80469,7.992188,7.992188,7.992188,7.992188,7.992188,7.992188],
			backgroundColor: ['rgba(118,174,40,0.7)','rgba(239,175,121,0.7)','rgba(181,180,138,0.7)','rgba(224,178,121,0.7)','rgba(136,183,116,0.7)','rgba(242,174,58,0.7)','rgba(143,172,142,0.7)','rgba(43,181,64,0.7)','rgba(101,184,205,0.7)','rgba(93,180,5,0.7)'],
			borderColor:  ['rgba(118,174,40,1)','rgba(239,175,121,1)','rgba(181,180,138,1)','rgba(224,178,121,1)','rgba(136,183,116,1)','rgba(242,174,58,1)','rgba(143,172,142,1)','rgba(43,181,64,1)','rgba(101,184,205,1)','rgba(93,180,5,1)'],
			hoverBackgroundColor:  ['rgba(118,174,40,1)','rgba(239,175,121,1)','rgba(181,180,138,1)','rgba(224,178,121,1)','rgba(136,183,116,1)','rgba(242,174,58,1)','rgba(143,172,142,1)','rgba(43,181,64,1)','rgba(101,184,205,1)','rgba(93,180,5,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: true,
		legend: {
                position: 'none',
            },
		title: {
				display: true,
				text: ' MaxSize TOP 10 (MB)'
			},
scales: {
                        xAxes: [{
                            display: false,
                            scaleLabel: {
                                display: false,
                                labelString: ''
                            }
                        }],
                        yAxes: [{
                            display: false,
                            scaleLabel: {
                                display: false,
                                labelString: ''
                            },
							ticks: {
								beginAtZero:true
							}
                        }]
                    },
	
	
	}

});	
 </script>
    </div>
    </div>
</div>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Error Log">Error Log</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<div class="first column">
<div class="section">
<div class="header">
    <a name="SQL Server Error Log Size">SQL Server Error Log Size</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#eavoypwg').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "FileId" },{ "data": "Date" },{ "data": "Size" }]
     });
 } );
</script><table id="eavoypwg" class="display compact"><thead>  <tr><th>FileId</th><th>Date</th><th>Size</th></tr></thead><tbody> <tr><td>0</td><td>01/31/2019  19:23</td><td>124.34 KB</td></tr> <tr><td>1</td><td>12/28/2018  11:02</td><td>157.21 KB</td></tr> <tr><td>2</td><td>11/14/2018  19:07</td><td>19.35 KB</td></tr> <tr><td>3</td><td>11/06/2018  22:30</td><td>124.42 KB</td></tr> <tr><td>4</td><td>10/11/2018  14:51</td><td>18.23 KB</td></tr> <tr><td>5</td><td>10/11/2018  14:51</td><td>19.47 KB</td></tr> <tr><td>6</td><td>10/11/2018  14:44</td><td>18.07 KB</td></tr> </tbody> </table>
    </div>
    </div>
</div>
<div class="second column">
<div class="section">
<div class="header">
    <a name="Agent Error Log Size">Agent Error Log Size</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#poxkabvb').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "FileId" },{ "data": "Date" },{ "data": "Size" }]
     });
 } );
</script><table id="poxkabvb" class="display compact"><thead>  <tr><th>FileId</th><th>Date</th><th>Size</th></tr></thead><tbody> <tr><td>1</td><td>12/28/2018  11:01</td><td>2.35 KB</td></tr> <tr><td>2</td><td>12/10/2018  14:01</td><td>2.76 KB</td></tr> <tr><td>3</td><td>11/14/2018  19:09</td><td>5.01 KB</td></tr> <tr><td>4</td><td>10/11/2018  14:42</td><td>2.2 KB</td></tr> <tr><td>5</td><td>10/10/2018  20:01</td><td>5.01 KB</td></tr> <tr><td>6</td><td>10/09/2018  16:08</td><td>2.43 KB</td></tr> <tr><td>7</td><td>09/13/2018  23:03</td><td>4.85 KB</td></tr> <tr><td>8</td><td>08/20/2018  12:46</td><td>5.09 KB</td></tr> <tr><td>9</td><td>08/16/2018  09:25</td><td>4.85 KB</td></tr> <tr><td>0</td><td>01/30/2019  17:22</td><td>0 Byte</td></tr> </tbody> </table>
    </div>
    </div>
</div>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Login Name">Login Name</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<table class="sortable">

<tr><th>name</th><th>TypeDesc</th><th>CreateDate</th><th>ModifyDate</th><th>DefaultDatabaseName</th><th>IsDisabled</th></tr>
<tr class="yellow"><td>sa</td><td>SQL_LOGIN</td><td>2003/4/8 9:10:35</td><td>2018/4/3 9:56:55</td><td>master</td><td>True</td></tr>
<tr class="yellow"><td>##MS_PolicyTsqlExecutionLogin##</td><td>SQL_LOGIN</td><td>2016/4/30 0:46:49</td><td>2018/4/3 10:02:47</td><td>master</td><td>True</td></tr>
<tr><td>TSECHENG\tsecheng</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:56:55</td><td>2018/4/3 9:56:55</td><td>master</td><td>False</td></tr>
<tr><td>TSECHENG\Administrator</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:56:55</td><td>2018/4/3 9:56:55</td><td>master</td><td>False</td></tr>
<tr><td>NT SERVICE\SQLWriter</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:56:55</td><td>2018/4/3 9:56:55</td><td>master</td><td>False</td></tr>
<tr><td>NT SERVICE\Winmgmt</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:56:55</td><td>2018/4/3 9:56:55</td><td>master</td><td>False</td></tr>
<tr><td>NT Service\MSSQL$MSSQL2016</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:56:55</td><td>2018/4/3 9:56:55</td><td>master</td><td>False</td></tr>
<tr><td>NT AUTHORITY\SYSTEM</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:56:55</td><td>2018/4/3 9:56:55</td><td>master</td><td>False</td></tr>
<tr><td>NT SERVICE\SQLAgent$MSSQL2016</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:56:59</td><td>2018/4/3 9:56:59</td><td>master</td><td>False</td></tr>
<tr><td>NT SERVICE\SQLTELEMETRY$MSSQL2016</td><td>WINDOWS_LOGIN</td><td>2018/4/3 9:57:01</td><td>2018/4/3 9:57:01</td><td>master</td><td>False</td></tr>
<tr class="yellow"><td>##MS_PolicyEventProcessingLogin##</td><td>SQL_LOGIN</td><td>2018/4/3 10:02:47</td><td>2018/4/3 10:02:47</td><td>master</td><td>True</td></tr>
<tr><td>kk</td><td>SQL_LOGIN</td><td>2018/4/10 9:36:13</td><td>2019/2/1 10:19:07</td><td>master</td><td>False</td></tr>
</table>
</table>
    </div>
    </div>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="Jobs" class="tabcontent">
<h7>Report: 2019-02-01</h7>
<div class="section">
<div class="header">
    <a name="Jobs Base Information">Jobs Base Information</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#ihdfngyt').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "JobNme" },{ "data": "Enabled" },{ "data": "OwnerUser" },{ "data": "Description" },{ "data": "DateCreated" },{ "data": "DateModified" },{ "data": "NextRunDate" },{ "data": "NextRunTime" }]
     });
 } );
</script><table id="ihdfngyt" class="display compact"><thead>  <tr><th>JobNme</th><th>Enabled</th><th>OwnerUser</th><th>Description</th><th>DateCreated</th><th>DateModified</th><th>NextRunDate</th><th>NextRunTime</th></tr></thead><tbody> <tr><td>syspolicy_purge_history</td><td>1</td><td>sa</td><td></td><td>2018/4/3 9:56:59</td><td>2018/4/3 9:57:01</td><td>20190202</td><td>20000</td></tr> <tr><td>TSECHENG\MSSQL2017-DemoRepl-repl_2017_2016-TSECHENG\MSSQL2016-DemoRepl-9D12BF80-FE22-473C-871F-630CD5F80D17</td><td>1</td><td>TSECHENG\tsecheng</td><td></td><td>2019/2/1 9:49:31</td><td>2019/2/1 9:49:31</td><td>0</td><td>0</td></tr> <tr><td>test_job</td><td>1</td><td>TSECHENG\tsecheng</td><td></td><td>2019/1/31 17:07:00</td><td>2019/1/31 17:07:00</td><td></td><td></td></tr> <tr><td></td><td>1</td><td>TSECHENG\tsecheng</td><td></td><td>2019/2/1 11:00:01</td><td>2019/2/1 11:00:01</td><td>20190202</td><td>10000</td></tr> </tbody> </table>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Jobs History">Jobs History</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#qokkcwrp').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "JobNme" },{ "data": "Enabled" },{ "data": "Server" },{ "data": "RunDate" },{ "data": "RunTime" },{ "data": "RunSeconds" },{ "data": "RunStatus" },{ "data": "Message" }]
     });
 } );
</script><table id="qokkcwrp" class="display compact"><thead>  <tr><th>JobNme</th><th>Enabled</th><th>Server</th><th>RunDate</th><th>RunTime</th><th>RunSeconds</th><th>RunStatus</th><th>Message</th></tr></thead><tbody> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20180930</td><td>20001</td><td>3</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181010</td><td>105553</td><td>4</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181011</td><td>20000</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181115</td><td>20000</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181116</td><td>20000</td><td>4</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181120</td><td>20000</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181121</td><td>20000</td><td>4</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181122</td><td>20001</td><td>3</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181123</td><td>20000</td><td>2</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181124</td><td>91400</td><td>8</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181127</td><td>20000</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181128</td><td>20000</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181129</td><td>20001</td><td>3</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181130</td><td>20001</td><td>3</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181201</td><td>20000</td><td>4</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181205</td><td>20000</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181206</td><td>20000</td><td>4</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181207</td><td>20000</td><td>3</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181221</td><td>20001</td><td>4</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181225</td><td>20000</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181226</td><td>20000</td><td>6</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181227</td><td>20001</td><td>5</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20181228</td><td>20000</td><td>4</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20190131</td><td>20000</td><td>2</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>syspolicy_purge_history</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20190201</td><td>20000</td><td>2</td><td>1</td><td>   8 (syspolicy_purge_history_schedule)  3 (Erase Phantom System Health Records.).</td></tr> <tr><td>test_job</td><td>1</td><td>TSECHENG\MSSQL2016</td><td>20190131</td><td>170709</td><td>0</td><td>0</td><td>   TSECHENG\tsecheng  1 (test_step1).</td></tr> </tbody> </table>
    </div>
    </div>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="Backup&Restore" class="tabcontent">
<h7>Report: 2019-02-01</h7>
<div class="section">
<div class="header">
    <a name="Database Backup">Database Backup</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<div class="first column">
<div class="section">
<div class="header">
    <a name="The Latest Backup">The Latest Backup</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#vlpljqwx').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "DatabaseName" },{ "data": "FullBackupTime" },{ "data": "DiffBackupTime" },{ "data": "LogBackupTime" }]
     });
 } );
</script><table id="vlpljqwx" class="display compact"><thead>  <tr><th>DatabaseName</th><th>FullBackupTime</th><th>DiffBackupTime</th><th>LogBackupTime</th></tr></thead><tbody> <tr><td>bank</td><td>2018/12/29 13:10:30</td><td></td><td></td></tr> <tr><td>demo</td><td>2018/6/28 14:14:04</td><td></td><td>2018/6/28 14:15:59</td></tr> <tr><td>DemoRepl</td><td></td><td></td><td></td></tr> <tr><td>DemoRepl2</td><td></td><td></td><td></td></tr> <tr><td>master</td><td></td><td></td><td></td></tr> <tr><td>model</td><td></td><td></td><td></td></tr> <tr><td>msdb</td><td></td><td></td><td></td></tr> <tr><td>tempdb</td><td></td><td></td><td></td></tr> <tr><td>test</td><td></td><td></td><td></td></tr> <tr><td>Test2016Pub</td><td></td><td></td><td></td></tr> <tr><td>TestRepl</td><td></td><td></td><td></td></tr> <tr><td>uc_hzc</td><td>2018/9/1 2:57:20</td><td></td><td></td></tr> <tr><td>uc_hzc_proc</td><td></td><td></td><td></td></tr> </tbody> </table>
    </div>
    </div>
</div>
<div class="second column">
<div class="section">
<div class="header">
    <a name="Backup Information">Backup Information</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<canvas id="BhIJmxbAruKp" width="300" height="300"></canvas>
<script>
var ctx = document.getElementById("BhIJmxbAruKp");
var BhIJmxbAruKp = new Chart(ctx, {
	type: 'doughnut',
	data:	{
		labels: ["never backup","has backup"],
		datasets: [{
			label: 'Data',
			data: [10,3],
			backgroundColor: ['rgba(72,40,69,0.7)','rgba(70,52,101,0.7)'],
			hoverBackgroundColor:  ['rgba(72,40,69,1)','rgba(70,52,101,1)'],
			borderWidth: 1
		}]
	},
	options: {
		responsive: false,
		legend: {
                position: 'bottom',
            },
		title: {
				display: true,
				text: 'Database Backup'
			},
	},
	animation: {
                animateScale: true,
                animateRotate: true
            }
});	
 </script>
    </div>
    </div>
</div>
<div class="section">
<div class="header">
    <a name="Backup History">Backup History</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#eqasyiyo').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "DatabaseName" },{ "data": "BackupType" },{ "data": "LatestBackupTime" },{ "data": "BackupSize" },{ "data": "BackupTimeCost_Minute" },{ "data": "BackupPath" }]
     });
 } );
</script><table id="eqasyiyo" class="display compact"><thead>  <tr><th>DatabaseName</th><th>BackupType</th><th>LatestBackupTime</th><th>BackupSize</th><th>BackupTimeCost_Minute</th><th>BackupPath</th></tr></thead><tbody> <tr><td>bank</td><td>Full</td><td>2018-12-29 13:06:31</td><td>1.77 GB</td><td>4</td><td>E:\00000\</td></tr> <tr><td>uc_hzc</td><td>Full</td><td>2018-09-01 02:57:20</td><td>17.57 MB</td><td>0</td><td>D:\MSSQL\Backup\</td></tr> <tr><td>Demo</td><td>Log</td><td>2018-06-28 14:15:59</td><td>8.44 KB</td><td>0</td><td>E:\00000\</td></tr> <tr><td>Demo</td><td>Full</td><td>2018-06-28 14:14:04</td><td>540.48 KB</td><td>0</td><td>E:\00000\</td></tr> </tbody> </table>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Restore History">Restore History</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#dncayzit').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "UserName" },{ "data": "DestDatabaseName" },{ "data": "RestoreType" },{ "data": "RestoreDate" },{ "data": "Replace" },{ "data": "Recovery" },{ "data": "Restart" },{ "data": "StopAt" },{ "data": "FileNumber" },{ "data": "DestPhysName" }]
     });
 } );
</script><table id="dncayzit" class="display compact"><thead>  <tr><th>UserName</th><th>DestDatabaseName</th><th>RestoreType</th><th>RestoreDate</th><th>Replace</th><th>Recovery</th><th>Restart</th><th>StopAt</th><th>FileNumber</th><th>DestPhysName</th></tr></thead><tbody> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/9/1 2:58:20</td><td>True</td><td>True</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\uc_hzc.mdf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/9/1 2:58:20</td><td>True</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\uc_hzc_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/31 22:13:31</td><td>True</td><td>True</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\uc_hzc.mdf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/31 22:13:31</td><td>True</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\uc_hzc_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/31 21:01:27</td><td>True</td><td>True</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\uc_hzc.mdf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/31 21:01:27</td><td>True</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\uc_hzc_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/31 19:18:13</td><td>True</td><td>True</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\uc_hzc.mdf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/31 19:18:13</td><td>True</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\uc_hzc_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/29 21:04:20</td><td>False</td><td>True</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\uc_hzc.mdf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>uc_hzc</td><td>Full</td><td>2018/8/29 21:04:20</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\uc_hzc_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:27:43</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:27:32</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:18:01</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:17:29</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:17:17</td><td>False</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:17:14</td><td>False</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:17:05</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:16:58</td><td>False</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:16:33</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Full</td><td>2018/6/28 14:16:15</td><td>True</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Full</td><td>2018/6/28 14:16:15</td><td>True</td><td>False</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\Demo.mdf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:12:38</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:12:35</td><td>False</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:12:33</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:07:07</td><td>False</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:05:58</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:05:39</td><td>False</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:05:07</td><td>False</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Log</td><td>2018/6/28 14:04:04</td><td>False</td><td>True</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Full</td><td>2018/6/28 13:56:53</td><td>True</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>Demo</td><td>Full</td><td>2018/6/28 13:56:53</td><td>True</td><td>False</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\Demo.mdf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>demo</td><td>Log</td><td>2018/6/8 11:05:54</td><td>False</td><td>True</td><td>False</td><td>2018/6/8 10:50:03</td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>demo</td><td>Full</td><td>2018/6/8 11:05:47</td><td>True</td><td>False</td><td>False</td><td></td><td>2</td><td>D:\MSSQL\Demo_log.ldf</td></tr> <tr><td>TSECHENG\tsecheng</td><td>demo</td><td>Full</td><td>2018/6/8 11:05:47</td><td>True</td><td>False</td><td>False</td><td></td><td>1</td><td>D:\MSSQL\Demo.mdf</td></tr> </tbody> </table>
    </div>
    </div>
    </div>
    </div>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="Mirror" class="tabcontent">
<h7>Report: 2019-02-01</h7>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="Replication" class="tabcontent">
<h7>Report: 2019-02-01</h7>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="AlwaysOn-AG" class="tabcontent">
<h7>Report: 2019-02-01</h7>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="AlwaysOn-FCI" class="tabcontent">
<h7>Report: 2019-02-01</h7>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<div id="Perfmon" class="tabcontent">
<h7>Report: 2019-02-01</h7>
<div class="section">
<div class="header">
    <a name="Buffer allocation">Buffer allocation</a> (<a id="show_764246799" href="#" onclick="show('764246799');" style="color: #ffffff;">Show</a><a id="hide_764246799" href="#" onclick="hide('764246799');" style="color: #ffffff; display:none;">Hide</a>)
</div>
<div class="content" id="764246799" style="display:none;background-color:#ffffff;"> 
<div class="first column">
<div class="section">
<div class="header">
    <a name="Database buffer pool allocation">Database buffer pool allocation</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#ihomyguj').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "DatabaseName" },{ "data": "CachedPagesCount" },{ "data": "CachedSpaceSize" },{ "data": "FreeSpaceSize" }]
     });
 } );
</script><table id="ihomyguj" class="display compact"><thead>  <tr><th>DatabaseName</th><th>CachedPagesCount</th><th>CachedSpaceSize</th><th>FreeSpaceSize</th></tr></thead><tbody> <tr><td>tempdb</td><td>189</td><td>1.48 MB</td><td>708.16 KB</td></tr> <tr><td>demo</td><td>6</td><td>48 KB</td><td>37.18 KB</td></tr> <tr><td>master</td><td>192</td><td>1.5 MB</td><td>787.23 KB</td></tr> <tr><td>DemoRepl</td><td>6</td><td>48 KB</td><td>33.91 KB</td></tr> <tr><td>Test2016Pub</td><td>190</td><td>1.48 MB</td><td>638.88 KB</td></tr> <tr><td>bank</td><td>6</td><td>48 KB</td><td>37 KB</td></tr> <tr><td>msdb</td><td>479</td><td>3.74 MB</td><td>1.71 MB</td></tr> <tr><td>DemoRepl2</td><td>14</td><td>112 KB</td><td>69.34 KB</td></tr> <tr><td>TestRepl</td><td>6</td><td>48 KB</td><td>34.24 KB</td></tr> <tr><td>ResourceDb</td><td>1785</td><td>13.95 MB</td><td>5.41 MB</td></tr> <tr><td>test</td><td>6</td><td>48 KB</td><td>36.32 KB</td></tr> <tr><td>model</td><td>4</td><td>32 KB</td><td>22.08 KB</td></tr> <tr><td>uc_hzc</td><td>6</td><td>48 KB</td><td>26.94 KB</td></tr> </tbody> </table>
    </div>
    </div>
</div>
<div class="second column">
<div class="section">
<div class="header">
    <a name="Database dirty page">Database dirty page</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#ruynzfom').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "DatabaseName" },{ "data": "DirtyPages" },{ "data": "DirtyPagesSize" }]
     });
 } );
</script><table id="ruynzfom" class="display compact"><thead>  <tr><th>DatabaseName</th><th>DirtyPages</th><th>DirtyPagesSize</th></tr></thead><tbody> <tr><td>master</td><td>4</td><td>32 KB</td></tr> <tr><td>tempdb</td><td>135</td><td>1.05 MB</td></tr> <tr><td>msdb</td><td>6</td><td>48 KB</td></tr> <tr><td>demo</td><td>1</td><td>8 KB</td></tr> <tr><td>DemoRepl</td><td>3</td><td>24 KB</td></tr> <tr><td>TestRepl</td><td>3</td><td>24 KB</td></tr> <tr><td>Test2016Pub</td><td>41</td><td>328 KB</td></tr> <tr><td>DemoRepl2</td><td>11</td><td>88 KB</td></tr> </tbody> </table>
    </div>
    </div>
</div>
    </div>
    </div>
<div class="section">
<div class="header">
    <a name="Cached Type Usage">Cached Type Usage</a> (<a id="show_1689870776" href="#" onclick="show('1689870776');" style="color: #ffffff;">Show</a><a id="hide_1689870776" href="#" onclick="hide('1689870776');" style="color: #ffffff; display:none;">Hide</a>)
</div>
<div class="content" id="1689870776" style="display:none;background-color:#ffffff;"> 
<div class="first column">
<div class="section">
<div class="header">
    <a name="Cached Type Size">Cached Type Size</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#xejuallm').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "CachedType" },{ "data": "NumberOfPlans" },{ "data": "Size" }]
     });
 } );
</script><table id="xejuallm" class="display compact"><thead>  <tr><th>CachedType</th><th>NumberOfPlans</th><th>Size</th></tr></thead><tbody> <tr><td>Parse Tree</td><td>13</td><td>2.41 MB</td></tr> <tr><td>Extended Proc</td><td>6</td><td>48 KB</td></tr> <tr><td>Compiled Plan</td><td>19</td><td>2.8 MB</td></tr> </tbody> </table>
    </div>
    </div>
</div>
<div class="second column">
<div class="section">
<div class="header">
    <a name="Cached Object Type Size">Cached Object Type Size</a>
</div>
<div class="content" style="background-color:#ffffff;"> 
<script>
 $(document).ready(function() {
     $('#wstzxxsi').DataTable({
		"paging":   true,
		"pagingType": "full_numbers",
		"lengthMenu": [[15,25, 50, 100, -1], [15,25, 50, 100, "All"]],
        "ordering": true,
        "info":     true,
         "columns": [{ "data": "CachedObjectType" },{ "data": "NumberOfPlans" },{ "data": "Size" }]
     });
 } );
</script><table id="wstzxxsi" class="display compact"><thead>  <tr><th>CachedObjectType</th><th>NumberOfPlans</th><th>Size</th></tr></thead><tbody> <tr><td>View</td><td>13</td><td>2.41 MB</td></tr> <tr><td>Adhoc</td><td>16</td><td>2.27 MB</td></tr> <tr><td>Proc</td><td>10</td><td>640 KB</td></tr> </tbody> </table>
    </div>
    </div>
</div>
    </div>
    </div>
</p>
</div>
<script>
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>
<hr />
<!-- FOOTER -->
<div class="footer"></div>

<!-- END BODY -->
</body>
</html>

